{"version":3,"file":"megolm.js","names":["isRoomSharedHistory","room","visibilityEvent","currentState","getStateEvents","visibility","getContent","history_visibility","includes","OutboundSessionInfo","constructor","sessionId","sharedHistory","creationTime","Date","getTime","needsRotation","rotationPeriodMsgs","rotationPeriodMs","sessionLifetime","useCount","logger","log","markSharedWithDevice","userId","deviceId","deviceKey","chainIndex","sharedWithDevices","messageIndex","markNotifiedBlockedDevice","blockedDevicesNotified","sharedWithTooManyDevices","devicesInRoom","hasOwnProperty","MegolmEncryption","EncryptionAlgorithm","params","Promise","resolve","roomId","sessionRotationPeriodMsgs","config","rotation_period_msgs","sessionRotationPeriodMs","rotation_period_ms","ensureOutboundSession","blocked","singleOlmCreationPhase","setup","oldSession","session","prepareSession","shareSession","fallible","setupPromise","then","catch","e","error","prepareNewSession","outboundSessions","shareMap","userDevices","Object","entries","deviceInfo","key","getIdentityKey","olmDevice","deviceCurve25519Key","undefined","push","getOutboundGroupSessionKey","payload","type","content","olmlib","MEGOLM_ALGORITHM","chain_index","devicesWithoutSession","olmSessions","getExistingOlmSessions","baseApis","all","debug","shareKeyWithOlmSessions","errorDevices","start","now","failedServers","shareKeyWithDevices","retryDevices","failedServerMap","Set","server","add","failedDevices","userHS","slice","indexOf","has","notifyFailedOlmDevices","length","blockedMap","blockedCount","userBlockedDevices","device","notifyBlockedDevices","createOutboundGroupSession","addInboundGroupSession","ed25519","deviceEd25519Key","crypto","backupManager","backupGroupSession","getDevicesWithoutSessions","devicemap","devicesByUser","noOlmDevices","devicesToShareWith","sessionResults","sessionResult","splitDevices","maxDevicesPerRequest","currentSlice","mapSlices","values","pop","encryptAndSendKeysToDevices","devices","encryptAndSendToDevices","sendBlockedNotificationsToDevices","userDeviceMap","contentMap","val","blockedInfo","message","code","reason","ToDeviceMessageId","uuidv4","room_id","session_id","sendToDevice","keys","reshareKeyWithDevice","senderKey","obSessionInfo","sessionSharedData","warn","getInboundGroupSessionKey","ensureOlmSessionsForDevices","sender_claimed_ed25519_key","forwarding_curve25519_key_chain","shared_history","encryptedContent","algorithm","OLM_ALGORITHM","sender_key","ciphertext","encryptMessageForDevice","otkTimeout","withPrefix","userDeviceMaps","i","taskDetail","map","d","unnotifiedFailedDevices","filterOutNotifiedErrorDevices","WITHHELD_MESSAGES","prepareToEncrypt","encryptionPreparation","elapsedTime","startTime","promise","getDevicesInRoom","globalErrorOnUnknownDevices","removeUnknownDevices","encryptMessage","eventType","forceDistributeToUnverified","isVerificationEvent","checkForUnknownDevices","payloadJson","encryptGroupMessage","JSON","stringify","device_id","EventType","KeyVerificationCancel","KeyVerificationDone","KeyVerificationMac","KeyVerificationStart","KeyVerificationKey","KeyVerificationReady","KeyVerificationAccept","RoomMessage","MsgType","KeyVerificationRequest","forceDiscardSession","unknownDevices","forEach","isUnverified","isKnown","UnknownDeviceError","members","getEncryptionTargetMembers","roomMembers","u","isBlacklisting","globalBlacklistUnverifiedDevices","isRoomBlacklisting","getBlacklistUnverifiedDevices","downloadKeys","deviceTrust","checkDeviceTrust","isBlocked","isVerified","MegolmDecryption","DecryptionAlgorithm","Map","decryptEvent","event","getWireContent","DecryptionError","addEventToPendingList","res","decryptGroupMessage","getRoomId","getId","getTs","name","errorCode","requestKeysForEvent","toString","queryKeyBackupRateLimited","problem","sessionMayHaveProblems","info","getSender","problemDescription","PROBLEM_DESCRIPTIONS","unknown","fixed","untrusted","removeEventFromPendingList","parse","result","clearEvent","senderCurve25519Key","claimedEd25519Key","keysClaimed","forwardingCurve25519KeyChain","wireContent","recipients","getKeyRequestRecipients","requestRoomKey","pendingEvents","set","senderPendingEvents","get","delete","size","onRoomKeyEvent","getSenderKey","forwardingKeyChain","exportFormat","extraSessionData","session_key","isOlmEncrypted","getType","deviceList","getDeviceByIdentityKey","senderKeyUser","getUserByIdentityKey","outgoingRequests","cryptoStore","getOutgoingRoomKeyRequestsByTarget","RoomKeyRequestState","Sent","weRequested","some","req","requestBody","getRoom","memberEvent","getMember","events","member","fromInviter","getUnsigned","prev_sender","getPrevContent","membership","fromUs","getUserId","Array","isArray","ed25519Key","parkedData","senderId","sessionKey","doTxn","txn","addParkedSharedHistory","sendingDevice","checkDeviceInfoTrust","getKeysClaimed","retryDecryption","cancelRoomKeyRequest","onRoomKeyWithheldEvent","sender","getSessionIdForDevice","recordSessionProblem","retryDecryptionFromSender","addInboundGroupSessionWithheld","hasKeysForKeyRequest","keyRequest","body","hasInboundSessionKeys","shareKeysWithDevice","getStoredDevice","olmSessionResult","buildKeyForwardingMessage","importRoomKey","source","sender_claimed_keys","forceRedecryptIfUntrusted","pending","ev","attemptDecryption","isRetry","_sessionId","sendSharedHistoryInboundSessions","sharedHistorySessions","getSharedHistoryInboundGroupSessions","promises","no_olm","registerAlgorithm"],"sources":["../../../src/crypto/algorithms/megolm.ts"],"sourcesContent":["/*\nCopyright 2015 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Defines m.olm encryption/decryption\n */\n\nimport { v4 as uuidv4 } from \"uuid\";\n\nimport type { IEventDecryptionResult, IMegolmSessionData } from \"../../@types/crypto\";\nimport { logger } from \"../../logger\";\nimport * as olmlib from \"../olmlib\";\nimport {\n    DecryptionAlgorithm,\n    DecryptionClassParams,\n    DecryptionError,\n    EncryptionAlgorithm,\n    IParams,\n    registerAlgorithm,\n    UnknownDeviceError,\n} from \"./base\";\nimport { IDecryptedGroupMessage, WITHHELD_MESSAGES } from \"../OlmDevice\";\nimport { Room } from \"../../models/room\";\nimport { DeviceInfo } from \"../deviceinfo\";\nimport { IOlmSessionResult } from \"../olmlib\";\nimport { DeviceInfoMap } from \"../DeviceList\";\nimport { IContent, MatrixEvent } from \"../../models/event\";\nimport { EventType, MsgType, ToDeviceMessageId } from \"../../@types/event\";\nimport { IMegolmEncryptedContent, IncomingRoomKeyRequest, IEncryptedContent } from \"../index\";\nimport { RoomKeyRequestState } from \"../OutgoingRoomKeyRequestManager\";\nimport { OlmGroupSessionExtraData } from \"../../@types/crypto\";\nimport { MatrixError } from \"../../http-api\";\n\n// determine whether the key can be shared with invitees\nexport function isRoomSharedHistory(room: Room): boolean {\n    const visibilityEvent = room?.currentState?.getStateEvents(\"m.room.history_visibility\", \"\");\n    // NOTE: if the room visibility is unset, it would normally default to\n    // \"world_readable\".\n    // (https://spec.matrix.org/unstable/client-server-api/#server-behaviour-5)\n    // But we will be paranoid here, and treat it as a situation where the room\n    // is not shared-history\n    const visibility = visibilityEvent?.getContent()?.history_visibility;\n    return [\"world_readable\", \"shared\"].includes(visibility);\n}\n\ninterface IBlockedDevice {\n    code: string;\n    reason: string;\n    deviceInfo: DeviceInfo;\n}\n\ninterface IBlockedMap {\n    [userId: string]: {\n        [deviceId: string]: IBlockedDevice;\n    };\n}\n\nexport interface IOlmDevice<T = DeviceInfo> {\n    userId: string;\n    deviceInfo: T;\n}\n\n/* eslint-disable camelcase */\nexport interface IOutboundGroupSessionKey {\n    chain_index: number;\n    key: string;\n}\n\ninterface IMessage {\n    type: string;\n    content: {\n        \"algorithm\": string;\n        \"room_id\": string;\n        \"sender_key\"?: string;\n        \"sender_claimed_ed25519_key\"?: string;\n        \"session_id\": string;\n        \"session_key\": string;\n        \"chain_index\": number;\n        \"forwarding_curve25519_key_chain\"?: string[];\n        \"org.matrix.msc3061.shared_history\": boolean;\n    };\n}\n\ninterface IKeyForwardingMessage extends IMessage {\n    type: \"m.forwarded_room_key\";\n}\n\ninterface IPayload extends Partial<IMessage> {\n    code?: string;\n    reason?: string;\n    room_id?: string;\n    session_id?: string;\n    algorithm?: string;\n    sender_key?: string;\n}\n/* eslint-enable camelcase */\n\ninterface SharedWithData {\n    // The identity key of the device we shared with\n    deviceKey: string;\n    // The message index of the ratchet we shared with that device\n    messageIndex: number;\n}\n\n/**\n * @internal\n */\nclass OutboundSessionInfo {\n    /** number of times this session has been used */\n    public useCount = 0;\n    /** when the session was created (ms since the epoch) */\n    public creationTime: number;\n    /** devices with which we have shared the session key `userId -> {deviceId -> SharedWithData}` */\n    public sharedWithDevices: Record<string, Record<string, SharedWithData>> = {};\n    public blockedDevicesNotified: Record<string, Record<string, boolean>> = {};\n\n    /**\n     * @param sharedHistory - whether the session can be freely shared with\n     *    other group members, according to the room history visibility settings\n     */\n    public constructor(public readonly sessionId: string, public readonly sharedHistory = false) {\n        this.creationTime = new Date().getTime();\n    }\n\n    /**\n     * Check if it's time to rotate the session\n     */\n    public needsRotation(rotationPeriodMsgs: number, rotationPeriodMs: number): boolean {\n        const sessionLifetime = new Date().getTime() - this.creationTime;\n\n        if (this.useCount >= rotationPeriodMsgs || sessionLifetime >= rotationPeriodMs) {\n            logger.log(\"Rotating megolm session after \" + this.useCount + \" messages, \" + sessionLifetime + \"ms\");\n            return true;\n        }\n\n        return false;\n    }\n\n    public markSharedWithDevice(userId: string, deviceId: string, deviceKey: string, chainIndex: number): void {\n        if (!this.sharedWithDevices[userId]) {\n            this.sharedWithDevices[userId] = {};\n        }\n        this.sharedWithDevices[userId][deviceId] = { deviceKey, messageIndex: chainIndex };\n    }\n\n    public markNotifiedBlockedDevice(userId: string, deviceId: string): void {\n        if (!this.blockedDevicesNotified[userId]) {\n            this.blockedDevicesNotified[userId] = {};\n        }\n        this.blockedDevicesNotified[userId][deviceId] = true;\n    }\n\n    /**\n     * Determine if this session has been shared with devices which it shouldn't\n     * have been.\n     *\n     * @param devicesInRoom - `userId -> {deviceId -> object}`\n     *   devices we should shared the session with.\n     *\n     * @returns true if we have shared the session with devices which aren't\n     * in devicesInRoom.\n     */\n    public sharedWithTooManyDevices(devicesInRoom: Record<string, Record<string, object>>): boolean {\n        for (const userId in this.sharedWithDevices) {\n            if (!this.sharedWithDevices.hasOwnProperty(userId)) {\n                continue;\n            }\n\n            if (!devicesInRoom.hasOwnProperty(userId)) {\n                logger.log(\"Starting new megolm session because we shared with \" + userId);\n                return true;\n            }\n\n            for (const deviceId in this.sharedWithDevices[userId]) {\n                if (!this.sharedWithDevices[userId].hasOwnProperty(deviceId)) {\n                    continue;\n                }\n\n                if (!devicesInRoom[userId].hasOwnProperty(deviceId)) {\n                    logger.log(\"Starting new megolm session because we shared with \" + userId + \":\" + deviceId);\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n}\n\n/**\n * Megolm encryption implementation\n *\n * @param params - parameters, as per {@link EncryptionAlgorithm}\n */\nexport class MegolmEncryption extends EncryptionAlgorithm {\n    // the most recent attempt to set up a session. This is used to serialise\n    // the session setups, so that we have a race-free view of which session we\n    // are using, and which devices we have shared the keys with. It resolves\n    // with an OutboundSessionInfo (or undefined, for the first message in the\n    // room).\n    private setupPromise = Promise.resolve<OutboundSessionInfo | null>(null);\n\n    // Map of outbound sessions by sessions ID. Used if we need a particular\n    // session (the session we're currently using to send is always obtained\n    // using setupPromise).\n    private outboundSessions: Record<string, OutboundSessionInfo> = {};\n\n    private readonly sessionRotationPeriodMsgs: number;\n    private readonly sessionRotationPeriodMs: number;\n    private encryptionPreparation?: {\n        promise: Promise<void>;\n        startTime: number;\n    };\n\n    protected readonly roomId: string;\n\n    public constructor(params: IParams & Required<Pick<IParams, \"roomId\">>) {\n        super(params);\n        this.roomId = params.roomId;\n\n        this.sessionRotationPeriodMsgs = params.config?.rotation_period_msgs ?? 100;\n        this.sessionRotationPeriodMs = params.config?.rotation_period_ms ?? 7 * 24 * 3600 * 1000;\n    }\n\n    /**\n     * @internal\n     *\n     * @param devicesInRoom - The devices in this room, indexed by user ID\n     * @param blocked - The devices that are blocked, indexed by user ID\n     * @param singleOlmCreationPhase - Only perform one round of olm\n     *     session creation\n     *\n     * This method updates the setupPromise field of the class by chaining a new\n     * call on top of the existing promise, and then catching and discarding any\n     * errors that might happen while setting up the outbound group session. This\n     * is done to ensure that `setupPromise` always resolves to `null` or the\n     * `OutboundSessionInfo`.\n     *\n     * Using `>>=` to represent the promise chaining operation, it does the\n     * following:\n     *\n     * ```\n     * setupPromise = previousSetupPromise >>= setup >>= discardErrors\n     * ```\n     *\n     * The initial value for the `setupPromise` is a promise that resolves to\n     * `null`. The forceDiscardSession() resets setupPromise to this initial\n     * promise.\n     *\n     * @returns Promise which resolves to the\n     *    OutboundSessionInfo when setup is complete.\n     */\n    private async ensureOutboundSession(\n        room: Room,\n        devicesInRoom: DeviceInfoMap,\n        blocked: IBlockedMap,\n        singleOlmCreationPhase = false,\n    ): Promise<OutboundSessionInfo> {\n        // takes the previous OutboundSessionInfo, and considers whether to create\n        // a new one. Also shares the key with any (new) devices in the room.\n        //\n        // returns a promise which resolves once the keyshare is successful.\n        const setup = async (oldSession: OutboundSessionInfo | null): Promise<OutboundSessionInfo> => {\n            const sharedHistory = isRoomSharedHistory(room);\n            const session = await this.prepareSession(devicesInRoom, sharedHistory, oldSession);\n\n            await this.shareSession(devicesInRoom, sharedHistory, singleOlmCreationPhase, blocked, session);\n\n            return session;\n        };\n\n        // first wait for the previous share to complete\n        const fallible = this.setupPromise.then(setup);\n\n        // Ensure any failures are logged for debugging and make sure that the\n        // promise chain remains unbroken\n        //\n        // setupPromise resolves to `null` or the `OutboundSessionInfo` whether\n        // or not the share succeeds\n        this.setupPromise = fallible.catch((e) => {\n            logger.error(`Failed to setup outbound session in ${this.roomId}`, e);\n            return null;\n        });\n\n        // but we return a promise which only resolves if the share was successful.\n        return fallible;\n    }\n\n    private async prepareSession(\n        devicesInRoom: DeviceInfoMap,\n        sharedHistory: boolean,\n        session: OutboundSessionInfo | null,\n    ): Promise<OutboundSessionInfo> {\n        // history visibility changed\n        if (session && sharedHistory !== session.sharedHistory) {\n            session = null;\n        }\n\n        // need to make a brand new session?\n        if (session?.needsRotation(this.sessionRotationPeriodMsgs, this.sessionRotationPeriodMs)) {\n            logger.log(\"Starting new megolm session because we need to rotate.\");\n            session = null;\n        }\n\n        // determine if we have shared with anyone we shouldn't have\n        if (session?.sharedWithTooManyDevices(devicesInRoom)) {\n            session = null;\n        }\n\n        if (!session) {\n            logger.log(`Starting new megolm session for room ${this.roomId}`);\n            session = await this.prepareNewSession(sharedHistory);\n            logger.log(`Started new megolm session ${session.sessionId} ` + `for room ${this.roomId}`);\n            this.outboundSessions[session.sessionId] = session;\n        }\n\n        return session;\n    }\n\n    private async shareSession(\n        devicesInRoom: DeviceInfoMap,\n        sharedHistory: boolean,\n        singleOlmCreationPhase: boolean,\n        blocked: IBlockedMap,\n        session: OutboundSessionInfo,\n    ): Promise<void> {\n        // now check if we need to share with any devices\n        const shareMap: Record<string, DeviceInfo[]> = {};\n\n        for (const [userId, userDevices] of Object.entries(devicesInRoom)) {\n            for (const [deviceId, deviceInfo] of Object.entries(userDevices)) {\n                const key = deviceInfo.getIdentityKey();\n                if (key == this.olmDevice.deviceCurve25519Key) {\n                    // don't bother sending to ourself\n                    continue;\n                }\n\n                if (!session.sharedWithDevices[userId] || session.sharedWithDevices[userId][deviceId] === undefined) {\n                    shareMap[userId] = shareMap[userId] || [];\n                    shareMap[userId].push(deviceInfo);\n                }\n            }\n        }\n\n        const key = this.olmDevice.getOutboundGroupSessionKey(session.sessionId);\n        const payload: IPayload = {\n            type: \"m.room_key\",\n            content: {\n                \"algorithm\": olmlib.MEGOLM_ALGORITHM,\n                \"room_id\": this.roomId,\n                \"session_id\": session.sessionId,\n                \"session_key\": key.key,\n                \"chain_index\": key.chain_index,\n                \"org.matrix.msc3061.shared_history\": sharedHistory,\n            },\n        };\n        const [devicesWithoutSession, olmSessions] = await olmlib.getExistingOlmSessions(\n            this.olmDevice,\n            this.baseApis,\n            shareMap,\n        );\n\n        await Promise.all([\n            (async (): Promise<void> => {\n                // share keys with devices that we already have a session for\n                logger.debug(`Sharing keys with existing Olm sessions in ${this.roomId}`, olmSessions);\n                await this.shareKeyWithOlmSessions(session, key, payload, olmSessions);\n                logger.debug(`Shared keys with existing Olm sessions in ${this.roomId}`);\n            })(),\n            (async (): Promise<void> => {\n                logger.debug(\n                    `Sharing keys (start phase 1) with new Olm sessions in ${this.roomId}`,\n                    devicesWithoutSession,\n                );\n                const errorDevices: IOlmDevice[] = [];\n\n                // meanwhile, establish olm sessions for devices that we don't\n                // already have a session for, and share keys with them.  If\n                // we're doing two phases of olm session creation, use a\n                // shorter timeout when fetching one-time keys for the first\n                // phase.\n                const start = Date.now();\n                const failedServers: string[] = [];\n                await this.shareKeyWithDevices(\n                    session,\n                    key,\n                    payload,\n                    devicesWithoutSession,\n                    errorDevices,\n                    singleOlmCreationPhase ? 10000 : 2000,\n                    failedServers,\n                );\n                logger.debug(`Shared keys (end phase 1) with new Olm sessions in ${this.roomId}`);\n\n                if (!singleOlmCreationPhase && Date.now() - start < 10000) {\n                    // perform the second phase of olm session creation if requested,\n                    // and if the first phase didn't take too long\n                    (async (): Promise<void> => {\n                        // Retry sending keys to devices that we were unable to establish\n                        // an olm session for.  This time, we use a longer timeout, but we\n                        // do this in the background and don't block anything else while we\n                        // do this.  We only need to retry users from servers that didn't\n                        // respond the first time.\n                        const retryDevices: Record<string, DeviceInfo[]> = {};\n                        const failedServerMap = new Set();\n                        for (const server of failedServers) {\n                            failedServerMap.add(server);\n                        }\n                        const failedDevices: IOlmDevice[] = [];\n                        for (const { userId, deviceInfo } of errorDevices) {\n                            const userHS = userId.slice(userId.indexOf(\":\") + 1);\n                            if (failedServerMap.has(userHS)) {\n                                retryDevices[userId] = retryDevices[userId] || [];\n                                retryDevices[userId].push(deviceInfo);\n                            } else {\n                                // if we aren't going to retry, then handle it\n                                // as a failed device\n                                failedDevices.push({ userId, deviceInfo });\n                            }\n                        }\n\n                        logger.debug(`Sharing keys (start phase 2) with new Olm sessions in ${this.roomId}`);\n                        await this.shareKeyWithDevices(session, key, payload, retryDevices, failedDevices, 30000);\n                        logger.debug(`Shared keys (end phase 2) with new Olm sessions in ${this.roomId}`);\n\n                        await this.notifyFailedOlmDevices(session, key, failedDevices);\n                    })();\n                } else {\n                    await this.notifyFailedOlmDevices(session, key, errorDevices);\n                }\n                logger.debug(`Shared keys (all phases done) with new Olm sessions in ${this.roomId}`);\n            })(),\n            (async (): Promise<void> => {\n                logger.debug(\n                    `There are ${Object.entries(blocked).length} blocked devices in ${this.roomId}`,\n                    Object.entries(blocked),\n                );\n\n                // also, notify newly blocked devices that they're blocked\n                logger.debug(`Notifying newly blocked devices in ${this.roomId}`);\n                const blockedMap: Record<string, Record<string, { device: IBlockedDevice }>> = {};\n                let blockedCount = 0;\n                for (const [userId, userBlockedDevices] of Object.entries(blocked)) {\n                    for (const [deviceId, device] of Object.entries(userBlockedDevices)) {\n                        if (\n                            !session.blockedDevicesNotified[userId] ||\n                            session.blockedDevicesNotified[userId][deviceId] === undefined\n                        ) {\n                            blockedMap[userId] = blockedMap[userId] || {};\n                            blockedMap[userId][deviceId] = { device };\n                            blockedCount++;\n                        }\n                    }\n                }\n\n                await this.notifyBlockedDevices(session, blockedMap);\n                logger.debug(`Notified ${blockedCount} newly blocked devices in ${this.roomId}`, blockedMap);\n            })(),\n        ]);\n    }\n\n    /**\n     * @internal\n     *\n     *\n     * @returns session\n     */\n    private async prepareNewSession(sharedHistory: boolean): Promise<OutboundSessionInfo> {\n        const sessionId = this.olmDevice.createOutboundGroupSession();\n        const key = this.olmDevice.getOutboundGroupSessionKey(sessionId);\n\n        await this.olmDevice.addInboundGroupSession(\n            this.roomId,\n            this.olmDevice.deviceCurve25519Key!,\n            [],\n            sessionId,\n            key.key,\n            { ed25519: this.olmDevice.deviceEd25519Key! },\n            false,\n            { sharedHistory },\n        );\n\n        // don't wait for it to complete\n        this.crypto.backupManager.backupGroupSession(this.olmDevice.deviceCurve25519Key!, sessionId);\n\n        return new OutboundSessionInfo(sessionId, sharedHistory);\n    }\n\n    /**\n     * Determines what devices in devicesByUser don't have an olm session as given\n     * in devicemap.\n     *\n     * @internal\n     *\n     * @param devicemap - the devices that have olm sessions, as returned by\n     *     olmlib.ensureOlmSessionsForDevices.\n     * @param devicesByUser - a map of user IDs to array of deviceInfo\n     * @param noOlmDevices - an array to fill with devices that don't have\n     *     olm sessions\n     *\n     * @returns an array of devices that don't have olm sessions.  If\n     *     noOlmDevices is specified, then noOlmDevices will be returned.\n     */\n    private getDevicesWithoutSessions(\n        devicemap: Record<string, Record<string, IOlmSessionResult>>,\n        devicesByUser: Record<string, DeviceInfo[]>,\n        noOlmDevices: IOlmDevice[] = [],\n    ): IOlmDevice[] {\n        for (const [userId, devicesToShareWith] of Object.entries(devicesByUser)) {\n            const sessionResults = devicemap[userId];\n\n            for (const deviceInfo of devicesToShareWith) {\n                const deviceId = deviceInfo.deviceId;\n\n                const sessionResult = sessionResults[deviceId];\n                if (!sessionResult.sessionId) {\n                    // no session with this device, probably because there\n                    // were no one-time keys.\n\n                    noOlmDevices.push({ userId, deviceInfo });\n                    delete sessionResults[deviceId];\n\n                    // ensureOlmSessionsForUsers has already done the logging,\n                    // so just skip it.\n                    continue;\n                }\n            }\n        }\n\n        return noOlmDevices;\n    }\n\n    /**\n     * Splits the user device map into multiple chunks to reduce the number of\n     * devices we encrypt to per API call.\n     *\n     * @internal\n     *\n     * @param devicesByUser - map from userid to list of devices\n     *\n     * @returns the blocked devices, split into chunks\n     */\n    private splitDevices<T extends DeviceInfo | IBlockedDevice>(\n        devicesByUser: Record<string, Record<string, { device: T }>>,\n    ): IOlmDevice<T>[][] {\n        const maxDevicesPerRequest = 20;\n\n        // use an array where the slices of a content map gets stored\n        let currentSlice: IOlmDevice<T>[] = [];\n        const mapSlices = [currentSlice];\n\n        for (const [userId, userDevices] of Object.entries(devicesByUser)) {\n            for (const deviceInfo of Object.values(userDevices)) {\n                currentSlice.push({\n                    userId: userId,\n                    deviceInfo: deviceInfo.device,\n                });\n            }\n\n            // We do this in the per-user loop as we prefer that all messages to the\n            // same user end up in the same API call to make it easier for the\n            // server (e.g. only have to send one EDU if a remote user, etc). This\n            // does mean that if a user has many devices we may go over the desired\n            // limit, but its not a hard limit so that is fine.\n            if (currentSlice.length > maxDevicesPerRequest) {\n                // the current slice is filled up. Start inserting into the next slice\n                currentSlice = [];\n                mapSlices.push(currentSlice);\n            }\n        }\n        if (currentSlice.length === 0) {\n            mapSlices.pop();\n        }\n        return mapSlices;\n    }\n\n    /**\n     * @internal\n     *\n     *\n     * @param chainIndex - current chain index\n     *\n     * @param userDeviceMap - mapping from userId to deviceInfo\n     *\n     * @param payload - fields to include in the encrypted payload\n     *\n     * @returns Promise which resolves once the key sharing\n     *     for the given userDeviceMap is generated and has been sent.\n     */\n    private encryptAndSendKeysToDevices(\n        session: OutboundSessionInfo,\n        chainIndex: number,\n        devices: IOlmDevice[],\n        payload: IPayload,\n    ): Promise<void> {\n        return this.crypto\n            .encryptAndSendToDevices(devices, payload)\n            .then(() => {\n                // store that we successfully uploaded the keys of the current slice\n                for (const device of devices) {\n                    session.markSharedWithDevice(\n                        device.userId,\n                        device.deviceInfo.deviceId,\n                        device.deviceInfo.getIdentityKey(),\n                        chainIndex,\n                    );\n                }\n            })\n            .catch((error) => {\n                logger.error(\"failed to encryptAndSendToDevices\", error);\n                throw error;\n            });\n    }\n\n    /**\n     * @internal\n     *\n     *\n     * @param userDeviceMap - list of blocked devices to notify\n     *\n     * @param payload - fields to include in the notification payload\n     *\n     * @returns Promise which resolves once the notifications\n     *     for the given userDeviceMap is generated and has been sent.\n     */\n    private async sendBlockedNotificationsToDevices(\n        session: OutboundSessionInfo,\n        userDeviceMap: IOlmDevice<IBlockedDevice>[],\n        payload: IPayload,\n    ): Promise<void> {\n        const contentMap: Record<string, Record<string, IPayload>> = {};\n\n        for (const val of userDeviceMap) {\n            const userId = val.userId;\n            const blockedInfo = val.deviceInfo;\n            const deviceInfo = blockedInfo.deviceInfo;\n            const deviceId = deviceInfo.deviceId;\n\n            const message = {\n                ...payload,\n                code: blockedInfo.code,\n                reason: blockedInfo.reason,\n                [ToDeviceMessageId]: uuidv4(),\n            };\n\n            if (message.code === \"m.no_olm\") {\n                delete message.room_id;\n                delete message.session_id;\n            }\n\n            if (!contentMap[userId]) {\n                contentMap[userId] = {};\n            }\n            contentMap[userId][deviceId] = message;\n        }\n\n        await this.baseApis.sendToDevice(\"m.room_key.withheld\", contentMap);\n\n        // record the fact that we notified these blocked devices\n        for (const userId of Object.keys(contentMap)) {\n            for (const deviceId of Object.keys(contentMap[userId])) {\n                session.markNotifiedBlockedDevice(userId, deviceId);\n            }\n        }\n    }\n\n    /**\n     * Re-shares a megolm session key with devices if the key has already been\n     * sent to them.\n     *\n     * @param senderKey - The key of the originating device for the session\n     * @param sessionId - ID of the outbound session to share\n     * @param userId - ID of the user who owns the target device\n     * @param device - The target device\n     */\n    public async reshareKeyWithDevice(\n        senderKey: string,\n        sessionId: string,\n        userId: string,\n        device: DeviceInfo,\n    ): Promise<void> {\n        const obSessionInfo = this.outboundSessions[sessionId];\n        if (!obSessionInfo) {\n            logger.debug(`megolm session ${senderKey}|${sessionId} not found: not re-sharing keys`);\n            return;\n        }\n\n        // The chain index of the key we previously sent this device\n        if (obSessionInfo.sharedWithDevices[userId] === undefined) {\n            logger.debug(`megolm session ${senderKey}|${sessionId} never shared with user ${userId}`);\n            return;\n        }\n        const sessionSharedData = obSessionInfo.sharedWithDevices[userId][device.deviceId];\n        if (sessionSharedData === undefined) {\n            logger.debug(\n                `megolm session ${senderKey}|${sessionId} never shared with device ${userId}:${device.deviceId}`,\n            );\n            return;\n        }\n\n        if (sessionSharedData.deviceKey !== device.getIdentityKey()) {\n            logger.warn(\n                `Megolm session ${senderKey}|${sessionId} has been shared with device ${device.deviceId} but ` +\n                    `with identity key ${sessionSharedData.deviceKey}. Key is now ${device.getIdentityKey()}!`,\n            );\n            return;\n        }\n\n        // get the key from the inbound session: the outbound one will already\n        // have been ratcheted to the next chain index.\n        const key = await this.olmDevice.getInboundGroupSessionKey(\n            this.roomId,\n            senderKey,\n            sessionId,\n            sessionSharedData.messageIndex,\n        );\n\n        if (!key) {\n            logger.warn(\n                `No inbound session key found for megolm session ${senderKey}|${sessionId}: not re-sharing keys`,\n            );\n            return;\n        }\n\n        await olmlib.ensureOlmSessionsForDevices(this.olmDevice, this.baseApis, {\n            [userId]: [device],\n        });\n\n        const payload = {\n            type: \"m.forwarded_room_key\",\n            content: {\n                \"algorithm\": olmlib.MEGOLM_ALGORITHM,\n                \"room_id\": this.roomId,\n                \"session_id\": sessionId,\n                \"session_key\": key.key,\n                \"chain_index\": key.chain_index,\n                \"sender_key\": senderKey,\n                \"sender_claimed_ed25519_key\": key.sender_claimed_ed25519_key,\n                \"forwarding_curve25519_key_chain\": key.forwarding_curve25519_key_chain,\n                \"org.matrix.msc3061.shared_history\": key.shared_history || false,\n            },\n        };\n\n        const encryptedContent: IEncryptedContent = {\n            algorithm: olmlib.OLM_ALGORITHM,\n            sender_key: this.olmDevice.deviceCurve25519Key!,\n            ciphertext: {},\n            [ToDeviceMessageId]: uuidv4(),\n        };\n        await olmlib.encryptMessageForDevice(\n            encryptedContent.ciphertext,\n            this.userId,\n            this.deviceId,\n            this.olmDevice,\n            userId,\n            device,\n            payload,\n        );\n\n        await this.baseApis.sendToDevice(\"m.room.encrypted\", {\n            [userId]: {\n                [device.deviceId]: encryptedContent,\n            },\n        });\n        logger.debug(`Re-shared key for megolm session ${senderKey}|${sessionId} with ${userId}:${device.deviceId}`);\n    }\n\n    /**\n     * @internal\n     *\n     *\n     * @param key - the session key as returned by\n     *    OlmDevice.getOutboundGroupSessionKey\n     *\n     * @param payload - the base to-device message payload for sharing keys\n     *\n     * @param devicesByUser - map from userid to list of devices\n     *\n     * @param errorDevices - array that will be populated with the devices that we can't get an\n     *    olm session for\n     *\n     * @param otkTimeout - The timeout in milliseconds when requesting\n     *     one-time keys for establishing new olm sessions.\n     *\n     * @param failedServers - An array to fill with remote servers that\n     *     failed to respond to one-time-key requests.\n     */\n    private async shareKeyWithDevices(\n        session: OutboundSessionInfo,\n        key: IOutboundGroupSessionKey,\n        payload: IPayload,\n        devicesByUser: Record<string, DeviceInfo[]>,\n        errorDevices: IOlmDevice[],\n        otkTimeout: number,\n        failedServers?: string[],\n    ): Promise<void> {\n        logger.debug(`Ensuring Olm sessions for devices in ${this.roomId}`);\n        const devicemap = await olmlib.ensureOlmSessionsForDevices(\n            this.olmDevice,\n            this.baseApis,\n            devicesByUser,\n            false,\n            otkTimeout,\n            failedServers,\n            logger.withPrefix?.(`[${this.roomId}]`),\n        );\n        logger.debug(`Ensured Olm sessions for devices in ${this.roomId}`);\n\n        this.getDevicesWithoutSessions(devicemap, devicesByUser, errorDevices);\n\n        logger.debug(`Sharing keys with newly created Olm sessions in ${this.roomId}`);\n        await this.shareKeyWithOlmSessions(session, key, payload, devicemap);\n        logger.debug(`Shared keys with newly created Olm sessions in ${this.roomId}`);\n    }\n\n    private async shareKeyWithOlmSessions(\n        session: OutboundSessionInfo,\n        key: IOutboundGroupSessionKey,\n        payload: IPayload,\n        devicemap: Record<string, Record<string, IOlmSessionResult>>,\n    ): Promise<void> {\n        const userDeviceMaps = this.splitDevices(devicemap);\n\n        for (let i = 0; i < userDeviceMaps.length; i++) {\n            const taskDetail =\n                `megolm keys for ${session.sessionId} ` + `in ${this.roomId} (slice ${i + 1}/${userDeviceMaps.length})`;\n            try {\n                logger.debug(\n                    `Sharing ${taskDetail}`,\n                    userDeviceMaps[i].map((d) => `${d.userId}/${d.deviceInfo.deviceId}`),\n                );\n                await this.encryptAndSendKeysToDevices(session, key.chain_index, userDeviceMaps[i], payload);\n                logger.debug(`Shared ${taskDetail}`);\n            } catch (e) {\n                logger.error(`Failed to share ${taskDetail}`);\n                throw e;\n            }\n        }\n    }\n\n    /**\n     * Notify devices that we weren't able to create olm sessions.\n     *\n     *\n     *\n     * @param failedDevices - the devices that we were unable to\n     *     create olm sessions for, as returned by shareKeyWithDevices\n     */\n    private async notifyFailedOlmDevices(\n        session: OutboundSessionInfo,\n        key: IOutboundGroupSessionKey,\n        failedDevices: IOlmDevice[],\n    ): Promise<void> {\n        logger.debug(\n            `Notifying ${failedDevices.length} devices we failed to ` + `create Olm sessions in ${this.roomId}`,\n        );\n\n        // mark the devices that failed as \"handled\" because we don't want to try\n        // to claim a one-time-key for dead devices on every message.\n        for (const { userId, deviceInfo } of failedDevices) {\n            const deviceId = deviceInfo.deviceId;\n\n            session.markSharedWithDevice(userId, deviceId, deviceInfo.getIdentityKey(), key.chain_index);\n        }\n\n        const unnotifiedFailedDevices = await this.olmDevice.filterOutNotifiedErrorDevices(failedDevices);\n        logger.debug(\n            `Need to notify ${unnotifiedFailedDevices.length} failed devices ` +\n                `which haven't been notified before in ${this.roomId}`,\n        );\n        const blockedMap: Record<string, Record<string, { device: IBlockedDevice }>> = {};\n        for (const { userId, deviceInfo } of unnotifiedFailedDevices) {\n            blockedMap[userId] = blockedMap[userId] || {};\n            // we use a similar format to what\n            // olmlib.ensureOlmSessionsForDevices returns, so that\n            // we can use the same function to split\n            blockedMap[userId][deviceInfo.deviceId] = {\n                device: {\n                    code: \"m.no_olm\",\n                    reason: WITHHELD_MESSAGES[\"m.no_olm\"],\n                    deviceInfo,\n                },\n            };\n        }\n\n        // send the notifications\n        await this.notifyBlockedDevices(session, blockedMap);\n        logger.debug(\n            `Notified ${unnotifiedFailedDevices.length} devices we failed to ` +\n                `create Olm sessions in ${this.roomId}`,\n        );\n    }\n\n    /**\n     * Notify blocked devices that they have been blocked.\n     *\n     *\n     * @param devicesByUser - map from userid to device ID to blocked data\n     */\n    private async notifyBlockedDevices(\n        session: OutboundSessionInfo,\n        devicesByUser: Record<string, Record<string, { device: IBlockedDevice }>>,\n    ): Promise<void> {\n        const payload: IPayload = {\n            room_id: this.roomId,\n            session_id: session.sessionId,\n            algorithm: olmlib.MEGOLM_ALGORITHM,\n            sender_key: this.olmDevice.deviceCurve25519Key!,\n        };\n\n        const userDeviceMaps = this.splitDevices(devicesByUser);\n\n        for (let i = 0; i < userDeviceMaps.length; i++) {\n            try {\n                await this.sendBlockedNotificationsToDevices(session, userDeviceMaps[i], payload);\n                logger.log(\n                    `Completed blacklist notification for ${session.sessionId} ` +\n                        `in ${this.roomId} (slice ${i + 1}/${userDeviceMaps.length})`,\n                );\n            } catch (e) {\n                logger.log(\n                    `blacklist notification for ${session.sessionId} in ` +\n                        `${this.roomId} (slice ${i + 1}/${userDeviceMaps.length}) failed`,\n                );\n\n                throw e;\n            }\n        }\n    }\n\n    /**\n     * Perform any background tasks that can be done before a message is ready to\n     * send, in order to speed up sending of the message.\n     *\n     * @param room - the room the event is in\n     */\n    public prepareToEncrypt(room: Room): void {\n        if (this.encryptionPreparation != null) {\n            // We're already preparing something, so don't do anything else.\n            // FIXME: check if we need to restart\n            // (https://github.com/matrix-org/matrix-js-sdk/issues/1255)\n            const elapsedTime = Date.now() - this.encryptionPreparation.startTime;\n            logger.debug(\n                `Already started preparing to encrypt for ${this.roomId} ` + `${elapsedTime} ms ago, skipping`,\n            );\n            return;\n        }\n\n        logger.debug(`Preparing to encrypt events for ${this.roomId}`);\n\n        this.encryptionPreparation = {\n            startTime: Date.now(),\n            promise: (async (): Promise<void> => {\n                try {\n                    logger.debug(`Getting devices in ${this.roomId}`);\n                    const [devicesInRoom, blocked] = await this.getDevicesInRoom(room);\n\n                    if (this.crypto.globalErrorOnUnknownDevices) {\n                        // Drop unknown devices for now.  When the message gets sent, we'll\n                        // throw an error, but we'll still be prepared to send to the known\n                        // devices.\n                        this.removeUnknownDevices(devicesInRoom);\n                    }\n\n                    logger.debug(`Ensuring outbound session in ${this.roomId}`);\n                    await this.ensureOutboundSession(room, devicesInRoom, blocked, true);\n\n                    logger.debug(`Ready to encrypt events for ${this.roomId}`);\n                } catch (e) {\n                    logger.error(`Failed to prepare to encrypt events for ${this.roomId}`, e);\n                } finally {\n                    delete this.encryptionPreparation;\n                }\n            })(),\n        };\n    }\n\n    /**\n     * @param content - plaintext event content\n     *\n     * @returns Promise which resolves to the new event body\n     */\n    public async encryptMessage(room: Room, eventType: string, content: IContent): Promise<IMegolmEncryptedContent> {\n        logger.log(`Starting to encrypt event for ${this.roomId}`);\n\n        if (this.encryptionPreparation != null) {\n            // If we started sending keys, wait for it to be done.\n            // FIXME: check if we need to cancel\n            // (https://github.com/matrix-org/matrix-js-sdk/issues/1255)\n            try {\n                await this.encryptionPreparation.promise;\n            } catch (e) {\n                // ignore any errors -- if the preparation failed, we'll just\n                // restart everything here\n            }\n        }\n\n        /**\n         * When using in-room messages and the room has encryption enabled,\n         * clients should ensure that encryption does not hinder the verification.\n         */\n        const forceDistributeToUnverified = this.isVerificationEvent(eventType, content);\n        const [devicesInRoom, blocked] = await this.getDevicesInRoom(room, forceDistributeToUnverified);\n\n        // check if any of these devices are not yet known to the user.\n        // if so, warn the user so they can verify or ignore.\n        if (this.crypto.globalErrorOnUnknownDevices) {\n            this.checkForUnknownDevices(devicesInRoom);\n        }\n\n        const session = await this.ensureOutboundSession(room, devicesInRoom, blocked);\n        const payloadJson = {\n            room_id: this.roomId,\n            type: eventType,\n            content: content,\n        };\n\n        const ciphertext = this.olmDevice.encryptGroupMessage(session.sessionId, JSON.stringify(payloadJson));\n        const encryptedContent: IEncryptedContent = {\n            algorithm: olmlib.MEGOLM_ALGORITHM,\n            sender_key: this.olmDevice.deviceCurve25519Key!,\n            ciphertext: ciphertext,\n            session_id: session.sessionId,\n            // Include our device ID so that recipients can send us a\n            // m.new_device message if they don't have our session key.\n            // XXX: Do we still need this now that m.new_device messages\n            // no longer exist since #483?\n            device_id: this.deviceId,\n        };\n\n        session.useCount++;\n        return encryptedContent;\n    }\n\n    private isVerificationEvent(eventType: string, content: IContent): boolean {\n        switch (eventType) {\n            case EventType.KeyVerificationCancel:\n            case EventType.KeyVerificationDone:\n            case EventType.KeyVerificationMac:\n            case EventType.KeyVerificationStart:\n            case EventType.KeyVerificationKey:\n            case EventType.KeyVerificationReady:\n            case EventType.KeyVerificationAccept: {\n                return true;\n            }\n            case EventType.RoomMessage: {\n                return content[\"msgtype\"] === MsgType.KeyVerificationRequest;\n            }\n            default: {\n                return false;\n            }\n        }\n    }\n\n    /**\n     * Forces the current outbound group session to be discarded such\n     * that another one will be created next time an event is sent.\n     *\n     * This should not normally be necessary.\n     */\n    public forceDiscardSession(): void {\n        this.setupPromise = this.setupPromise.then(() => null);\n    }\n\n    /**\n     * Checks the devices we're about to send to and see if any are entirely\n     * unknown to the user.  If so, warn the user, and mark them as known to\n     * give the user a chance to go verify them before re-sending this message.\n     *\n     * @param devicesInRoom - `userId -> {deviceId -> object}`\n     *   devices we should shared the session with.\n     */\n    private checkForUnknownDevices(devicesInRoom: DeviceInfoMap): void {\n        const unknownDevices: Record<string, Record<string, DeviceInfo>> = {};\n\n        Object.keys(devicesInRoom).forEach((userId) => {\n            Object.keys(devicesInRoom[userId]).forEach((deviceId) => {\n                const device = devicesInRoom[userId][deviceId];\n                if (device.isUnverified() && !device.isKnown()) {\n                    if (!unknownDevices[userId]) {\n                        unknownDevices[userId] = {};\n                    }\n                    unknownDevices[userId][deviceId] = device;\n                }\n            });\n        });\n\n        if (Object.keys(unknownDevices).length) {\n            // it'd be kind to pass unknownDevices up to the user in this error\n            throw new UnknownDeviceError(\n                \"This room contains unknown devices which have not been verified. \" +\n                    \"We strongly recommend you verify them before continuing.\",\n                unknownDevices,\n            );\n        }\n    }\n\n    /**\n     * Remove unknown devices from a set of devices.  The devicesInRoom parameter\n     * will be modified.\n     *\n     * @param devicesInRoom - `userId -> {deviceId -> object}`\n     *   devices we should shared the session with.\n     */\n    private removeUnknownDevices(devicesInRoom: DeviceInfoMap): void {\n        for (const [userId, userDevices] of Object.entries(devicesInRoom)) {\n            for (const [deviceId, device] of Object.entries(userDevices)) {\n                if (device.isUnverified() && !device.isKnown()) {\n                    delete userDevices[deviceId];\n                }\n            }\n\n            if (Object.keys(userDevices).length === 0) {\n                delete devicesInRoom[userId];\n            }\n        }\n    }\n\n    /**\n     * Get the list of unblocked devices for all users in the room\n     *\n     * @param forceDistributeToUnverified - if set to true will include the unverified devices\n     * even if setting is set to block them (useful for verification)\n     *\n     * @returns Promise which resolves to an array whose\n     *     first element is a map from userId to deviceId to deviceInfo indicating\n     *     the devices that messages should be encrypted to, and whose second\n     *     element is a map from userId to deviceId to data indicating the devices\n     *     that are in the room but that have been blocked\n     */\n    private async getDevicesInRoom(\n        room: Room,\n        forceDistributeToUnverified = false,\n    ): Promise<[DeviceInfoMap, IBlockedMap]> {\n        const members = await room.getEncryptionTargetMembers();\n        const roomMembers = members.map(function (u) {\n            return u.userId;\n        });\n\n        // The global value is treated as a default for when rooms don't specify a value.\n        let isBlacklisting = this.crypto.globalBlacklistUnverifiedDevices;\n        const isRoomBlacklisting = room.getBlacklistUnverifiedDevices();\n        if (typeof isRoomBlacklisting === \"boolean\") {\n            isBlacklisting = isRoomBlacklisting;\n        }\n\n        // We are happy to use a cached version here: we assume that if we already\n        // have a list of the user's devices, then we already share an e2e room\n        // with them, which means that they will have announced any new devices via\n        // device_lists in their /sync response.  This cache should then be maintained\n        // using all the device_lists changes and left fields.\n        // See https://github.com/vector-im/element-web/issues/2305 for details.\n        const devices = await this.crypto.downloadKeys(roomMembers, false);\n        const blocked: IBlockedMap = {};\n        // remove any blocked devices\n        for (const userId in devices) {\n            if (!devices.hasOwnProperty(userId)) {\n                continue;\n            }\n\n            const userDevices = devices[userId];\n            for (const deviceId in userDevices) {\n                if (!userDevices.hasOwnProperty(deviceId)) {\n                    continue;\n                }\n\n                const deviceTrust = this.crypto.checkDeviceTrust(userId, deviceId);\n\n                if (\n                    userDevices[deviceId].isBlocked() ||\n                    (!deviceTrust.isVerified() && isBlacklisting && !forceDistributeToUnverified)\n                ) {\n                    if (!blocked[userId]) {\n                        blocked[userId] = {};\n                    }\n                    const isBlocked = userDevices[deviceId].isBlocked();\n                    blocked[userId][deviceId] = {\n                        code: isBlocked ? \"m.blacklisted\" : \"m.unverified\",\n                        reason: WITHHELD_MESSAGES[isBlocked ? \"m.blacklisted\" : \"m.unverified\"],\n                        deviceInfo: userDevices[deviceId],\n                    };\n                    delete userDevices[deviceId];\n                }\n            }\n        }\n\n        return [devices, blocked];\n    }\n}\n\n/**\n * Megolm decryption implementation\n *\n * @param params - parameters, as per {@link DecryptionAlgorithm}\n */\nexport class MegolmDecryption extends DecryptionAlgorithm {\n    // events which we couldn't decrypt due to unknown sessions /\n    // indexes, or which we could only decrypt with untrusted keys:\n    // map from senderKey|sessionId to Set of MatrixEvents\n    private pendingEvents = new Map<string, Map<string, Set<MatrixEvent>>>();\n\n    // this gets stubbed out by the unit tests.\n    private olmlib = olmlib;\n\n    protected readonly roomId: string;\n\n    public constructor(params: DecryptionClassParams<IParams & Required<Pick<IParams, \"roomId\">>>) {\n        super(params);\n        this.roomId = params.roomId;\n    }\n\n    /**\n     * returns a promise which resolves to a\n     * {@link EventDecryptionResult} once we have finished\n     * decrypting, or rejects with an `algorithms.DecryptionError` if there is a\n     * problem decrypting the event.\n     */\n    public async decryptEvent(event: MatrixEvent): Promise<IEventDecryptionResult> {\n        const content = event.getWireContent();\n\n        if (!content.sender_key || !content.session_id || !content.ciphertext) {\n            throw new DecryptionError(\"MEGOLM_MISSING_FIELDS\", \"Missing fields in input\");\n        }\n\n        // we add the event to the pending list *before* we start decryption.\n        //\n        // then, if the key turns up while decryption is in progress (and\n        // decryption fails), we will schedule a retry.\n        // (fixes https://github.com/vector-im/element-web/issues/5001)\n        this.addEventToPendingList(event);\n\n        let res: IDecryptedGroupMessage | null;\n        try {\n            res = await this.olmDevice.decryptGroupMessage(\n                event.getRoomId()!,\n                content.sender_key,\n                content.session_id,\n                content.ciphertext,\n                event.getId()!,\n                event.getTs(),\n            );\n        } catch (e) {\n            if ((<Error>e).name === \"DecryptionError\") {\n                // re-throw decryption errors as-is\n                throw e;\n            }\n\n            let errorCode = \"OLM_DECRYPT_GROUP_MESSAGE_ERROR\";\n\n            if ((<MatrixError>e)?.message === \"OLM.UNKNOWN_MESSAGE_INDEX\") {\n                this.requestKeysForEvent(event);\n\n                errorCode = \"OLM_UNKNOWN_MESSAGE_INDEX\";\n            }\n\n            throw new DecryptionError(errorCode, e ? e.toString() : \"Unknown Error: Error is undefined\", {\n                session: content.sender_key + \"|\" + content.session_id,\n            });\n        }\n\n        if (res === null) {\n            // We've got a message for a session we don't have.\n            // try and get the missing key from the backup first\n            this.crypto.backupManager.queryKeyBackupRateLimited(event.getRoomId(), content.session_id).catch(() => {});\n\n            // (XXX: We might actually have received this key since we started\n            // decrypting, in which case we'll have scheduled a retry, and this\n            // request will be redundant. We could probably check to see if the\n            // event is still in the pending list; if not, a retry will have been\n            // scheduled, so we needn't send out the request here.)\n            this.requestKeysForEvent(event);\n\n            // See if there was a problem with the olm session at the time the\n            // event was sent.  Use a fuzz factor of 2 minutes.\n            const problem = await this.olmDevice.sessionMayHaveProblems(content.sender_key, event.getTs() - 120000);\n            if (problem) {\n                logger.info(\n                    `When handling UISI from ${event.getSender()} (sender key ${content.sender_key}): ` +\n                        `recent session problem with that sender: ${problem}`,\n                );\n                let problemDescription = PROBLEM_DESCRIPTIONS[problem.type as \"no_olm\"] || PROBLEM_DESCRIPTIONS.unknown;\n                if (problem.fixed) {\n                    problemDescription += \" Trying to create a new secure channel and re-requesting the keys.\";\n                }\n                throw new DecryptionError(\"MEGOLM_UNKNOWN_INBOUND_SESSION_ID\", problemDescription, {\n                    session: content.sender_key + \"|\" + content.session_id,\n                });\n            }\n\n            throw new DecryptionError(\n                \"MEGOLM_UNKNOWN_INBOUND_SESSION_ID\",\n                \"The sender's device has not sent us the keys for this message.\",\n                {\n                    session: content.sender_key + \"|\" + content.session_id,\n                },\n            );\n        }\n\n        // Success. We can remove the event from the pending list, if\n        // that hasn't already happened. However, if the event was\n        // decrypted with an untrusted key, leave it on the pending\n        // list so it will be retried if we find a trusted key later.\n        if (!res.untrusted) {\n            this.removeEventFromPendingList(event);\n        }\n\n        const payload = JSON.parse(res.result);\n\n        // belt-and-braces check that the room id matches that indicated by the HS\n        // (this is somewhat redundant, since the megolm session is scoped to the\n        // room, so neither the sender nor a MITM can lie about the room_id).\n        if (payload.room_id !== event.getRoomId()) {\n            throw new DecryptionError(\"MEGOLM_BAD_ROOM\", \"Message intended for room \" + payload.room_id);\n        }\n\n        return {\n            clearEvent: payload,\n            senderCurve25519Key: res.senderKey,\n            claimedEd25519Key: res.keysClaimed.ed25519,\n            forwardingCurve25519KeyChain: res.forwardingCurve25519KeyChain,\n            untrusted: res.untrusted,\n        };\n    }\n\n    private requestKeysForEvent(event: MatrixEvent): void {\n        const wireContent = event.getWireContent();\n\n        const recipients = event.getKeyRequestRecipients(this.userId);\n\n        this.crypto.requestRoomKey(\n            {\n                room_id: event.getRoomId()!,\n                algorithm: wireContent.algorithm,\n                sender_key: wireContent.sender_key,\n                session_id: wireContent.session_id,\n            },\n            recipients,\n        );\n    }\n\n    /**\n     * Add an event to the list of those awaiting their session keys.\n     *\n     * @internal\n     *\n     */\n    private addEventToPendingList(event: MatrixEvent): void {\n        const content = event.getWireContent();\n        const senderKey = content.sender_key;\n        const sessionId = content.session_id;\n        if (!this.pendingEvents.has(senderKey)) {\n            this.pendingEvents.set(senderKey, new Map<string, Set<MatrixEvent>>());\n        }\n        const senderPendingEvents = this.pendingEvents.get(senderKey)!;\n        if (!senderPendingEvents.has(sessionId)) {\n            senderPendingEvents.set(sessionId, new Set());\n        }\n        senderPendingEvents.get(sessionId)?.add(event);\n    }\n\n    /**\n     * Remove an event from the list of those awaiting their session keys.\n     *\n     * @internal\n     *\n     */\n    private removeEventFromPendingList(event: MatrixEvent): void {\n        const content = event.getWireContent();\n        const senderKey = content.sender_key;\n        const sessionId = content.session_id;\n        const senderPendingEvents = this.pendingEvents.get(senderKey);\n        const pendingEvents = senderPendingEvents?.get(sessionId);\n        if (!pendingEvents) {\n            return;\n        }\n\n        pendingEvents.delete(event);\n        if (pendingEvents.size === 0) {\n            senderPendingEvents!.delete(sessionId);\n        }\n        if (senderPendingEvents!.size === 0) {\n            this.pendingEvents.delete(senderKey);\n        }\n    }\n\n    public async onRoomKeyEvent(event: MatrixEvent): Promise<void> {\n        const content = event.getContent<Partial<IMessage[\"content\"]>>();\n        let senderKey = event.getSenderKey()!;\n        let forwardingKeyChain: string[] = [];\n        let exportFormat = false;\n        let keysClaimed: ReturnType<MatrixEvent[\"getKeysClaimed\"]>;\n\n        const extraSessionData: OlmGroupSessionExtraData = {};\n\n        if (!content.room_id || !content.session_key || !content.session_id || !content.algorithm) {\n            logger.error(\"key event is missing fields\");\n            return;\n        }\n\n        if (!olmlib.isOlmEncrypted(event)) {\n            logger.error(\"key event not properly encrypted\");\n            return;\n        }\n\n        if (content[\"org.matrix.msc3061.shared_history\"]) {\n            extraSessionData.sharedHistory = true;\n        }\n\n        if (event.getType() == \"m.forwarded_room_key\") {\n            const deviceInfo = this.crypto.deviceList.getDeviceByIdentityKey(olmlib.OLM_ALGORITHM, senderKey);\n            const senderKeyUser = this.baseApis.crypto!.deviceList.getUserByIdentityKey(\n                olmlib.OLM_ALGORITHM,\n                senderKey,\n            );\n            if (senderKeyUser !== event.getSender()) {\n                logger.error(\"sending device does not belong to the user it claims to be from\");\n                return;\n            }\n            const outgoingRequests = deviceInfo\n                ? await this.crypto.cryptoStore.getOutgoingRoomKeyRequestsByTarget(\n                      event.getSender()!,\n                      deviceInfo.deviceId,\n                      [RoomKeyRequestState.Sent],\n                  )\n                : [];\n            const weRequested = outgoingRequests.some(\n                (req) =>\n                    req.requestBody.room_id === content.room_id && req.requestBody.session_id === content.session_id,\n            );\n            const room = this.baseApis.getRoom(content.room_id);\n            const memberEvent = room?.getMember(this.userId)?.events.member;\n            const fromInviter =\n                memberEvent?.getSender() === event.getSender() ||\n                (memberEvent?.getUnsigned()?.prev_sender === event.getSender() &&\n                    memberEvent?.getPrevContent()?.membership === \"invite\");\n            const fromUs = event.getSender() === this.baseApis.getUserId();\n\n            if (!weRequested && !fromUs) {\n                // If someone sends us an unsolicited key and they're\n                // not one of our other devices and it's not shared\n                // history, ignore it\n                if (!extraSessionData.sharedHistory) {\n                    logger.log(\"forwarded key not shared history - ignoring\");\n                    return;\n                }\n\n                // If someone sends us an unsolicited key for a room\n                // we're already in, and they're not one of our other\n                // devices or the one who invited us, ignore it\n                if (room && !fromInviter) {\n                    logger.log(\"forwarded key not from inviter or from us - ignoring\");\n                    return;\n                }\n            }\n\n            exportFormat = true;\n            forwardingKeyChain = Array.isArray(content.forwarding_curve25519_key_chain)\n                ? content.forwarding_curve25519_key_chain\n                : [];\n\n            // copy content before we modify it\n            forwardingKeyChain = forwardingKeyChain.slice();\n            forwardingKeyChain.push(senderKey);\n\n            if (!content.sender_key) {\n                logger.error(\"forwarded_room_key event is missing sender_key field\");\n                return;\n            }\n\n            const ed25519Key = content.sender_claimed_ed25519_key;\n            if (!ed25519Key) {\n                logger.error(`forwarded_room_key_event is missing sender_claimed_ed25519_key field`);\n                return;\n            }\n\n            keysClaimed = {\n                ed25519: ed25519Key,\n            };\n\n            // If this is a key for a room we're not in, don't load it\n            // yet, just park it in case *this sender* invites us to\n            // that room later\n            if (!room) {\n                const parkedData = {\n                    senderId: event.getSender()!,\n                    senderKey: content.sender_key,\n                    sessionId: content.session_id,\n                    sessionKey: content.session_key,\n                    keysClaimed,\n                    forwardingCurve25519KeyChain: forwardingKeyChain,\n                };\n                await this.crypto.cryptoStore.doTxn(\n                    \"readwrite\",\n                    [\"parked_shared_history\"],\n                    (txn) => this.crypto.cryptoStore.addParkedSharedHistory(content.room_id!, parkedData, txn),\n                    logger.withPrefix(\"[addParkedSharedHistory]\"),\n                );\n                return;\n            }\n\n            const sendingDevice =\n                this.crypto.deviceList.getDeviceByIdentityKey(olmlib.OLM_ALGORITHM, senderKey) ?? undefined;\n            const deviceTrust = this.crypto.checkDeviceInfoTrust(event.getSender()!, sendingDevice);\n\n            if (fromUs && !deviceTrust.isVerified()) {\n                return;\n            }\n\n            // forwarded keys are always untrusted\n            extraSessionData.untrusted = true;\n\n            // replace the sender key with the sender key of the session\n            // creator for storage\n            senderKey = content.sender_key;\n        } else {\n            keysClaimed = event.getKeysClaimed();\n        }\n\n        if (content[\"org.matrix.msc3061.shared_history\"]) {\n            extraSessionData.sharedHistory = true;\n        }\n\n        try {\n            await this.olmDevice.addInboundGroupSession(\n                content.room_id,\n                senderKey,\n                forwardingKeyChain,\n                content.session_id,\n                content.session_key,\n                keysClaimed,\n                exportFormat,\n                extraSessionData,\n            );\n\n            // have another go at decrypting events sent with this session.\n            if (await this.retryDecryption(senderKey, content.session_id, !extraSessionData.untrusted)) {\n                // cancel any outstanding room key requests for this session.\n                // Only do this if we managed to decrypt every message in the\n                // session, because if we didn't, we leave the other key\n                // requests in the hopes that someone sends us a key that\n                // includes an earlier index.\n                this.crypto.cancelRoomKeyRequest({\n                    algorithm: content.algorithm,\n                    room_id: content.room_id,\n                    session_id: content.session_id,\n                    sender_key: senderKey,\n                });\n            }\n\n            // don't wait for the keys to be backed up for the server\n            await this.crypto.backupManager.backupGroupSession(senderKey, content.session_id);\n        } catch (e) {\n            logger.error(`Error handling m.room_key_event: ${e}`);\n        }\n    }\n\n    /**\n     * @param event - key event\n     */\n    public async onRoomKeyWithheldEvent(event: MatrixEvent): Promise<void> {\n        const content = event.getContent();\n        const senderKey = content.sender_key;\n\n        if (content.code === \"m.no_olm\") {\n            const sender = event.getSender()!;\n            logger.warn(`${sender}:${senderKey} was unable to establish an olm session with us`);\n            // if the sender says that they haven't been able to establish an olm\n            // session, let's proactively establish one\n\n            // Note: after we record that the olm session has had a problem, we\n            // trigger retrying decryption for all the messages from the sender's\n            // key, so that we can update the error message to indicate the olm\n            // session problem.\n\n            if (await this.olmDevice.getSessionIdForDevice(senderKey)) {\n                // a session has already been established, so we don't need to\n                // create a new one.\n                logger.debug(\"New session already created.  Not creating a new one.\");\n                await this.olmDevice.recordSessionProblem(senderKey, \"no_olm\", true);\n                this.retryDecryptionFromSender(senderKey);\n                return;\n            }\n            let device = this.crypto.deviceList.getDeviceByIdentityKey(content.algorithm, senderKey);\n            if (!device) {\n                // if we don't know about the device, fetch the user's devices again\n                // and retry before giving up\n                await this.crypto.downloadKeys([sender], false);\n                device = this.crypto.deviceList.getDeviceByIdentityKey(content.algorithm, senderKey);\n                if (!device) {\n                    logger.info(\"Couldn't find device for identity key \" + senderKey + \": not establishing session\");\n                    await this.olmDevice.recordSessionProblem(senderKey, \"no_olm\", false);\n                    this.retryDecryptionFromSender(senderKey);\n                    return;\n                }\n            }\n\n            // XXX: switch this to use encryptAndSendToDevices() rather than duplicating it?\n\n            await olmlib.ensureOlmSessionsForDevices(this.olmDevice, this.baseApis, { [sender]: [device] }, false);\n            const encryptedContent: IEncryptedContent = {\n                algorithm: olmlib.OLM_ALGORITHM,\n                sender_key: this.olmDevice.deviceCurve25519Key!,\n                ciphertext: {},\n                [ToDeviceMessageId]: uuidv4(),\n            };\n            await olmlib.encryptMessageForDevice(\n                encryptedContent.ciphertext,\n                this.userId,\n                undefined,\n                this.olmDevice,\n                sender,\n                device,\n                { type: \"m.dummy\" },\n            );\n\n            await this.olmDevice.recordSessionProblem(senderKey, \"no_olm\", true);\n            this.retryDecryptionFromSender(senderKey);\n\n            await this.baseApis.sendToDevice(\"m.room.encrypted\", {\n                [sender]: {\n                    [device.deviceId]: encryptedContent,\n                },\n            });\n        } else {\n            await this.olmDevice.addInboundGroupSessionWithheld(\n                content.room_id,\n                senderKey,\n                content.session_id,\n                content.code,\n                content.reason,\n            );\n        }\n    }\n\n    public hasKeysForKeyRequest(keyRequest: IncomingRoomKeyRequest): Promise<boolean> {\n        const body = keyRequest.requestBody;\n\n        return this.olmDevice.hasInboundSessionKeys(\n            body.room_id,\n            body.sender_key,\n            body.session_id,\n            // TODO: ratchet index\n        );\n    }\n\n    public shareKeysWithDevice(keyRequest: IncomingRoomKeyRequest): void {\n        const userId = keyRequest.userId;\n        const deviceId = keyRequest.deviceId;\n        const deviceInfo = this.crypto.getStoredDevice(userId, deviceId)!;\n        const body = keyRequest.requestBody;\n\n        // XXX: switch this to use encryptAndSendToDevices()?\n\n        this.olmlib\n            .ensureOlmSessionsForDevices(this.olmDevice, this.baseApis, {\n                [userId]: [deviceInfo],\n            })\n            .then((devicemap) => {\n                const olmSessionResult = devicemap[userId][deviceId];\n                if (!olmSessionResult.sessionId) {\n                    // no session with this device, probably because there\n                    // were no one-time keys.\n                    //\n                    // ensureOlmSessionsForUsers has already done the logging,\n                    // so just skip it.\n                    return null;\n                }\n\n                logger.log(\n                    \"sharing keys for session \" +\n                        body.sender_key +\n                        \"|\" +\n                        body.session_id +\n                        \" with device \" +\n                        userId +\n                        \":\" +\n                        deviceId,\n                );\n\n                return this.buildKeyForwardingMessage(body.room_id, body.sender_key, body.session_id);\n            })\n            .then((payload) => {\n                const encryptedContent: IEncryptedContent = {\n                    algorithm: olmlib.OLM_ALGORITHM,\n                    sender_key: this.olmDevice.deviceCurve25519Key!,\n                    ciphertext: {},\n                    [ToDeviceMessageId]: uuidv4(),\n                };\n\n                return this.olmlib\n                    .encryptMessageForDevice(\n                        encryptedContent.ciphertext,\n                        this.userId,\n                        undefined,\n                        this.olmDevice,\n                        userId,\n                        deviceInfo,\n                        payload!,\n                    )\n                    .then(() => {\n                        const contentMap = {\n                            [userId]: {\n                                [deviceId]: encryptedContent,\n                            },\n                        };\n\n                        // TODO: retries\n                        return this.baseApis.sendToDevice(\"m.room.encrypted\", contentMap);\n                    });\n            });\n    }\n\n    private async buildKeyForwardingMessage(\n        roomId: string,\n        senderKey: string,\n        sessionId: string,\n    ): Promise<IKeyForwardingMessage> {\n        const key = await this.olmDevice.getInboundGroupSessionKey(roomId, senderKey, sessionId);\n\n        return {\n            type: \"m.forwarded_room_key\",\n            content: {\n                \"algorithm\": olmlib.MEGOLM_ALGORITHM,\n                \"room_id\": roomId,\n                \"sender_key\": senderKey,\n                \"sender_claimed_ed25519_key\": key!.sender_claimed_ed25519_key!,\n                \"session_id\": sessionId,\n                \"session_key\": key!.key,\n                \"chain_index\": key!.chain_index,\n                \"forwarding_curve25519_key_chain\": key!.forwarding_curve25519_key_chain,\n                \"org.matrix.msc3061.shared_history\": key!.shared_history || false,\n            },\n        };\n    }\n\n    /**\n     * @param untrusted - whether the key should be considered as untrusted\n     * @param source - where the key came from\n     */\n    public importRoomKey(\n        session: IMegolmSessionData,\n        { untrusted, source }: { untrusted?: boolean; source?: string } = {},\n    ): Promise<void> {\n        const extraSessionData: OlmGroupSessionExtraData = {};\n        if (untrusted || session.untrusted) {\n            extraSessionData.untrusted = true;\n        }\n        if (session[\"org.matrix.msc3061.shared_history\"]) {\n            extraSessionData.sharedHistory = true;\n        }\n        return this.olmDevice\n            .addInboundGroupSession(\n                session.room_id,\n                session.sender_key,\n                session.forwarding_curve25519_key_chain,\n                session.session_id,\n                session.session_key,\n                session.sender_claimed_keys,\n                true,\n                extraSessionData,\n            )\n            .then(() => {\n                if (source !== \"backup\") {\n                    // don't wait for it to complete\n                    this.crypto.backupManager.backupGroupSession(session.sender_key, session.session_id).catch((e) => {\n                        // This throws if the upload failed, but this is fine\n                        // since it will have written it to the db and will retry.\n                        logger.log(\"Failed to back up megolm session\", e);\n                    });\n                }\n                // have another go at decrypting events sent with this session.\n                this.retryDecryption(session.sender_key, session.session_id, !extraSessionData.untrusted);\n            });\n    }\n\n    /**\n     * Have another go at decrypting events after we receive a key. Resolves once\n     * decryption has been re-attempted on all events.\n     *\n     * @internal\n     * @param forceRedecryptIfUntrusted - whether messages that were already\n     *     successfully decrypted using untrusted keys should be re-decrypted\n     *\n     * @returns whether all messages were successfully\n     *     decrypted with trusted keys\n     */\n    private async retryDecryption(\n        senderKey: string,\n        sessionId: string,\n        forceRedecryptIfUntrusted?: boolean,\n    ): Promise<boolean> {\n        const senderPendingEvents = this.pendingEvents.get(senderKey);\n        if (!senderPendingEvents) {\n            return true;\n        }\n\n        const pending = senderPendingEvents.get(sessionId);\n        if (!pending) {\n            return true;\n        }\n\n        logger.debug(\"Retrying decryption on events\", [...pending]);\n\n        await Promise.all(\n            [...pending].map(async (ev) => {\n                try {\n                    await ev.attemptDecryption(this.crypto, { isRetry: true, forceRedecryptIfUntrusted });\n                } catch (e) {\n                    // don't die if something goes wrong\n                }\n            }),\n        );\n\n        // If decrypted successfully with trusted keys, they'll have\n        // been removed from pendingEvents\n        return !this.pendingEvents.get(senderKey)?.has(sessionId);\n    }\n\n    public async retryDecryptionFromSender(senderKey: string): Promise<boolean> {\n        const senderPendingEvents = this.pendingEvents.get(senderKey);\n        if (!senderPendingEvents) {\n            return true;\n        }\n\n        this.pendingEvents.delete(senderKey);\n\n        await Promise.all(\n            [...senderPendingEvents].map(async ([_sessionId, pending]) => {\n                await Promise.all(\n                    [...pending].map(async (ev) => {\n                        try {\n                            await ev.attemptDecryption(this.crypto);\n                        } catch (e) {\n                            // don't die if something goes wrong\n                        }\n                    }),\n                );\n            }),\n        );\n\n        return !this.pendingEvents.has(senderKey);\n    }\n\n    public async sendSharedHistoryInboundSessions(devicesByUser: Record<string, DeviceInfo[]>): Promise<void> {\n        await olmlib.ensureOlmSessionsForDevices(this.olmDevice, this.baseApis, devicesByUser);\n\n        const sharedHistorySessions = await this.olmDevice.getSharedHistoryInboundGroupSessions(this.roomId);\n        logger.log(\n            `Sharing history in ${this.roomId} with users ${Object.keys(devicesByUser)}`,\n            sharedHistorySessions.map(([senderKey, sessionId]) => `${senderKey}|${sessionId}`),\n        );\n        for (const [senderKey, sessionId] of sharedHistorySessions) {\n            const payload = await this.buildKeyForwardingMessage(this.roomId, senderKey, sessionId);\n\n            // FIXME: use encryptAndSendToDevices() rather than duplicating it here.\n            const promises: Promise<unknown>[] = [];\n            const contentMap: Record<string, Record<string, IEncryptedContent>> = {};\n            for (const [userId, devices] of Object.entries(devicesByUser)) {\n                contentMap[userId] = {};\n                for (const deviceInfo of devices) {\n                    const encryptedContent: IEncryptedContent = {\n                        algorithm: olmlib.OLM_ALGORITHM,\n                        sender_key: this.olmDevice.deviceCurve25519Key!,\n                        ciphertext: {},\n                        [ToDeviceMessageId]: uuidv4(),\n                    };\n                    contentMap[userId][deviceInfo.deviceId] = encryptedContent;\n                    promises.push(\n                        olmlib.encryptMessageForDevice(\n                            encryptedContent.ciphertext,\n                            this.userId,\n                            undefined,\n                            this.olmDevice,\n                            userId,\n                            deviceInfo,\n                            payload,\n                        ),\n                    );\n                }\n            }\n            await Promise.all(promises);\n\n            // prune out any devices that encryptMessageForDevice could not encrypt for,\n            // in which case it will have just not added anything to the ciphertext object.\n            // There's no point sending messages to devices if we couldn't encrypt to them,\n            // since that's effectively a blank message.\n            for (const userId of Object.keys(contentMap)) {\n                for (const deviceId of Object.keys(contentMap[userId])) {\n                    if (Object.keys(contentMap[userId][deviceId].ciphertext).length === 0) {\n                        logger.log(\"No ciphertext for device \" + userId + \":\" + deviceId + \": pruning\");\n                        delete contentMap[userId][deviceId];\n                    }\n                }\n                // No devices left for that user? Strip that too.\n                if (Object.keys(contentMap[userId]).length === 0) {\n                    logger.log(\"Pruned all devices for user \" + userId);\n                    delete contentMap[userId];\n                }\n            }\n\n            // Is there anything left?\n            if (Object.keys(contentMap).length === 0) {\n                logger.log(\"No users left to send to: aborting\");\n                return;\n            }\n\n            await this.baseApis.sendToDevice(\"m.room.encrypted\", contentMap);\n        }\n    }\n}\n\nconst PROBLEM_DESCRIPTIONS = {\n    no_olm: \"The sender was unable to establish a secure channel.\",\n    unknown: \"The secure channel with the sender was corrupted.\",\n};\n\nregisterAlgorithm(olmlib.MEGOLM_ALGORITHM, MegolmEncryption, MegolmDecryption);\n"],"mappings":"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"}