{"version":3,"file":"index.js","names":["DeviceVerification","DeviceInfo","defaultVerificationMethods","ReciprocateQRCode","NAME","SASVerification","SHOW_QR_CODE_METHOD","IllegalMethod","SCAN_QR_CODE_METHOD","verificationMethods","RECIPROCATE_QR_CODE","SAS","isCryptoAvailable","Boolean","global","Olm","MIN_FORCE_SESSION_INTERVAL_MS","CryptoEvent","Crypto","TypedEventEmitter","getOlmVersion","OlmDevice","constructor","baseApis","userId","deviceId","clientStore","cryptoStore","roomList","Map","newCrossSigning","deviceList","getStoredCrossSigningForUser","seenPubkey","getId","currentPubkey","crossSigningInfo","changed","checkOwnCrossSigningTrust","storeTrustedSelfKeys","emit","KeysChanged","UserTrustStatusChanged","checkUserTrust","checkDeviceVerifications","crossSigning","updateCrossSigningVerifiedBefore","isCrossSigningVerified","setRawStoredCrossSigningForUser","toStorage","event","member","oldMembership","onRoomMembership","e","logger","error","log","getType","getSender","getContent","ToDeviceMessageId","onRoomKeyEvent","onRoomKeyRequestEvent","secretStorage","onRequestReceived","onSecretReceived","onRoomKeyWithheldEvent","transaction_id","onKeyVerificationMessage","msgtype","onToDeviceBadEncrypted","isBeingDecrypted","shouldAttemptDecryption","attemptDecryption","once","MatrixEventEvent","Decrypted","ev","onToDeviceEvent","room","atStart","removed","liveEvent","InRoomChannel","validateEvent","createRequest","channel","getRoomId","VerificationRequest","handleVerificationEvent","inRoomVerificationRequests","reEmitter","TypedReEmitter","method","set","warn","Object","entries","backupManager","BackupManager","cachedKey","getSessionBackupPrivateKey","storedKey","getSecret","fixedKey","fixBackupKey","keys","getSecretStorageKey","storeSecret","olmlib","decodeBase64","cryptoCallbacks","getBackupKey","Error","olmDevice","DeviceList","on","UserCrossSigningUpdated","onDeviceListUserCrossSigningUpdated","reEmit","DevicesUpdated","WillUpdateDevices","supportedAlgorithms","Array","from","algorithms","DECRYPTION_CLASSES","outgoingRoomKeyRequestManager","OutgoingRoomKeyRequestManager","toDeviceVerificationRequests","ToDeviceRequests","InRoomRequests","cacheCallbacks","createCryptoStoreCacheCallbacks","CrossSigningInfo","SecretStorage","dehydrationManager","DehydrationManager","getCrossSigningKey","type","getFromSecretStorage","init","exportedOlmDevice","pickleKey","fromExportedDevice","load","deviceKeys","deviceEd25519Key","deviceCurve25519Key","myDevices","getRawStoredDevicesForUser","deviceInfo","verified","VERIFIED","known","storeDevicesForUser","saveIfDirty","doTxn","IndexedDBCryptoStore","STORE_ACCOUNT","txn","getCrossSigningKeys","length","setKeys","startTrackingDeviceList","checkAndStart","getCryptoTrustCrossSignedDevices","trustCrossSignedDevices","setCryptoTrustCrossSignedDevices","val","getKnownUserIds","devices","deviceTrust","checkDeviceTrust","isLocallyVerified","deviceObj","getStoredDevice","DeviceVerificationChanged","createRecoveryKeyFromPassphrase","password","decryption","PkDecryption","keyInfo","derivation","keyFromPassphrase","passphrase","algorithm","iterations","salt","pubkey","init_with_private_key","key","generate_key","privateKey","get_private_key","encodedPrivateKey","encodeRecoveryKey","free","userHasCrossSigningKeys","downloadKeys","isCrossSigningReady","publicKeysOnDevice","privateKeysExistSomewhere","isStoredInKeyCache","isStoredInSecretStorage","isSecretStorageReady","secretStorageKeyInAccount","hasKey","privateKeysInStorage","sessionBackupInStorage","getKeyBackupEnabled","isKeyBackupKeyStored","bootstrapCrossSigning","authUploadDeviceSigningKeys","setupNewCrossSigning","delegateCryptoCallbacks","builder","EncryptionSetupBuilder","store","accountData","crossSigningCallbacks","resetCrossSigning","resetKeys","signObject","master","addCrossSigningKeys","device","deviceSignature","signDevice","addKeySignature","backupInfo","auth_data","addSessionBackup","privateKeysInCache","allowPrivateKeyRequests","crossSigningPrivateKeys","privateKeys","size","saveCrossSigningKeys","accountDataClientAdapter","ssssCryptoCallbacks","undefined","storeInSecretStorage","operation","buildOperation","apply","persist","bootstrapSecretStorage","createSecretStorageKey","keyBackupInfo","setupNewKeyBackup","setupNewSecretStorage","getKeyBackupPassphrase","newKeyId","createSSSS","opts","keyId","addKey","SECRET_STORAGE_ALGORITHM_V1_AES","addPrivateKey","setDefaultKeyId","ensureCanCheckPassphrase","mac","iv","calculateKeyCheck","setAccountData","signKeyBackupWithCrossSigning","keyBackupAuthData","oldSSSSKey","oldKeyId","oldKeyInfo","storageExists","backupKey","private_key_salt","private_key_iterations","bits","encodeBase64","getCrossSigningKeysFromCache","info","prepareKeyBackupVersion","secureSecretStorage","decodeRecoveryKey","recovery_key","data","sessionBackupKey","get","fixedBackupKey","decodedBackupKey","Uint8Array","addSessionBackupPrivateKeyToCache","addSecretStorageKey","keyID","hasSecretStorageKey","getKey","name","secret","isSecretStored","isStored","requestSecret","request","getDefaultSecretStorageKeyId","getDefaultKeyId","setDefaultSecretStorageKeyId","k","checkSecretStorageKey","checkKey","checkSecretStoragePrivateKey","expectedPublicKey","gotPubkey","Promise","resolve","getSecretStorePrivateKey","storeSessionBackupPrivateKey","ciphertext","Buffer","decrypted","decryptAES","encryptedKey","encryptAES","storeSecretStorePrivateKey","checkCrossSigningPrivateKey","signing","PkSigning","init_with_seed","afterCrossSigningLocalKeyChange","signedDevice","upload","shouldEmit","uploadKeySignatures","then","response","failures","KeySignatureUploadFailure","KeySignatureUploadError","catch","shouldUpgradeCb","shouldUpgradeDeviceVerifications","users","upgradeInfo","checkForDeviceVerificationUpgrade","fromStorage","usersToUpgrade","setDeviceVerified","trustLevel","firstUse","isVerified","deviceIds","checkForValidDeviceSignature","map","signatures","signame","split","verifySignature","push","getCrossSigningId","userCrossSigning","UserTrustLevel","checkDeviceInfoTrust","trustedLocally","trustCrossSig","DeviceTrustLevel","checkIfOwnDeviceCrossSigned","masterChanged","masterExistsNotLocallyCached","has","ret","oldSelfSigningId","oldUserSigningId","selfSigningChanged","userSigningChanged","selfSigningExistsNotLocallyCached","userSigningExistsNotLocallyCached","keySignatures","masterKey","deviceSig","assign","keysToUpload","checkKeyBackup","clearKeys","storeCrossSigningKeys","user_signing","includes","enableLazyLoading","lazyLoadMembers","registerEventHandlers","eventEmitter","RoomMemberEvent","Membership","onMembership","ClientEvent","ToDeviceEvent","RoomEvent","Timeline","onTimelineEvent","start","stop","getDeviceEd25519Key","getDeviceCurve25519Key","setGlobalBlacklistUnverifiedDevices","value","globalBlacklistUnverifiedDevices","getGlobalBlacklistUnverifiedDevices","uploadDeviceKeys","device_id","user_id","uploadKeysRequest","device_keys","updateOneTimeKeyCount","currentCount","isFinite","oneTimeKeyCount","TypeError","setNeedsNewFallback","needsNewFallback","getNeedsNewFallback","maybeUploadOneTimeKeys","uploadPeriod","maxKeysPerCycle","oneTimeKeyCheckInProgress","now","Date","lastOneTimeKeyCheck","maxOneTimeKeys","maxNumberOfOneTimeKeys","keyLimit","Math","floor","uploadLoop","keyCount","keysThisLoop","min","generateOneTimeKeys","fallbackKeys","getFallbackKey","curve25519","fallbackCleanup","clearTimeout","generateFallbackKey","res","uploadOneTimeKeys","one_time_key_counts","signed_curve25519","stack","finally","promises","fallbackJson","fallback","oneTimeKeys","getOneTimeKeys","oneTimeJson","hasOwnProperty","all","requestBody","one_time_keys","setTimeout","forgetOldFallbackKey","markKeysAsPublished","userIds","forceDownload","getStoredDevicesForUser","saveDeviceList","delay","setDeviceVerification","blocked","xsk","gotKeyId","values","signUser","dev","verificationStatus","UNVERIFIED","BLOCKED","knownStatus","cancelAndResendAllOutgoingKeyRequests","findVerificationRequestDMInProgress","roomId","findRequestInProgress","getVerificationRequestsToDeviceInProgress","getRequestsInProgress","requestVerificationDM","existingRequest","requestVerificationWithChannel","requestVerification","ToDeviceChannel","makeTransactionId","requestsMap","transactionId","setRequestByChannel","sendRequest","racingRequest","getRequestByChannel","beginKeyVerification","getRequestBySenderAndTxnId","setRequestBySenderAndTxnId","legacyDeviceVerification","verifier","race","verify","waitFor","r","started","getOlmSessionsForUser","result","deviceKey","getIdentityKey","sessions","getSessionInfoForDevice","deviceIdKey","getEventSenderDeviceInfo","senderKey","getSenderKey","getWireContent","isKeySourceUntrusted","getDeviceByIdentityKey","claimedKey","getClaimedEd25519Key","getFingerprint","getEventEncryptionInfo","encrypted","authenticated","sender","mismatchedSender","forceDiscardSession","alg","roomEncryptors","setRoomEncryption","config","inhibitDeviceQuery","getRoom","setRoomEncryptionImpl","refreshOutdatedDeviceLists","existingConfig","getRoomEncryption","JSON","stringify","existingAlg","storeConfigPromise","AlgClass","ENCRYPTION_CLASSES","crypto","membersLoaded","trackRoomDevicesImpl","onState","_state","off","RoomStateEvent","Update","trackRoomDevices","trackMembers","members","getEncryptionTargetMembers","forEach","m","promise","roomDeviceTrackingState","err","ensureOlmSessionsForUsers","force","devicesByUser","ensureOlmSessionsForDevices","exportRoomKeys","exportedSessions","STORE_INBOUND_GROUP_SESSIONS","getAllEndToEndInboundGroupSessions","s","sess","exportInboundGroupSession","sessionId","sessionData","first_known_index","MEGOLM_ALGORITHM","importRoomKeys","successes","total","updateProgress","progressCallback","stage","room_id","getRoomDecryptor","importRoomKey","countSessionsNeedingBackup","prepareToEncrypt","encryptEvent","content","mRelatesTo","elementPerfMetrics","encryptedContent","encryptMessage","makeEncrypted","decryptEvent","isRedacted","redactionEvent","MatrixEvent","getUnsigned","redacted_because","decryptedEvent","clearEvent","unsigned","handleDeviceListChanges","syncData","syncDeviceLists","oldSyncToken","evalDeviceListChanges","requestRoomKey","recipients","resend","queueRoomKeyRequest","sendKeyRequestsImmediately","sendQueuedRequests","cancelRoomKeyRequest","cancelAndResendAllOutgoingRequests","onCryptoEvent","onSyncWillProcess","stopTrackingAllDeviceLists","onSyncCompleted","setSyncToken","nextSyncToken","catchingUp","processReceivedRoomKeyRequests","deviceLists","isArray","u","invalidateUserDeviceList","left","e2eUserIds","Set","getTrackedE2eUsers","stopTrackingDeviceList","getTrackedE2eRooms","getRooms","filter","myMembership","getMyMembership","encryptAndSendToDevices","userDeviceInfoArr","payload","toDeviceBatch","eventType","EventType","RoomMessageEncrypted","batch","OLM_ALGORITHM","sender_key","uuidv4","encryptMessageForDevice","msg","queueToDevice","checkedForBackup","code","session_id","reason","roomDecryptors","getRoomDecryptors","decryptor","retryDecryptionFromSender","canCreateRequest","getEventType","from_device","isLiveEvent","isSending","status","EventStatus","SENT","eventIdListener","statusListener","reject","CANCELLED","LocalEventIdReplaced","Status","removeListener","getRequest","isNewRequest","setRequest","setVerificationRequest","handleEvent","initiatedByMe","invalid","observeOnly","retryDecryption","lastNewSessionForced","debug","recordSessionProblem","sendToDevice","requestsToResend","getOutgoingSentRoomKeyRequest","keyReq","membership","shouldEncryptForInvitedMembers","action","req","IncomingRoomKeyRequest","receivedRoomKeyRequests","IncomingRoomKeyRequestCancellation","receivedRoomKeyRequestCancellations","processingRoomKeyRequests","requests","cancellations","processReceivedRoomKeyRequest","cancellation","processReceivedRoomKeyRequestCancellation","body","requestId","encryptor","reshareKeyWithDevice","hasKeysForKeyRequest","share","shareKeysWithDevice","RoomKeyRequest","RoomKeyRequestCancellation","decryptors","DecryptionError","d","obj","sigs","sign","anotherjson","indexOf","x","parseInt","requesting_device_id","request_id"],"sources":["../../src/crypto/index.ts"],"sourcesContent":["/*\nCopyright 2016 OpenMarket Ltd\nCopyright 2017 Vector Creations Ltd\nCopyright 2018-2019 New Vector Ltd\nCopyright 2019-2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport anotherjson from \"another-json\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nimport type { IEventDecryptionResult, IMegolmSessionData } from \"../@types/crypto\";\nimport type { PkDecryption, PkSigning } from \"@matrix-org/olm\";\nimport { EventType, ToDeviceMessageId } from \"../@types/event\";\nimport { TypedReEmitter } from \"../ReEmitter\";\nimport { logger } from \"../logger\";\nimport { IExportedDevice, OlmDevice } from \"./OlmDevice\";\nimport { IOlmDevice } from \"./algorithms/megolm\";\nimport * as olmlib from \"./olmlib\";\nimport { DeviceInfoMap, DeviceList } from \"./DeviceList\";\nimport { DeviceInfo, IDevice } from \"./deviceinfo\";\nimport type { DecryptionAlgorithm, EncryptionAlgorithm } from \"./algorithms\";\nimport * as algorithms from \"./algorithms\";\nimport { createCryptoStoreCacheCallbacks, CrossSigningInfo, DeviceTrustLevel, UserTrustLevel } from \"./CrossSigning\";\nimport { EncryptionSetupBuilder } from \"./EncryptionSetup\";\nimport {\n    IAccountDataClient,\n    ISecretRequest,\n    SECRET_STORAGE_ALGORITHM_V1_AES,\n    SecretStorage,\n    SecretStorageKeyObject,\n    SecretStorageKeyTuple,\n} from \"./SecretStorage\";\nimport {\n    IAddSecretStorageKeyOpts,\n    ICreateSecretStorageOpts,\n    IEncryptedEventInfo,\n    IImportRoomKeysOpts,\n    IRecoveryKey,\n    ISecretStorageKeyInfo,\n} from \"./api\";\nimport { OutgoingRoomKeyRequestManager } from \"./OutgoingRoomKeyRequestManager\";\nimport { IndexedDBCryptoStore } from \"./store/indexeddb-crypto-store\";\nimport { VerificationBase } from \"./verification/Base\";\nimport { ReciprocateQRCode, SCAN_QR_CODE_METHOD, SHOW_QR_CODE_METHOD } from \"./verification/QRCode\";\nimport { SAS as SASVerification } from \"./verification/SAS\";\nimport { keyFromPassphrase } from \"./key_passphrase\";\nimport { decodeRecoveryKey, encodeRecoveryKey } from \"./recoverykey\";\nimport { VerificationRequest } from \"./verification/request/VerificationRequest\";\nimport { InRoomChannel, InRoomRequests } from \"./verification/request/InRoomChannel\";\nimport { ToDeviceChannel, ToDeviceRequests, Request } from \"./verification/request/ToDeviceChannel\";\nimport { IllegalMethod } from \"./verification/IllegalMethod\";\nimport { KeySignatureUploadError } from \"../errors\";\nimport { calculateKeyCheck, decryptAES, encryptAES } from \"./aes\";\nimport { DehydrationManager, IDeviceKeys, IOneTimeKey } from \"./dehydration\";\nimport { BackupManager } from \"./backup\";\nimport { IStore } from \"../store\";\nimport { Room, RoomEvent } from \"../models/room\";\nimport { RoomMember, RoomMemberEvent } from \"../models/room-member\";\nimport { EventStatus, IEvent, MatrixEvent, MatrixEventEvent } from \"../models/event\";\nimport { ToDeviceBatch } from \"../models/ToDeviceMessage\";\nimport {\n    ClientEvent,\n    ICrossSigningKey,\n    IKeysUploadResponse,\n    ISignedKey,\n    IUploadKeySignaturesResponse,\n    MatrixClient,\n} from \"../client\";\nimport type { IRoomEncryption, RoomList } from \"./RoomList\";\nimport { IKeyBackupInfo } from \"./keybackup\";\nimport { ISyncStateData } from \"../sync\";\nimport { CryptoStore } from \"./store/base\";\nimport { IVerificationChannel } from \"./verification/request/Channel\";\nimport { TypedEventEmitter } from \"../models/typed-event-emitter\";\nimport { IContent } from \"../models/event\";\nimport { ISyncResponse } from \"../sync-accumulator\";\nimport { ISignatures } from \"../@types/signed\";\nimport { IMessage } from \"./algorithms/olm\";\nimport { CryptoBackend } from \"../common-crypto/CryptoBackend\";\nimport { RoomState, RoomStateEvent } from \"../models/room-state\";\n\nconst DeviceVerification = DeviceInfo.DeviceVerification;\n\nconst defaultVerificationMethods = {\n    [ReciprocateQRCode.NAME]: ReciprocateQRCode,\n    [SASVerification.NAME]: SASVerification,\n\n    // These two can't be used for actual verification, but we do\n    // need to be able to define them here for the verification flows\n    // to start.\n    [SHOW_QR_CODE_METHOD]: IllegalMethod,\n    [SCAN_QR_CODE_METHOD]: IllegalMethod,\n} as const;\n\n/**\n * verification method names\n */\n// legacy export identifier\nexport const verificationMethods = {\n    RECIPROCATE_QR_CODE: ReciprocateQRCode.NAME,\n    SAS: SASVerification.NAME,\n} as const;\n\nexport type VerificationMethod = keyof typeof verificationMethods | string;\n\nexport function isCryptoAvailable(): boolean {\n    return Boolean(global.Olm);\n}\n\nconst MIN_FORCE_SESSION_INTERVAL_MS = 60 * 60 * 1000;\n\ninterface IInitOpts {\n    exportedOlmDevice?: IExportedDevice;\n    pickleKey?: string;\n}\n\nexport interface IBootstrapCrossSigningOpts {\n    /** Optional. Reset even if keys already exist. */\n    setupNewCrossSigning?: boolean;\n    /**\n     * A function that makes the request requiring auth. Receives the auth data as an object.\n     * Can be called multiple times, first with an empty authDict, to obtain the flows.\n     */\n    authUploadDeviceSigningKeys?(makeRequest: (authData: any) => Promise<{}>): Promise<void>;\n}\n\nexport interface ICryptoCallbacks {\n    getCrossSigningKey?: (keyType: string, pubKey: string) => Promise<Uint8Array | null>;\n    saveCrossSigningKeys?: (keys: Record<string, Uint8Array>) => void;\n    shouldUpgradeDeviceVerifications?: (users: Record<string, any>) => Promise<string[]>;\n    getSecretStorageKey?: (\n        keys: { keys: Record<string, ISecretStorageKeyInfo> },\n        name: string,\n    ) => Promise<[string, Uint8Array] | null>;\n    cacheSecretStorageKey?: (keyId: string, keyInfo: ISecretStorageKeyInfo, key: Uint8Array) => void;\n    onSecretRequested?: (\n        userId: string,\n        deviceId: string,\n        requestId: string,\n        secretName: string,\n        deviceTrust: DeviceTrustLevel,\n    ) => Promise<string>;\n    getDehydrationKey?: (keyInfo: ISecretStorageKeyInfo, checkFunc: (key: Uint8Array) => void) => Promise<Uint8Array>;\n    getBackupKey?: () => Promise<Uint8Array>;\n}\n\n/* eslint-disable camelcase */\ninterface IRoomKey {\n    room_id: string;\n    algorithm: string;\n}\n\n/**\n * The parameters of a room key request. The details of the request may\n * vary with the crypto algorithm, but the management and storage layers for\n * outgoing requests expect it to have 'room_id' and 'session_id' properties.\n */\nexport interface IRoomKeyRequestBody extends IRoomKey {\n    session_id: string;\n    sender_key: string;\n}\n\n/* eslint-enable camelcase */\n\ninterface IDeviceVerificationUpgrade {\n    devices: DeviceInfo[];\n    crossSigningInfo: CrossSigningInfo;\n}\n\nexport interface ICheckOwnCrossSigningTrustOpts {\n    allowPrivateKeyRequests?: boolean;\n}\n\ninterface IUserOlmSession {\n    deviceIdKey: string;\n    sessions: {\n        sessionId: string;\n        hasReceivedMessage: boolean;\n    }[];\n}\n\nexport interface IRoomKeyRequestRecipient {\n    userId: string;\n    deviceId: string;\n}\n\ninterface ISignableObject {\n    signatures?: ISignatures;\n    unsigned?: object;\n}\n\nexport interface IRequestsMap {\n    getRequest(event: MatrixEvent): VerificationRequest | undefined;\n    getRequestByChannel(channel: IVerificationChannel): VerificationRequest | undefined;\n    setRequest(event: MatrixEvent, request: VerificationRequest): void;\n    setRequestByChannel(channel: IVerificationChannel, request: VerificationRequest): void;\n}\n\n/* eslint-disable camelcase */\nexport interface IOlmEncryptedContent {\n    algorithm: typeof olmlib.OLM_ALGORITHM;\n    sender_key: string;\n    ciphertext: Record<string, IMessage>;\n    [ToDeviceMessageId]?: string;\n}\n\nexport interface IMegolmEncryptedContent {\n    algorithm: typeof olmlib.MEGOLM_ALGORITHM;\n    sender_key: string;\n    session_id: string;\n    device_id: string;\n    ciphertext: string;\n    [ToDeviceMessageId]?: string;\n}\n/* eslint-enable camelcase */\n\nexport type IEncryptedContent = IOlmEncryptedContent | IMegolmEncryptedContent;\n\nexport enum CryptoEvent {\n    DeviceVerificationChanged = \"deviceVerificationChanged\",\n    UserTrustStatusChanged = \"userTrustStatusChanged\",\n    UserCrossSigningUpdated = \"userCrossSigningUpdated\",\n    RoomKeyRequest = \"crypto.roomKeyRequest\",\n    RoomKeyRequestCancellation = \"crypto.roomKeyRequestCancellation\",\n    KeyBackupStatus = \"crypto.keyBackupStatus\",\n    KeyBackupFailed = \"crypto.keyBackupFailed\",\n    KeyBackupSessionsRemaining = \"crypto.keyBackupSessionsRemaining\",\n    KeySignatureUploadFailure = \"crypto.keySignatureUploadFailure\",\n    VerificationRequest = \"crypto.verification.request\",\n    Warning = \"crypto.warning\",\n    WillUpdateDevices = \"crypto.willUpdateDevices\",\n    DevicesUpdated = \"crypto.devicesUpdated\",\n    KeysChanged = \"crossSigning.keysChanged\",\n}\n\nexport type CryptoEventHandlerMap = {\n    /**\n     * Fires when a device is marked as verified/unverified/blocked/unblocked by\n     * {@link MatrixClient#setDeviceVerified|MatrixClient.setDeviceVerified} or\n     * {@link MatrixClient#setDeviceBlocked|MatrixClient.setDeviceBlocked}.\n     *\n     * @param userId - the owner of the verified device\n     * @param deviceId - the id of the verified device\n     * @param deviceInfo - updated device information\n     */\n    [CryptoEvent.DeviceVerificationChanged]: (userId: string, deviceId: string, device: DeviceInfo) => void;\n    /**\n     * Fires when the trust status of a user changes\n     * If userId is the userId of the logged-in user, this indicated a change\n     * in the trust status of the cross-signing data on the account.\n     *\n     * The cross-signing API is currently UNSTABLE and may change without notice.\n     * @experimental\n     *\n     * @param userId - the userId of the user in question\n     * @param trustLevel - The new trust level of the user\n     */\n    [CryptoEvent.UserTrustStatusChanged]: (userId: string, trustLevel: UserTrustLevel) => void;\n    /**\n     * Fires when we receive a room key request\n     *\n     * @param req - request details\n     */\n    [CryptoEvent.RoomKeyRequest]: (request: IncomingRoomKeyRequest) => void;\n    /**\n     * Fires when we receive a room key request cancellation\n     */\n    [CryptoEvent.RoomKeyRequestCancellation]: (request: IncomingRoomKeyRequestCancellation) => void;\n    /**\n     * Fires whenever the status of e2e key backup changes, as returned by getKeyBackupEnabled()\n     * @param enabled - true if key backup has been enabled, otherwise false\n     * @example\n     * ```\n     * matrixClient.on(\"crypto.keyBackupStatus\", function(enabled){\n     *   if (enabled) {\n     *     [...]\n     *   }\n     * });\n     * ```\n     */\n    [CryptoEvent.KeyBackupStatus]: (enabled: boolean) => void;\n    [CryptoEvent.KeyBackupFailed]: (errcode: string) => void;\n    [CryptoEvent.KeyBackupSessionsRemaining]: (remaining: number) => void;\n    [CryptoEvent.KeySignatureUploadFailure]: (\n        failures: IUploadKeySignaturesResponse[\"failures\"],\n        source: \"checkOwnCrossSigningTrust\" | \"afterCrossSigningLocalKeyChange\" | \"setDeviceVerification\",\n        upload: (opts: { shouldEmit: boolean }) => Promise<void>,\n    ) => void;\n    /**\n     * Fires when a key verification is requested.\n     */\n    [CryptoEvent.VerificationRequest]: (request: VerificationRequest<any>) => void;\n    /**\n     * Fires when the app may wish to warn the user about something related\n     * the end-to-end crypto.\n     *\n     * @param type - One of the strings listed above\n     */\n    [CryptoEvent.Warning]: (type: string) => void;\n    /**\n     * Fires when the user's cross-signing keys have changed or cross-signing\n     * has been enabled/disabled. The client can use getStoredCrossSigningForUser\n     * with the user ID of the logged in user to check if cross-signing is\n     * enabled on the account. If enabled, it can test whether the current key\n     * is trusted using with checkUserTrust with the user ID of the logged\n     * in user. The checkOwnCrossSigningTrust function may be used to reconcile\n     * the trust in the account key.\n     *\n     * The cross-signing API is currently UNSTABLE and may change without notice.\n     * @experimental\n     */\n    [CryptoEvent.KeysChanged]: (data: {}) => void;\n    /**\n     * Fires whenever the stored devices for a user will be updated\n     * @param users - A list of user IDs that will be updated\n     * @param initialFetch - If true, the store is empty (apart\n     *     from our own device) and is being seeded.\n     */\n    [CryptoEvent.WillUpdateDevices]: (users: string[], initialFetch: boolean) => void;\n    /**\n     * Fires whenever the stored devices for a user have changed\n     * @param users - A list of user IDs that were updated\n     * @param initialFetch - If true, the store was empty (apart\n     *     from our own device) and has been seeded.\n     */\n    [CryptoEvent.DevicesUpdated]: (users: string[], initialFetch: boolean) => void;\n    [CryptoEvent.UserCrossSigningUpdated]: (userId: string) => void;\n};\n\nexport class Crypto extends TypedEventEmitter<CryptoEvent, CryptoEventHandlerMap> implements CryptoBackend {\n    /**\n     * @returns The version of Olm.\n     */\n    public static getOlmVersion(): [number, number, number] {\n        return OlmDevice.getOlmVersion();\n    }\n\n    public readonly backupManager: BackupManager;\n    public readonly crossSigningInfo: CrossSigningInfo;\n    public readonly olmDevice: OlmDevice;\n    public readonly deviceList: DeviceList;\n    public readonly dehydrationManager: DehydrationManager;\n    public readonly secretStorage: SecretStorage;\n\n    private readonly reEmitter: TypedReEmitter<CryptoEvent, CryptoEventHandlerMap>;\n    private readonly verificationMethods: Map<VerificationMethod, typeof VerificationBase>;\n    public readonly supportedAlgorithms: string[];\n    private readonly outgoingRoomKeyRequestManager: OutgoingRoomKeyRequestManager;\n    private readonly toDeviceVerificationRequests: ToDeviceRequests;\n    public readonly inRoomVerificationRequests: InRoomRequests;\n\n    private trustCrossSignedDevices = true;\n    // the last time we did a check for the number of one-time-keys on the server.\n    private lastOneTimeKeyCheck: number | null = null;\n    private oneTimeKeyCheckInProgress = false;\n\n    // EncryptionAlgorithm instance for each room\n    private roomEncryptors = new Map<string, EncryptionAlgorithm>();\n    // map from algorithm to DecryptionAlgorithm instance, for each room\n    private roomDecryptors = new Map<string, Map<string, DecryptionAlgorithm>>();\n\n    private deviceKeys: Record<string, string> = {}; // type: key\n\n    public globalBlacklistUnverifiedDevices = false;\n    public globalErrorOnUnknownDevices = true;\n\n    // list of IncomingRoomKeyRequests/IncomingRoomKeyRequestCancellations\n    // we received in the current sync.\n    private receivedRoomKeyRequests: IncomingRoomKeyRequest[] = [];\n    private receivedRoomKeyRequestCancellations: IncomingRoomKeyRequestCancellation[] = [];\n    // true if we are currently processing received room key requests\n    private processingRoomKeyRequests = false;\n    // controls whether device tracking is delayed\n    // until calling encryptEvent or trackRoomDevices,\n    // or done immediately upon enabling room encryption.\n    private lazyLoadMembers = false;\n    // in case lazyLoadMembers is true,\n    // track if an initial tracking of all the room members\n    // has happened for a given room. This is delayed\n    // to avoid loading room members as long as possible.\n    private roomDeviceTrackingState: { [roomId: string]: Promise<void> } = {};\n\n    // The timestamp of the last time we forced establishment\n    // of a new session for each device, in milliseconds.\n    // {\n    //     userId: {\n    //         deviceId: 1234567890000,\n    //     },\n    // }\n    private lastNewSessionForced: Record<string, Record<string, number>> = {};\n\n    // This flag will be unset whilst the client processes a sync response\n    // so that we don't start requesting keys until we've actually finished\n    // processing the response.\n    private sendKeyRequestsImmediately = false;\n\n    private oneTimeKeyCount?: number;\n    private needsNewFallback?: boolean;\n    private fallbackCleanup?: ReturnType<typeof setTimeout>;\n\n    /**\n     * Cryptography bits\n     *\n     * This module is internal to the js-sdk; the public API is via MatrixClient.\n     *\n     * @internal\n     *\n     * @param baseApis - base matrix api interface\n     *\n     * @param userId - The user ID for the local user\n     *\n     * @param deviceId - The identifier for this device.\n     *\n     * @param clientStore - the MatrixClient data store.\n     *\n     * @param cryptoStore - storage for the crypto layer.\n     *\n     * @param roomList - An initialised RoomList object\n     *\n     * @param verificationMethods - Array of verification methods to use.\n     *    Each element can either be a string from MatrixClient.verificationMethods\n     *    or a class that implements a verification method.\n     */\n    public constructor(\n        public readonly baseApis: MatrixClient,\n        public readonly userId: string,\n        private readonly deviceId: string,\n        private readonly clientStore: IStore,\n        public readonly cryptoStore: CryptoStore,\n        private readonly roomList: RoomList,\n        verificationMethods: Array<VerificationMethod | (typeof VerificationBase & { NAME: string })>,\n    ) {\n        super();\n        this.reEmitter = new TypedReEmitter(this);\n\n        if (verificationMethods) {\n            this.verificationMethods = new Map();\n            for (const method of verificationMethods) {\n                if (typeof method === \"string\") {\n                    if (defaultVerificationMethods[method]) {\n                        this.verificationMethods.set(\n                            method,\n                            <typeof VerificationBase>defaultVerificationMethods[method],\n                        );\n                    }\n                } else if (method[\"NAME\"]) {\n                    this.verificationMethods.set(method[\"NAME\"], method as typeof VerificationBase);\n                } else {\n                    logger.warn(`Excluding unknown verification method ${method}`);\n                }\n            }\n        } else {\n            this.verificationMethods = new Map(Object.entries(defaultVerificationMethods)) as Map<\n                VerificationMethod,\n                typeof VerificationBase\n            >;\n        }\n\n        this.backupManager = new BackupManager(baseApis, async () => {\n            // try to get key from cache\n            const cachedKey = await this.getSessionBackupPrivateKey();\n            if (cachedKey) {\n                return cachedKey;\n            }\n\n            // try to get key from secret storage\n            const storedKey = await this.getSecret(\"m.megolm_backup.v1\");\n\n            if (storedKey) {\n                // ensure that the key is in the right format.  If not, fix the key and\n                // store the fixed version\n                const fixedKey = fixBackupKey(storedKey);\n                if (fixedKey) {\n                    const keys = await this.getSecretStorageKey();\n                    await this.storeSecret(\"m.megolm_backup.v1\", fixedKey, [keys![0]]);\n                }\n\n                return olmlib.decodeBase64(fixedKey || storedKey);\n            }\n\n            // try to get key from app\n            if (this.baseApis.cryptoCallbacks && this.baseApis.cryptoCallbacks.getBackupKey) {\n                return this.baseApis.cryptoCallbacks.getBackupKey();\n            }\n\n            throw new Error(\"Unable to get private key\");\n        });\n\n        this.olmDevice = new OlmDevice(cryptoStore);\n        this.deviceList = new DeviceList(baseApis, cryptoStore, this.olmDevice);\n\n        // XXX: This isn't removed at any point, but then none of the event listeners\n        // this class sets seem to be removed at any point... :/\n        this.deviceList.on(CryptoEvent.UserCrossSigningUpdated, this.onDeviceListUserCrossSigningUpdated);\n        this.reEmitter.reEmit(this.deviceList, [CryptoEvent.DevicesUpdated, CryptoEvent.WillUpdateDevices]);\n\n        this.supportedAlgorithms = Array.from(algorithms.DECRYPTION_CLASSES.keys());\n\n        this.outgoingRoomKeyRequestManager = new OutgoingRoomKeyRequestManager(\n            baseApis,\n            this.deviceId,\n            this.cryptoStore,\n        );\n\n        this.toDeviceVerificationRequests = new ToDeviceRequests();\n        this.inRoomVerificationRequests = new InRoomRequests();\n\n        const cryptoCallbacks = this.baseApis.cryptoCallbacks || {};\n        const cacheCallbacks = createCryptoStoreCacheCallbacks(cryptoStore, this.olmDevice);\n\n        this.crossSigningInfo = new CrossSigningInfo(userId, cryptoCallbacks, cacheCallbacks);\n        // Yes, we pass the client twice here: see SecretStorage\n        this.secretStorage = new SecretStorage(baseApis as IAccountDataClient, cryptoCallbacks, baseApis);\n        this.dehydrationManager = new DehydrationManager(this);\n\n        // Assuming no app-supplied callback, default to getting from SSSS.\n        if (!cryptoCallbacks.getCrossSigningKey && cryptoCallbacks.getSecretStorageKey) {\n            cryptoCallbacks.getCrossSigningKey = async (type): Promise<Uint8Array | null> => {\n                return CrossSigningInfo.getFromSecretStorage(type, this.secretStorage);\n            };\n        }\n    }\n\n    /**\n     * Initialise the crypto module so that it is ready for use\n     *\n     * Returns a promise which resolves once the crypto module is ready for use.\n     *\n     * @param exportedOlmDevice - (Optional) data from exported device\n     *     that must be re-created.\n     */\n    public async init({ exportedOlmDevice, pickleKey }: IInitOpts = {}): Promise<void> {\n        logger.log(\"Crypto: initialising Olm...\");\n        await global.Olm.init();\n        logger.log(\n            exportedOlmDevice\n                ? \"Crypto: initialising Olm device from exported device...\"\n                : \"Crypto: initialising Olm device...\",\n        );\n        await this.olmDevice.init({ fromExportedDevice: exportedOlmDevice, pickleKey });\n        logger.log(\"Crypto: loading device list...\");\n        await this.deviceList.load();\n\n        // build our device keys: these will later be uploaded\n        this.deviceKeys[\"ed25519:\" + this.deviceId] = this.olmDevice.deviceEd25519Key!;\n        this.deviceKeys[\"curve25519:\" + this.deviceId] = this.olmDevice.deviceCurve25519Key!;\n\n        logger.log(\"Crypto: fetching own devices...\");\n        let myDevices = this.deviceList.getRawStoredDevicesForUser(this.userId);\n\n        if (!myDevices) {\n            myDevices = {};\n        }\n\n        if (!myDevices[this.deviceId]) {\n            // add our own deviceinfo to the cryptoStore\n            logger.log(\"Crypto: adding this device to the store...\");\n            const deviceInfo = {\n                keys: this.deviceKeys,\n                algorithms: this.supportedAlgorithms,\n                verified: DeviceVerification.VERIFIED,\n                known: true,\n            };\n\n            myDevices[this.deviceId] = deviceInfo;\n            this.deviceList.storeDevicesForUser(this.userId, myDevices);\n            this.deviceList.saveIfDirty();\n        }\n\n        await this.cryptoStore.doTxn(\"readonly\", [IndexedDBCryptoStore.STORE_ACCOUNT], (txn) => {\n            this.cryptoStore.getCrossSigningKeys(txn, (keys) => {\n                // can be an empty object after resetting cross-signing keys, see storeTrustedSelfKeys\n                if (keys && Object.keys(keys).length !== 0) {\n                    logger.log(\"Loaded cross-signing public keys from crypto store\");\n                    this.crossSigningInfo.setKeys(keys);\n                }\n            });\n        });\n        // make sure we are keeping track of our own devices\n        // (this is important for key backups & things)\n        this.deviceList.startTrackingDeviceList(this.userId);\n\n        logger.log(\"Crypto: checking for key backup...\");\n        this.backupManager.checkAndStart();\n    }\n\n    /**\n     * Whether to trust a others users signatures of their devices.\n     * If false, devices will only be considered 'verified' if we have\n     * verified that device individually (effectively disabling cross-signing).\n     *\n     * Default: true\n     *\n     * @returns True if trusting cross-signed devices\n     */\n    public getCryptoTrustCrossSignedDevices(): boolean {\n        return this.trustCrossSignedDevices;\n    }\n\n    /**\n     * See getCryptoTrustCrossSignedDevices\n\n     * This may be set before initCrypto() is called to ensure no races occur.\n     *\n     * @param val - True to trust cross-signed devices\n     */\n    public setCryptoTrustCrossSignedDevices(val: boolean): void {\n        this.trustCrossSignedDevices = val;\n\n        for (const userId of this.deviceList.getKnownUserIds()) {\n            const devices = this.deviceList.getRawStoredDevicesForUser(userId);\n            for (const deviceId of Object.keys(devices)) {\n                const deviceTrust = this.checkDeviceTrust(userId, deviceId);\n                // If the device is locally verified then isVerified() is always true,\n                // so this will only have caused the value to change if the device is\n                // cross-signing verified but not locally verified\n                if (!deviceTrust.isLocallyVerified() && deviceTrust.isCrossSigningVerified()) {\n                    const deviceObj = this.deviceList.getStoredDevice(userId, deviceId)!;\n                    this.emit(CryptoEvent.DeviceVerificationChanged, userId, deviceId, deviceObj);\n                }\n            }\n        }\n    }\n\n    /**\n     * Create a recovery key from a user-supplied passphrase.\n     *\n     * @param password - Passphrase string that can be entered by the user\n     *     when restoring the backup as an alternative to entering the recovery key.\n     *     Optional.\n     * @returns Object with public key metadata, encoded private\n     *     recovery key which should be disposed of after displaying to the user,\n     *     and raw private key to avoid round tripping if needed.\n     */\n    public async createRecoveryKeyFromPassphrase(password?: string): Promise<IRecoveryKey> {\n        const decryption = new global.Olm.PkDecryption();\n        try {\n            const keyInfo: Partial<IRecoveryKey[\"keyInfo\"]> = {};\n            if (password) {\n                const derivation = await keyFromPassphrase(password);\n                keyInfo.passphrase = {\n                    algorithm: \"m.pbkdf2\",\n                    iterations: derivation.iterations,\n                    salt: derivation.salt,\n                };\n                keyInfo.pubkey = decryption.init_with_private_key(derivation.key);\n            } else {\n                keyInfo.pubkey = decryption.generate_key();\n            }\n            const privateKey = decryption.get_private_key();\n            const encodedPrivateKey = encodeRecoveryKey(privateKey);\n            return {\n                keyInfo: keyInfo as IRecoveryKey[\"keyInfo\"],\n                encodedPrivateKey,\n                privateKey,\n            };\n        } finally {\n            decryption?.free();\n        }\n    }\n\n    /**\n     * Checks if the user has previously published cross-signing keys\n     *\n     * This means downloading the devicelist for the user and checking if the list includes\n     * the cross-signing pseudo-device.\n     *\n     * @internal\n     */\n    public async userHasCrossSigningKeys(): Promise<boolean> {\n        await this.downloadKeys([this.userId]);\n        return this.deviceList.getStoredCrossSigningForUser(this.userId) !== null;\n    }\n\n    /**\n     * Checks whether cross signing:\n     * - is enabled on this account and trusted by this device\n     * - has private keys either cached locally or stored in secret storage\n     *\n     * If this function returns false, bootstrapCrossSigning() can be used\n     * to fix things such that it returns true. That is to say, after\n     * bootstrapCrossSigning() completes successfully, this function should\n     * return true.\n     *\n     * The cross-signing API is currently UNSTABLE and may change without notice.\n     *\n     * @returns True if cross-signing is ready to be used on this device\n     */\n    public async isCrossSigningReady(): Promise<boolean> {\n        const publicKeysOnDevice = this.crossSigningInfo.getId();\n        const privateKeysExistSomewhere =\n            (await this.crossSigningInfo.isStoredInKeyCache()) ||\n            (await this.crossSigningInfo.isStoredInSecretStorage(this.secretStorage));\n\n        return !!(publicKeysOnDevice && privateKeysExistSomewhere);\n    }\n\n    /**\n     * Checks whether secret storage:\n     * - is enabled on this account\n     * - is storing cross-signing private keys\n     * - is storing session backup key (if enabled)\n     *\n     * If this function returns false, bootstrapSecretStorage() can be used\n     * to fix things such that it returns true. That is to say, after\n     * bootstrapSecretStorage() completes successfully, this function should\n     * return true.\n     *\n     * The Secure Secret Storage API is currently UNSTABLE and may change without notice.\n     *\n     * @returns True if secret storage is ready to be used on this device\n     */\n    public async isSecretStorageReady(): Promise<boolean> {\n        const secretStorageKeyInAccount = await this.secretStorage.hasKey();\n        const privateKeysInStorage = await this.crossSigningInfo.isStoredInSecretStorage(this.secretStorage);\n        const sessionBackupInStorage =\n            !this.backupManager.getKeyBackupEnabled() || (await this.baseApis.isKeyBackupKeyStored());\n\n        return !!(secretStorageKeyInAccount && privateKeysInStorage && sessionBackupInStorage);\n    }\n\n    /**\n     * Bootstrap cross-signing by creating keys if needed. If everything is already\n     * set up, then no changes are made, so this is safe to run to ensure\n     * cross-signing is ready for use.\n     *\n     * This function:\n     * - creates new cross-signing keys if they are not found locally cached nor in\n     *   secret storage (if it has been setup)\n     *\n     * The cross-signing API is currently UNSTABLE and may change without notice.\n     *\n     * @param authUploadDeviceSigningKeys - Function\n     * called to await an interactive auth flow when uploading device signing keys.\n     * @param setupNewCrossSigning - Optional. Reset even if keys\n     * already exist.\n     * Args:\n     *     A function that makes the request requiring auth. Receives the\n     *     auth data as an object. Can be called multiple times, first with an empty\n     *     authDict, to obtain the flows.\n     */\n    public async bootstrapCrossSigning({\n        authUploadDeviceSigningKeys,\n        setupNewCrossSigning,\n    }: IBootstrapCrossSigningOpts = {}): Promise<void> {\n        logger.log(\"Bootstrapping cross-signing\");\n\n        const delegateCryptoCallbacks = this.baseApis.cryptoCallbacks;\n        const builder = new EncryptionSetupBuilder(this.baseApis.store.accountData, delegateCryptoCallbacks);\n        const crossSigningInfo = new CrossSigningInfo(\n            this.userId,\n            builder.crossSigningCallbacks,\n            builder.crossSigningCallbacks,\n        );\n\n        // Reset the cross-signing keys\n        const resetCrossSigning = async (): Promise<void> => {\n            crossSigningInfo.resetKeys();\n            // Sign master key with device key\n            await this.signObject(crossSigningInfo.keys.master);\n\n            // Store auth flow helper function, as we need to call it when uploading\n            // to ensure we handle auth errors properly.\n            builder.addCrossSigningKeys(authUploadDeviceSigningKeys, crossSigningInfo.keys);\n\n            // Cross-sign own device\n            const device = this.deviceList.getStoredDevice(this.userId, this.deviceId)!;\n            const deviceSignature = await crossSigningInfo.signDevice(this.userId, device);\n            builder.addKeySignature(this.userId, this.deviceId, deviceSignature!);\n\n            // Sign message key backup with cross-signing master key\n            if (this.backupManager.backupInfo) {\n                await crossSigningInfo.signObject(this.backupManager.backupInfo.auth_data, \"master\");\n                builder.addSessionBackup(this.backupManager.backupInfo);\n            }\n        };\n\n        const publicKeysOnDevice = this.crossSigningInfo.getId();\n        const privateKeysInCache = await this.crossSigningInfo.isStoredInKeyCache();\n        const privateKeysInStorage = await this.crossSigningInfo.isStoredInSecretStorage(this.secretStorage);\n        const privateKeysExistSomewhere = privateKeysInCache || privateKeysInStorage;\n\n        // Log all relevant state for easier parsing of debug logs.\n        logger.log({\n            setupNewCrossSigning,\n            publicKeysOnDevice,\n            privateKeysInCache,\n            privateKeysInStorage,\n            privateKeysExistSomewhere,\n        });\n\n        if (!privateKeysExistSomewhere || setupNewCrossSigning) {\n            logger.log(\"Cross-signing private keys not found locally or in secret storage, \" + \"creating new keys\");\n            // If a user has multiple devices, it important to only call bootstrap\n            // as part of some UI flow (and not silently during startup), as they\n            // may have setup cross-signing on a platform which has not saved keys\n            // to secret storage, and this would reset them. In such a case, you\n            // should prompt the user to verify any existing devices first (and\n            // request private keys from those devices) before calling bootstrap.\n            await resetCrossSigning();\n        } else if (publicKeysOnDevice && privateKeysInCache) {\n            logger.log(\"Cross-signing public keys trusted and private keys found locally\");\n        } else if (privateKeysInStorage) {\n            logger.log(\n                \"Cross-signing private keys not found locally, but they are available \" +\n                    \"in secret storage, reading storage and caching locally\",\n            );\n            await this.checkOwnCrossSigningTrust({\n                allowPrivateKeyRequests: true,\n            });\n        }\n\n        // Assuming no app-supplied callback, default to storing new private keys in\n        // secret storage if it exists. If it does not, it is assumed this will be\n        // done as part of setting up secret storage later.\n        const crossSigningPrivateKeys = builder.crossSigningCallbacks.privateKeys;\n        if (crossSigningPrivateKeys.size && !this.baseApis.cryptoCallbacks.saveCrossSigningKeys) {\n            const secretStorage = new SecretStorage(\n                builder.accountDataClientAdapter,\n                builder.ssssCryptoCallbacks,\n                undefined,\n            );\n            if (await secretStorage.hasKey()) {\n                logger.log(\"Storing new cross-signing private keys in secret storage\");\n                // This is writing to in-memory account data in\n                // builder.accountDataClientAdapter so won't fail\n                await CrossSigningInfo.storeInSecretStorage(crossSigningPrivateKeys, secretStorage);\n            }\n        }\n\n        const operation = builder.buildOperation();\n        await operation.apply(this);\n        // This persists private keys and public keys as trusted,\n        // only do this if apply succeeded for now as retry isn't in place yet\n        await builder.persist(this);\n\n        logger.log(\"Cross-signing ready\");\n    }\n\n    /**\n     * Bootstrap Secure Secret Storage if needed by creating a default key. If everything is\n     * already set up, then no changes are made, so this is safe to run to ensure secret\n     * storage is ready for use.\n     *\n     * This function\n     * - creates a new Secure Secret Storage key if no default key exists\n     *   - if a key backup exists, it is migrated to store the key in the Secret\n     *     Storage\n     * - creates a backup if none exists, and one is requested\n     * - migrates Secure Secret Storage to use the latest algorithm, if an outdated\n     *   algorithm is found\n     *\n     * The Secure Secret Storage API is currently UNSTABLE and may change without notice.\n     *\n     * @param createSecretStorageKey - Optional. Function\n     * called to await a secret storage key creation flow.\n     *     Returns a Promise which resolves to an object with public key metadata, encoded private\n     *     recovery key which should be disposed of after displaying to the user,\n     *     and raw private key to avoid round tripping if needed.\n     * @param keyBackupInfo - The current key backup object. If passed,\n     * the passphrase and recovery key from this backup will be used.\n     * @param setupNewKeyBackup - If true, a new key backup version will be\n     * created and the private key stored in the new SSSS store. Ignored if keyBackupInfo\n     * is supplied.\n     * @param setupNewSecretStorage - Optional. Reset even if keys already exist.\n     * @param getKeyBackupPassphrase - Optional. Function called to get the user's\n     *     current key backup passphrase. Should return a promise that resolves with a Buffer\n     *     containing the key, or rejects if the key cannot be obtained.\n     * Returns:\n     *     A promise which resolves to key creation data for\n     *     SecretStorage#addKey: an object with `passphrase` etc fields.\n     */\n    // TODO this does not resolve with what it says it does\n    public async bootstrapSecretStorage({\n        createSecretStorageKey = async (): Promise<IRecoveryKey> => ({} as IRecoveryKey),\n        keyBackupInfo,\n        setupNewKeyBackup,\n        setupNewSecretStorage,\n        getKeyBackupPassphrase,\n    }: ICreateSecretStorageOpts = {}): Promise<void> {\n        logger.log(\"Bootstrapping Secure Secret Storage\");\n        const delegateCryptoCallbacks = this.baseApis.cryptoCallbacks;\n        const builder = new EncryptionSetupBuilder(this.baseApis.store.accountData, delegateCryptoCallbacks);\n        const secretStorage = new SecretStorage(\n            builder.accountDataClientAdapter,\n            builder.ssssCryptoCallbacks,\n            undefined,\n        );\n\n        // the ID of the new SSSS key, if we create one\n        let newKeyId: string | null = null;\n\n        // create a new SSSS key and set it as default\n        const createSSSS = async (opts: IAddSecretStorageKeyOpts, privateKey?: Uint8Array): Promise<string> => {\n            if (privateKey) {\n                opts.key = privateKey;\n            }\n\n            const { keyId, keyInfo } = await secretStorage.addKey(SECRET_STORAGE_ALGORITHM_V1_AES, opts);\n\n            if (privateKey) {\n                // make the private key available to encrypt 4S secrets\n                builder.ssssCryptoCallbacks.addPrivateKey(keyId, keyInfo, privateKey);\n            }\n\n            await secretStorage.setDefaultKeyId(keyId);\n            return keyId;\n        };\n\n        const ensureCanCheckPassphrase = async (keyId: string, keyInfo: ISecretStorageKeyInfo): Promise<void> => {\n            if (!keyInfo.mac) {\n                const key = await this.baseApis.cryptoCallbacks.getSecretStorageKey?.(\n                    { keys: { [keyId]: keyInfo } },\n                    \"\",\n                );\n                if (key) {\n                    const privateKey = key[1];\n                    builder.ssssCryptoCallbacks.addPrivateKey(keyId, keyInfo, privateKey);\n                    const { iv, mac } = await calculateKeyCheck(privateKey);\n                    keyInfo.iv = iv;\n                    keyInfo.mac = mac;\n\n                    await builder.setAccountData(`m.secret_storage.key.${keyId}`, keyInfo);\n                }\n            }\n        };\n\n        const signKeyBackupWithCrossSigning = async (keyBackupAuthData: IKeyBackupInfo[\"auth_data\"]): Promise<void> => {\n            if (this.crossSigningInfo.getId() && (await this.crossSigningInfo.isStoredInKeyCache(\"master\"))) {\n                try {\n                    logger.log(\"Adding cross-signing signature to key backup\");\n                    await this.crossSigningInfo.signObject(keyBackupAuthData, \"master\");\n                } catch (e) {\n                    // This step is not critical (just helpful), so we catch here\n                    // and continue if it fails.\n                    logger.error(\"Signing key backup with cross-signing keys failed\", e);\n                }\n            } else {\n                logger.warn(\"Cross-signing keys not available, skipping signature on key backup\");\n            }\n        };\n\n        const oldSSSSKey = await this.getSecretStorageKey();\n        const [oldKeyId, oldKeyInfo] = oldSSSSKey || [null, null];\n        const storageExists =\n            !setupNewSecretStorage && oldKeyInfo && oldKeyInfo.algorithm === SECRET_STORAGE_ALGORITHM_V1_AES;\n\n        // Log all relevant state for easier parsing of debug logs.\n        logger.log({\n            keyBackupInfo,\n            setupNewKeyBackup,\n            setupNewSecretStorage,\n            storageExists,\n            oldKeyInfo,\n        });\n\n        if (!storageExists && !keyBackupInfo) {\n            // either we don't have anything, or we've been asked to restart\n            // from scratch\n            logger.log(\"Secret storage does not exist, creating new storage key\");\n\n            // if we already have a usable default SSSS key and aren't resetting\n            // SSSS just use it. otherwise, create a new one\n            // Note: we leave the old SSSS key in place: there could be other\n            // secrets using it, in theory. We could move them to the new key but a)\n            // that would mean we'd need to prompt for the old passphrase, and b)\n            // it's not clear that would be the right thing to do anyway.\n            const { keyInfo = {} as IAddSecretStorageKeyOpts, privateKey } = await createSecretStorageKey();\n            newKeyId = await createSSSS(keyInfo, privateKey);\n        } else if (!storageExists && keyBackupInfo) {\n            // we have an existing backup, but no SSSS\n            logger.log(\"Secret storage does not exist, using key backup key\");\n\n            // if we have the backup key already cached, use it; otherwise use the\n            // callback to prompt for the key\n            const backupKey = (await this.getSessionBackupPrivateKey()) || (await getKeyBackupPassphrase?.());\n\n            // create a new SSSS key and use the backup key as the new SSSS key\n            const opts = {} as IAddSecretStorageKeyOpts;\n\n            if (keyBackupInfo.auth_data.private_key_salt && keyBackupInfo.auth_data.private_key_iterations) {\n                // FIXME: ???\n                opts.passphrase = {\n                    algorithm: \"m.pbkdf2\",\n                    iterations: keyBackupInfo.auth_data.private_key_iterations,\n                    salt: keyBackupInfo.auth_data.private_key_salt,\n                    bits: 256,\n                };\n            }\n\n            newKeyId = await createSSSS(opts, backupKey);\n\n            // store the backup key in secret storage\n            await secretStorage.store(\"m.megolm_backup.v1\", olmlib.encodeBase64(backupKey!), [newKeyId]);\n\n            // The backup is trusted because the user provided the private key.\n            // Sign the backup with the cross-signing key so the key backup can\n            // be trusted via cross-signing.\n            await signKeyBackupWithCrossSigning(keyBackupInfo.auth_data);\n\n            builder.addSessionBackup(keyBackupInfo);\n        } else {\n            // 4S is already set up\n            logger.log(\"Secret storage exists\");\n\n            if (oldKeyInfo && oldKeyInfo.algorithm === SECRET_STORAGE_ALGORITHM_V1_AES) {\n                // make sure that the default key has the information needed to\n                // check the passphrase\n                await ensureCanCheckPassphrase(oldKeyId, oldKeyInfo);\n            }\n        }\n\n        // If we have cross-signing private keys cached, store them in secret\n        // storage if they are not there already.\n        if (\n            !this.baseApis.cryptoCallbacks.saveCrossSigningKeys &&\n            (await this.isCrossSigningReady()) &&\n            (newKeyId || !(await this.crossSigningInfo.isStoredInSecretStorage(secretStorage)))\n        ) {\n            logger.log(\"Copying cross-signing private keys from cache to secret storage\");\n            const crossSigningPrivateKeys = await this.crossSigningInfo.getCrossSigningKeysFromCache();\n            // This is writing to in-memory account data in\n            // builder.accountDataClientAdapter so won't fail\n            await CrossSigningInfo.storeInSecretStorage(crossSigningPrivateKeys, secretStorage);\n        }\n\n        if (setupNewKeyBackup && !keyBackupInfo) {\n            logger.log(\"Creating new message key backup version\");\n            const info = await this.baseApis.prepareKeyBackupVersion(\n                null /* random key */,\n                // don't write to secret storage, as it will write to this.secretStorage.\n                // Here, we want to capture all the side-effects of bootstrapping,\n                // and want to write to the local secretStorage object\n                { secureSecretStorage: false },\n            );\n            // write the key ourselves to 4S\n            const privateKey = decodeRecoveryKey(info.recovery_key);\n            await secretStorage.store(\"m.megolm_backup.v1\", olmlib.encodeBase64(privateKey));\n\n            // create keyBackupInfo object to add to builder\n            const data: IKeyBackupInfo = {\n                algorithm: info.algorithm,\n                auth_data: info.auth_data,\n            };\n\n            // Sign with cross-signing master key\n            await signKeyBackupWithCrossSigning(data.auth_data);\n\n            // sign with the device fingerprint\n            await this.signObject(data.auth_data);\n\n            builder.addSessionBackup(data);\n        }\n\n        // Cache the session backup key\n        const sessionBackupKey = await secretStorage.get(\"m.megolm_backup.v1\");\n        if (sessionBackupKey) {\n            logger.info(\"Got session backup key from secret storage: caching\");\n            // fix up the backup key if it's in the wrong format, and replace\n            // in secret storage\n            const fixedBackupKey = fixBackupKey(sessionBackupKey);\n            if (fixedBackupKey) {\n                const keyId = newKeyId || oldKeyId;\n                await secretStorage.store(\"m.megolm_backup.v1\", fixedBackupKey, keyId ? [keyId] : null);\n            }\n            const decodedBackupKey = new Uint8Array(olmlib.decodeBase64(fixedBackupKey || sessionBackupKey));\n            builder.addSessionBackupPrivateKeyToCache(decodedBackupKey);\n        } else if (this.backupManager.getKeyBackupEnabled()) {\n            // key backup is enabled but we don't have a session backup key in SSSS: see if we have one in\n            // the cache or the user can provide one, and if so, write it to SSSS\n            const backupKey = (await this.getSessionBackupPrivateKey()) || (await getKeyBackupPassphrase?.());\n            if (!backupKey) {\n                // This will require user intervention to recover from since we don't have the key\n                // backup key anywhere. The user should probably just set up a new key backup and\n                // the key for the new backup will be stored. If we hit this scenario in the wild\n                // with any frequency, we should do more than just log an error.\n                logger.error(\"Key backup is enabled but couldn't get key backup key!\");\n                return;\n            }\n            logger.info(\"Got session backup key from cache/user that wasn't in SSSS: saving to SSSS\");\n            await secretStorage.store(\"m.megolm_backup.v1\", olmlib.encodeBase64(backupKey));\n        }\n\n        const operation = builder.buildOperation();\n        await operation.apply(this);\n        // this persists private keys and public keys as trusted,\n        // only do this if apply succeeded for now as retry isn't in place yet\n        await builder.persist(this);\n\n        logger.log(\"Secure Secret Storage ready\");\n    }\n\n    public addSecretStorageKey(\n        algorithm: string,\n        opts: IAddSecretStorageKeyOpts,\n        keyID?: string,\n    ): Promise<SecretStorageKeyObject> {\n        return this.secretStorage.addKey(algorithm, opts, keyID);\n    }\n\n    public hasSecretStorageKey(keyID?: string): Promise<boolean> {\n        return this.secretStorage.hasKey(keyID);\n    }\n\n    public getSecretStorageKey(keyID?: string): Promise<SecretStorageKeyTuple | null> {\n        return this.secretStorage.getKey(keyID);\n    }\n\n    public storeSecret(name: string, secret: string, keys?: string[]): Promise<void> {\n        return this.secretStorage.store(name, secret, keys);\n    }\n\n    public getSecret(name: string): Promise<string | undefined> {\n        return this.secretStorage.get(name);\n    }\n\n    public isSecretStored(name: string): Promise<Record<string, ISecretStorageKeyInfo> | null> {\n        return this.secretStorage.isStored(name);\n    }\n\n    public requestSecret(name: string, devices: string[]): ISecretRequest {\n        if (!devices) {\n            devices = Object.keys(this.deviceList.getRawStoredDevicesForUser(this.userId));\n        }\n        return this.secretStorage.request(name, devices);\n    }\n\n    public getDefaultSecretStorageKeyId(): Promise<string | null> {\n        return this.secretStorage.getDefaultKeyId();\n    }\n\n    public setDefaultSecretStorageKeyId(k: string): Promise<void> {\n        return this.secretStorage.setDefaultKeyId(k);\n    }\n\n    public checkSecretStorageKey(key: Uint8Array, info: ISecretStorageKeyInfo): Promise<boolean> {\n        return this.secretStorage.checkKey(key, info);\n    }\n\n    /**\n     * Checks that a given secret storage private key matches a given public key.\n     * This can be used by the getSecretStorageKey callback to verify that the\n     * private key it is about to supply is the one that was requested.\n     *\n     * @param privateKey - The private key\n     * @param expectedPublicKey - The public key\n     * @returns true if the key matches, otherwise false\n     */\n    public checkSecretStoragePrivateKey(privateKey: Uint8Array, expectedPublicKey: string): boolean {\n        let decryption: PkDecryption | null = null;\n        try {\n            decryption = new global.Olm.PkDecryption();\n            const gotPubkey = decryption.init_with_private_key(privateKey);\n            // make sure it agrees with the given pubkey\n            return gotPubkey === expectedPublicKey;\n        } finally {\n            decryption?.free();\n        }\n    }\n\n    /**\n     * Fetches the backup private key, if cached\n     * @returns the key, if any, or null\n     */\n    public async getSessionBackupPrivateKey(): Promise<Uint8Array | null> {\n        let key = await new Promise<any>((resolve) => {\n            // TODO types\n            this.cryptoStore.doTxn(\"readonly\", [IndexedDBCryptoStore.STORE_ACCOUNT], (txn) => {\n                this.cryptoStore.getSecretStorePrivateKey(txn, resolve, \"m.megolm_backup.v1\");\n            });\n        });\n\n        // make sure we have a Uint8Array, rather than a string\n        if (key && typeof key === \"string\") {\n            key = new Uint8Array(olmlib.decodeBase64(fixBackupKey(key) || key));\n            await this.storeSessionBackupPrivateKey(key);\n        }\n        if (key && key.ciphertext) {\n            const pickleKey = Buffer.from(this.olmDevice.pickleKey);\n            const decrypted = await decryptAES(key, pickleKey, \"m.megolm_backup.v1\");\n            key = olmlib.decodeBase64(decrypted);\n        }\n        return key;\n    }\n\n    /**\n     * Stores the session backup key to the cache\n     * @param key - the private key\n     * @returns a promise so you can catch failures\n     */\n    public async storeSessionBackupPrivateKey(key: ArrayLike<number>): Promise<void> {\n        if (!(key instanceof Uint8Array)) {\n            throw new Error(`storeSessionBackupPrivateKey expects Uint8Array, got ${key}`);\n        }\n        const pickleKey = Buffer.from(this.olmDevice.pickleKey);\n        const encryptedKey = await encryptAES(olmlib.encodeBase64(key), pickleKey, \"m.megolm_backup.v1\");\n        return this.cryptoStore.doTxn(\"readwrite\", [IndexedDBCryptoStore.STORE_ACCOUNT], (txn) => {\n            this.cryptoStore.storeSecretStorePrivateKey(txn, \"m.megolm_backup.v1\", encryptedKey);\n        });\n    }\n\n    /**\n     * Checks that a given cross-signing private key matches a given public key.\n     * This can be used by the getCrossSigningKey callback to verify that the\n     * private key it is about to supply is the one that was requested.\n     *\n     * @param privateKey - The private key\n     * @param expectedPublicKey - The public key\n     * @returns true if the key matches, otherwise false\n     */\n    public checkCrossSigningPrivateKey(privateKey: Uint8Array, expectedPublicKey: string): boolean {\n        let signing: PkSigning | null = null;\n        try {\n            signing = new global.Olm.PkSigning();\n            const gotPubkey = signing.init_with_seed(privateKey);\n            // make sure it agrees with the given pubkey\n            return gotPubkey === expectedPublicKey;\n        } finally {\n            signing?.free();\n        }\n    }\n\n    /**\n     * Run various follow-up actions after cross-signing keys have changed locally\n     * (either by resetting the keys for the account or by getting them from secret\n     * storage), such as signing the current device, upgrading device\n     * verifications, etc.\n     */\n    private async afterCrossSigningLocalKeyChange(): Promise<void> {\n        logger.info(\"Starting cross-signing key change post-processing\");\n\n        // sign the current device with the new key, and upload to the server\n        const device = this.deviceList.getStoredDevice(this.userId, this.deviceId)!;\n        const signedDevice = await this.crossSigningInfo.signDevice(this.userId, device);\n        logger.info(`Starting background key sig upload for ${this.deviceId}`);\n\n        const upload = ({ shouldEmit = false }): Promise<void> => {\n            return this.baseApis\n                .uploadKeySignatures({\n                    [this.userId]: {\n                        [this.deviceId]: signedDevice!,\n                    },\n                })\n                .then((response) => {\n                    const { failures } = response || {};\n                    if (Object.keys(failures || []).length > 0) {\n                        if (shouldEmit) {\n                            this.baseApis.emit(\n                                CryptoEvent.KeySignatureUploadFailure,\n                                failures,\n                                \"afterCrossSigningLocalKeyChange\",\n                                upload, // continuation\n                            );\n                        }\n                        throw new KeySignatureUploadError(\"Key upload failed\", { failures });\n                    }\n                    logger.info(`Finished background key sig upload for ${this.deviceId}`);\n                })\n                .catch((e) => {\n                    logger.error(`Error during background key sig upload for ${this.deviceId}`, e);\n                });\n        };\n        upload({ shouldEmit: true });\n\n        const shouldUpgradeCb = this.baseApis.cryptoCallbacks.shouldUpgradeDeviceVerifications;\n        if (shouldUpgradeCb) {\n            logger.info(\"Starting device verification upgrade\");\n\n            // Check all users for signatures if upgrade callback present\n            // FIXME: do this in batches\n            const users: Record<string, IDeviceVerificationUpgrade> = {};\n            for (const [userId, crossSigningInfo] of Object.entries(this.deviceList.crossSigningInfo)) {\n                const upgradeInfo = await this.checkForDeviceVerificationUpgrade(\n                    userId,\n                    CrossSigningInfo.fromStorage(crossSigningInfo, userId),\n                );\n                if (upgradeInfo) {\n                    users[userId] = upgradeInfo;\n                }\n            }\n\n            if (Object.keys(users).length > 0) {\n                logger.info(`Found ${Object.keys(users).length} verif users to upgrade`);\n                try {\n                    const usersToUpgrade = await shouldUpgradeCb({ users: users });\n                    if (usersToUpgrade) {\n                        for (const userId of usersToUpgrade) {\n                            if (userId in users) {\n                                await this.baseApis.setDeviceVerified(userId, users[userId].crossSigningInfo.getId()!);\n                            }\n                        }\n                    }\n                } catch (e) {\n                    logger.log(\"shouldUpgradeDeviceVerifications threw an error: not upgrading\", e);\n                }\n            }\n\n            logger.info(\"Finished device verification upgrade\");\n        }\n\n        logger.info(\"Finished cross-signing key change post-processing\");\n    }\n\n    /**\n     * Check if a user's cross-signing key is a candidate for upgrading from device\n     * verification.\n     *\n     * @param userId - the user whose cross-signing information is to be checked\n     * @param crossSigningInfo - the cross-signing information to check\n     */\n    private async checkForDeviceVerificationUpgrade(\n        userId: string,\n        crossSigningInfo: CrossSigningInfo,\n    ): Promise<IDeviceVerificationUpgrade | undefined> {\n        // only upgrade if this is the first cross-signing key that we've seen for\n        // them, and if their cross-signing key isn't already verified\n        const trustLevel = this.crossSigningInfo.checkUserTrust(crossSigningInfo);\n        if (crossSigningInfo.firstUse && !trustLevel.isVerified()) {\n            const devices = this.deviceList.getRawStoredDevicesForUser(userId);\n            const deviceIds = await this.checkForValidDeviceSignature(userId, crossSigningInfo.keys.master, devices);\n            if (deviceIds.length) {\n                return {\n                    devices: deviceIds.map((deviceId) => DeviceInfo.fromStorage(devices[deviceId], deviceId)),\n                    crossSigningInfo,\n                };\n            }\n        }\n    }\n\n    /**\n     * Check if the cross-signing key is signed by a verified device.\n     *\n     * @param userId - the user ID whose key is being checked\n     * @param key - the key that is being checked\n     * @param devices - the user's devices.  Should be a map from device ID\n     *     to device info\n     */\n    private async checkForValidDeviceSignature(\n        userId: string,\n        key: ICrossSigningKey,\n        devices: Record<string, IDevice>,\n    ): Promise<string[]> {\n        const deviceIds: string[] = [];\n        if (devices && key.signatures && key.signatures[userId]) {\n            for (const signame of Object.keys(key.signatures[userId])) {\n                const [, deviceId] = signame.split(\":\", 2);\n                if (deviceId in devices && devices[deviceId].verified === DeviceVerification.VERIFIED) {\n                    try {\n                        await olmlib.verifySignature(\n                            this.olmDevice,\n                            key,\n                            userId,\n                            deviceId,\n                            devices[deviceId].keys[signame],\n                        );\n                        deviceIds.push(deviceId);\n                    } catch (e) {}\n                }\n            }\n        }\n        return deviceIds;\n    }\n\n    /**\n     * Get the user's cross-signing key ID.\n     *\n     * @param type - The type of key to get the ID of.  One of\n     *     \"master\", \"self_signing\", or \"user_signing\".  Defaults to \"master\".\n     *\n     * @returns the key ID\n     */\n    public getCrossSigningId(type: string): string | null {\n        return this.crossSigningInfo.getId(type);\n    }\n\n    /**\n     * Get the cross signing information for a given user.\n     *\n     * @param userId - the user ID to get the cross-signing info for.\n     *\n     * @returns the cross signing information for the user.\n     */\n    public getStoredCrossSigningForUser(userId: string): CrossSigningInfo | null {\n        return this.deviceList.getStoredCrossSigningForUser(userId);\n    }\n\n    /**\n     * Check whether a given user is trusted.\n     *\n     * @param userId - The ID of the user to check.\n     *\n     * @returns\n     */\n    public checkUserTrust(userId: string): UserTrustLevel {\n        const userCrossSigning = this.deviceList.getStoredCrossSigningForUser(userId);\n        if (!userCrossSigning) {\n            return new UserTrustLevel(false, false, false);\n        }\n        return this.crossSigningInfo.checkUserTrust(userCrossSigning);\n    }\n\n    /**\n     * Check whether a given device is trusted.\n     *\n     * @param userId - The ID of the user whose devices is to be checked.\n     * @param deviceId - The ID of the device to check\n     *\n     * @returns\n     */\n    public checkDeviceTrust(userId: string, deviceId: string): DeviceTrustLevel {\n        const device = this.deviceList.getStoredDevice(userId, deviceId);\n        return this.checkDeviceInfoTrust(userId, device);\n    }\n\n    /**\n     * Check whether a given deviceinfo is trusted.\n     *\n     * @param userId - The ID of the user whose devices is to be checked.\n     * @param device - The device info object to check\n     *\n     * @returns\n     */\n    public checkDeviceInfoTrust(userId: string, device?: DeviceInfo): DeviceTrustLevel {\n        const trustedLocally = !!device?.isVerified();\n\n        const userCrossSigning = this.deviceList.getStoredCrossSigningForUser(userId);\n        if (device && userCrossSigning) {\n            // The trustCrossSignedDevices only affects trust of other people's cross-signing\n            // signatures\n            const trustCrossSig = this.trustCrossSignedDevices || userId === this.userId;\n            return this.crossSigningInfo.checkDeviceTrust(userCrossSigning, device, trustedLocally, trustCrossSig);\n        } else {\n            return new DeviceTrustLevel(false, false, trustedLocally, false);\n        }\n    }\n\n    /**\n     * Check whether one of our own devices is cross-signed by our\n     * user's stored keys, regardless of whether we trust those keys yet.\n     *\n     * @param deviceId - The ID of the device to check\n     *\n     * @returns true if the device is cross-signed\n     */\n    public checkIfOwnDeviceCrossSigned(deviceId: string): boolean {\n        const device = this.deviceList.getStoredDevice(this.userId, deviceId);\n        if (!device) return false;\n        const userCrossSigning = this.deviceList.getStoredCrossSigningForUser(this.userId);\n        return (\n            userCrossSigning?.checkDeviceTrust(userCrossSigning, device, false, true).isCrossSigningVerified() ?? false\n        );\n    }\n\n    /*\n     * Event handler for DeviceList's userNewDevices event\n     */\n    private onDeviceListUserCrossSigningUpdated = async (userId: string): Promise<void> => {\n        if (userId === this.userId) {\n            // An update to our own cross-signing key.\n            // Get the new key first:\n            const newCrossSigning = this.deviceList.getStoredCrossSigningForUser(userId);\n            const seenPubkey = newCrossSigning ? newCrossSigning.getId() : null;\n            const currentPubkey = this.crossSigningInfo.getId();\n            const changed = currentPubkey !== seenPubkey;\n\n            if (currentPubkey && seenPubkey && !changed) {\n                // If it's not changed, just make sure everything is up to date\n                await this.checkOwnCrossSigningTrust();\n            } else {\n                // We'll now be in a state where cross-signing on the account is not trusted\n                // because our locally stored cross-signing keys will not match the ones\n                // on the server for our account. So we clear our own stored cross-signing keys,\n                // effectively disabling cross-signing until the user gets verified by the device\n                // that reset the keys\n                this.storeTrustedSelfKeys(null);\n                // emit cross-signing has been disabled\n                this.emit(CryptoEvent.KeysChanged, {});\n                // as the trust for our own user has changed,\n                // also emit an event for this\n                this.emit(CryptoEvent.UserTrustStatusChanged, this.userId, this.checkUserTrust(userId));\n            }\n        } else {\n            await this.checkDeviceVerifications(userId);\n\n            // Update verified before latch using the current state and save the new\n            // latch value in the device list store.\n            const crossSigning = this.deviceList.getStoredCrossSigningForUser(userId);\n            if (crossSigning) {\n                crossSigning.updateCrossSigningVerifiedBefore(this.checkUserTrust(userId).isCrossSigningVerified());\n                this.deviceList.setRawStoredCrossSigningForUser(userId, crossSigning.toStorage());\n            }\n\n            this.emit(CryptoEvent.UserTrustStatusChanged, userId, this.checkUserTrust(userId));\n        }\n    };\n\n    /**\n     * Check the copy of our cross-signing key that we have in the device list and\n     * see if we can get the private key. If so, mark it as trusted.\n     */\n    public async checkOwnCrossSigningTrust({\n        allowPrivateKeyRequests = false,\n    }: ICheckOwnCrossSigningTrustOpts = {}): Promise<void> {\n        const userId = this.userId;\n\n        // Before proceeding, ensure our cross-signing public keys have been\n        // downloaded via the device list.\n        await this.downloadKeys([this.userId]);\n\n        // Also check which private keys are locally cached.\n        const crossSigningPrivateKeys = await this.crossSigningInfo.getCrossSigningKeysFromCache();\n\n        // If we see an update to our own master key, check it against the master\n        // key we have and, if it matches, mark it as verified\n\n        // First, get the new cross-signing info\n        const newCrossSigning = this.deviceList.getStoredCrossSigningForUser(userId);\n        if (!newCrossSigning) {\n            logger.error(\n                \"Got cross-signing update event for user \" + userId + \" but no new cross-signing information found!\",\n            );\n            return;\n        }\n\n        const seenPubkey = newCrossSigning.getId()!;\n        const masterChanged = this.crossSigningInfo.getId() !== seenPubkey;\n        const masterExistsNotLocallyCached = newCrossSigning.getId() && !crossSigningPrivateKeys.has(\"master\");\n        if (masterChanged) {\n            logger.info(\"Got new master public key\", seenPubkey);\n        }\n        if (allowPrivateKeyRequests && (masterChanged || masterExistsNotLocallyCached)) {\n            logger.info(\"Attempting to retrieve cross-signing master private key\");\n            let signing: PkSigning | null = null;\n            // It's important for control flow that we leave any errors alone for\n            // higher levels to handle so that e.g. cancelling access properly\n            // aborts any larger operation as well.\n            try {\n                const ret = await this.crossSigningInfo.getCrossSigningKey(\"master\", seenPubkey);\n                signing = ret[1];\n                logger.info(\"Got cross-signing master private key\");\n            } finally {\n                signing?.free();\n            }\n        }\n\n        const oldSelfSigningId = this.crossSigningInfo.getId(\"self_signing\");\n        const oldUserSigningId = this.crossSigningInfo.getId(\"user_signing\");\n\n        // Update the version of our keys in our cross-signing object and the local store\n        this.storeTrustedSelfKeys(newCrossSigning.keys);\n\n        const selfSigningChanged = oldSelfSigningId !== newCrossSigning.getId(\"self_signing\");\n        const userSigningChanged = oldUserSigningId !== newCrossSigning.getId(\"user_signing\");\n\n        const selfSigningExistsNotLocallyCached =\n            newCrossSigning.getId(\"self_signing\") && !crossSigningPrivateKeys.has(\"self_signing\");\n        const userSigningExistsNotLocallyCached =\n            newCrossSigning.getId(\"user_signing\") && !crossSigningPrivateKeys.has(\"user_signing\");\n\n        const keySignatures: Record<string, ISignedKey> = {};\n\n        if (selfSigningChanged) {\n            logger.info(\"Got new self-signing key\", newCrossSigning.getId(\"self_signing\"));\n        }\n        if (allowPrivateKeyRequests && (selfSigningChanged || selfSigningExistsNotLocallyCached)) {\n            logger.info(\"Attempting to retrieve cross-signing self-signing private key\");\n            let signing: PkSigning | null = null;\n            try {\n                const ret = await this.crossSigningInfo.getCrossSigningKey(\n                    \"self_signing\",\n                    newCrossSigning.getId(\"self_signing\")!,\n                );\n                signing = ret[1];\n                logger.info(\"Got cross-signing self-signing private key\");\n            } finally {\n                signing?.free();\n            }\n\n            const device = this.deviceList.getStoredDevice(this.userId, this.deviceId)!;\n            const signedDevice = await this.crossSigningInfo.signDevice(this.userId, device);\n            keySignatures[this.deviceId] = signedDevice!;\n        }\n        if (userSigningChanged) {\n            logger.info(\"Got new user-signing key\", newCrossSigning.getId(\"user_signing\"));\n        }\n        if (allowPrivateKeyRequests && (userSigningChanged || userSigningExistsNotLocallyCached)) {\n            logger.info(\"Attempting to retrieve cross-signing user-signing private key\");\n            let signing: PkSigning | null = null;\n            try {\n                const ret = await this.crossSigningInfo.getCrossSigningKey(\n                    \"user_signing\",\n                    newCrossSigning.getId(\"user_signing\")!,\n                );\n                signing = ret[1];\n                logger.info(\"Got cross-signing user-signing private key\");\n            } finally {\n                signing?.free();\n            }\n        }\n\n        if (masterChanged) {\n            const masterKey = this.crossSigningInfo.keys.master;\n            await this.signObject(masterKey);\n            const deviceSig = masterKey.signatures![this.userId][\"ed25519:\" + this.deviceId];\n            // Include only the _new_ device signature in the upload.\n            // We may have existing signatures from deleted devices, which will cause\n            // the entire upload to fail.\n            keySignatures[this.crossSigningInfo.getId()!] = Object.assign({} as ISignedKey, masterKey, {\n                signatures: {\n                    [this.userId]: {\n                        [\"ed25519:\" + this.deviceId]: deviceSig,\n                    },\n                },\n            });\n        }\n\n        const keysToUpload = Object.keys(keySignatures);\n        if (keysToUpload.length) {\n            const upload = ({ shouldEmit = false }): Promise<void> => {\n                logger.info(`Starting background key sig upload for ${keysToUpload}`);\n                return this.baseApis\n                    .uploadKeySignatures({ [this.userId]: keySignatures })\n                    .then((response) => {\n                        const { failures } = response || {};\n                        logger.info(`Finished background key sig upload for ${keysToUpload}`);\n                        if (Object.keys(failures || []).length > 0) {\n                            if (shouldEmit) {\n                                this.baseApis.emit(\n                                    CryptoEvent.KeySignatureUploadFailure,\n                                    failures,\n                                    \"checkOwnCrossSigningTrust\",\n                                    upload,\n                                );\n                            }\n                            throw new KeySignatureUploadError(\"Key upload failed\", { failures });\n                        }\n                    })\n                    .catch((e) => {\n                        logger.error(`Error during background key sig upload for ${keysToUpload}`, e);\n                    });\n            };\n            upload({ shouldEmit: true });\n        }\n\n        this.emit(CryptoEvent.UserTrustStatusChanged, userId, this.checkUserTrust(userId));\n\n        if (masterChanged) {\n            this.emit(CryptoEvent.KeysChanged, {});\n            await this.afterCrossSigningLocalKeyChange();\n        }\n\n        // Now we may be able to trust our key backup\n        await this.backupManager.checkKeyBackup();\n        // FIXME: if we previously trusted the backup, should we automatically sign\n        // the backup with the new key (if not already signed)?\n    }\n\n    /**\n     * Store a set of keys as our own, trusted, cross-signing keys.\n     *\n     * @param keys - The new trusted set of keys\n     */\n    private async storeTrustedSelfKeys(keys: Record<string, ICrossSigningKey> | null): Promise<void> {\n        if (keys) {\n            this.crossSigningInfo.setKeys(keys);\n        } else {\n            this.crossSigningInfo.clearKeys();\n        }\n        await this.cryptoStore.doTxn(\"readwrite\", [IndexedDBCryptoStore.STORE_ACCOUNT], (txn) => {\n            this.cryptoStore.storeCrossSigningKeys(txn, this.crossSigningInfo.keys);\n        });\n    }\n\n    /**\n     * Check if the master key is signed by a verified device, and if so, prompt\n     * the application to mark it as verified.\n     *\n     * @param userId - the user ID whose key should be checked\n     */\n    private async checkDeviceVerifications(userId: string): Promise<void> {\n        const shouldUpgradeCb = this.baseApis.cryptoCallbacks.shouldUpgradeDeviceVerifications;\n        if (!shouldUpgradeCb) {\n            // Upgrading skipped when callback is not present.\n            return;\n        }\n        logger.info(`Starting device verification upgrade for ${userId}`);\n        if (this.crossSigningInfo.keys.user_signing) {\n            const crossSigningInfo = this.deviceList.getStoredCrossSigningForUser(userId);\n            if (crossSigningInfo) {\n                const upgradeInfo = await this.checkForDeviceVerificationUpgrade(userId, crossSigningInfo);\n                if (upgradeInfo) {\n                    const usersToUpgrade = await shouldUpgradeCb({\n                        users: {\n                            [userId]: upgradeInfo,\n                        },\n                    });\n                    if (usersToUpgrade.includes(userId)) {\n                        await this.baseApis.setDeviceVerified(userId, crossSigningInfo.getId()!);\n                    }\n                }\n            }\n        }\n        logger.info(`Finished device verification upgrade for ${userId}`);\n    }\n\n    /**\n     */\n    public enableLazyLoading(): void {\n        this.lazyLoadMembers = true;\n    }\n\n    /**\n     * Tell the crypto module to register for MatrixClient events which it needs to\n     * listen for\n     *\n     * @param eventEmitter - event source where we can register\n     *    for event notifications\n     */\n    public registerEventHandlers(\n        eventEmitter: TypedEventEmitter<\n            RoomMemberEvent.Membership | ClientEvent.ToDeviceEvent | RoomEvent.Timeline | MatrixEventEvent.Decrypted,\n            any\n        >,\n    ): void {\n        eventEmitter.on(RoomMemberEvent.Membership, this.onMembership);\n        eventEmitter.on(ClientEvent.ToDeviceEvent, this.onToDeviceEvent);\n        eventEmitter.on(RoomEvent.Timeline, this.onTimelineEvent);\n        eventEmitter.on(MatrixEventEvent.Decrypted, this.onTimelineEvent);\n    }\n\n    /**\n     * @deprecated this does nothing and will be removed in a future version\n     */\n    public start(): void {\n        logger.warn(\"MatrixClient.crypto.start() is deprecated\");\n    }\n\n    /** Stop background processes related to crypto */\n    public stop(): void {\n        this.outgoingRoomKeyRequestManager.stop();\n        this.deviceList.stop();\n        this.dehydrationManager.stop();\n    }\n\n    /**\n     * Get the Ed25519 key for this device\n     *\n     * @returns base64-encoded ed25519 key.\n     */\n    public getDeviceEd25519Key(): string | null {\n        return this.olmDevice.deviceEd25519Key;\n    }\n\n    /**\n     * Get the Curve25519 key for this device\n     *\n     * @returns base64-encoded curve25519 key.\n     */\n    public getDeviceCurve25519Key(): string | null {\n        return this.olmDevice.deviceCurve25519Key;\n    }\n\n    /**\n     * Set the global override for whether the client should ever send encrypted\n     * messages to unverified devices.  This provides the default for rooms which\n     * do not specify a value.\n     *\n     * @param value - whether to blacklist all unverified devices by default\n     *\n     * @deprecated For external code, use {@link MatrixClient#setGlobalBlacklistUnverifiedDevices}. For\n     *   internal code, set {@link MatrixClient#globalBlacklistUnverifiedDevices} directly.\n     */\n    public setGlobalBlacklistUnverifiedDevices(value: boolean): void {\n        this.globalBlacklistUnverifiedDevices = value;\n    }\n\n    /**\n     * @returns whether to blacklist all unverified devices by default\n     *\n     * @deprecated For external code, use {@link MatrixClient#getGlobalBlacklistUnverifiedDevices}. For\n     *   internal code, reference {@link MatrixClient#globalBlacklistUnverifiedDevices} directly.\n     */\n    public getGlobalBlacklistUnverifiedDevices(): boolean {\n        return this.globalBlacklistUnverifiedDevices;\n    }\n\n    /**\n     * Upload the device keys to the homeserver.\n     * @returns A promise that will resolve when the keys are uploaded.\n     */\n    public uploadDeviceKeys(): Promise<IKeysUploadResponse> {\n        const deviceKeys = {\n            algorithms: this.supportedAlgorithms,\n            device_id: this.deviceId,\n            keys: this.deviceKeys,\n            user_id: this.userId,\n        };\n\n        return this.signObject(deviceKeys).then(() => {\n            return this.baseApis.uploadKeysRequest({\n                device_keys: deviceKeys as Required<IDeviceKeys>,\n            });\n        });\n    }\n\n    /**\n     * Stores the current one_time_key count which will be handled later (in a call of\n     * onSyncCompleted). The count is e.g. coming from a /sync response.\n     *\n     * @param currentCount - The current count of one_time_keys to be stored\n     */\n    public updateOneTimeKeyCount(currentCount: number): void {\n        if (isFinite(currentCount)) {\n            this.oneTimeKeyCount = currentCount;\n        } else {\n            throw new TypeError(\"Parameter for updateOneTimeKeyCount has to be a number\");\n        }\n    }\n\n    public setNeedsNewFallback(needsNewFallback: boolean): void {\n        this.needsNewFallback = needsNewFallback;\n    }\n\n    public getNeedsNewFallback(): boolean {\n        return !!this.needsNewFallback;\n    }\n\n    // check if it's time to upload one-time keys, and do so if so.\n    private maybeUploadOneTimeKeys(): void {\n        // frequency with which to check & upload one-time keys\n        const uploadPeriod = 1000 * 60; // one minute\n\n        // max number of keys to upload at once\n        // Creating keys can be an expensive operation so we limit the\n        // number we generate in one go to avoid blocking the application\n        // for too long.\n        const maxKeysPerCycle = 5;\n\n        if (this.oneTimeKeyCheckInProgress) {\n            return;\n        }\n\n        const now = Date.now();\n        if (this.lastOneTimeKeyCheck !== null && now - this.lastOneTimeKeyCheck < uploadPeriod) {\n            // we've done a key upload recently.\n            return;\n        }\n\n        this.lastOneTimeKeyCheck = now;\n\n        // We need to keep a pool of one time public keys on the server so that\n        // other devices can start conversations with us. But we can only store\n        // a finite number of private keys in the olm Account object.\n        // To complicate things further then can be a delay between a device\n        // claiming a public one time key from the server and it sending us a\n        // message. We need to keep the corresponding private key locally until\n        // we receive the message.\n        // But that message might never arrive leaving us stuck with duff\n        // private keys clogging up our local storage.\n        // So we need some kind of engineering compromise to balance all of\n        // these factors.\n\n        // Check how many keys we can store in the Account object.\n        const maxOneTimeKeys = this.olmDevice.maxNumberOfOneTimeKeys();\n        // Try to keep at most half that number on the server. This leaves the\n        // rest of the slots free to hold keys that have been claimed from the\n        // server but we haven't received a message for.\n        // If we run out of slots when generating new keys then olm will\n        // discard the oldest private keys first. This will eventually clean\n        // out stale private keys that won't receive a message.\n        const keyLimit = Math.floor(maxOneTimeKeys / 2);\n\n        const uploadLoop = async (keyCount: number): Promise<void> => {\n            while (keyLimit > keyCount || this.getNeedsNewFallback()) {\n                // Ask olm to generate new one time keys, then upload them to synapse.\n                if (keyLimit > keyCount) {\n                    logger.info(\"generating oneTimeKeys\");\n                    const keysThisLoop = Math.min(keyLimit - keyCount, maxKeysPerCycle);\n                    await this.olmDevice.generateOneTimeKeys(keysThisLoop);\n                }\n\n                if (this.getNeedsNewFallback()) {\n                    const fallbackKeys = await this.olmDevice.getFallbackKey();\n                    // if fallbackKeys is non-empty, we've already generated a\n                    // fallback key, but it hasn't been published yet, so we\n                    // can use that instead of generating a new one\n                    if (!fallbackKeys.curve25519 || Object.keys(fallbackKeys.curve25519).length == 0) {\n                        logger.info(\"generating fallback key\");\n                        if (this.fallbackCleanup) {\n                            // cancel any pending fallback cleanup because generating\n                            // a new fallback key will already drop the old fallback\n                            // that would have been dropped, and we don't want to kill\n                            // the current key\n                            clearTimeout(this.fallbackCleanup);\n                            delete this.fallbackCleanup;\n                        }\n                        await this.olmDevice.generateFallbackKey();\n                    }\n                }\n\n                logger.info(\"calling uploadOneTimeKeys\");\n                const res = await this.uploadOneTimeKeys();\n                if (res.one_time_key_counts && res.one_time_key_counts.signed_curve25519) {\n                    // if the response contains a more up to date value use this\n                    // for the next loop\n                    keyCount = res.one_time_key_counts.signed_curve25519;\n                } else {\n                    throw new Error(\n                        \"response for uploading keys does not contain \" + \"one_time_key_counts.signed_curve25519\",\n                    );\n                }\n            }\n        };\n\n        this.oneTimeKeyCheckInProgress = true;\n        Promise.resolve()\n            .then(() => {\n                if (this.oneTimeKeyCount !== undefined) {\n                    // We already have the current one_time_key count from a /sync response.\n                    // Use this value instead of asking the server for the current key count.\n                    return Promise.resolve(this.oneTimeKeyCount);\n                }\n                // ask the server how many keys we have\n                return this.baseApis.uploadKeysRequest({}).then((res) => {\n                    return res.one_time_key_counts.signed_curve25519 || 0;\n                });\n            })\n            .then((keyCount) => {\n                // Start the uploadLoop with the current keyCount. The function checks if\n                // we need to upload new keys or not.\n                // If there are too many keys on the server then we don't need to\n                // create any more keys.\n                return uploadLoop(keyCount);\n            })\n            .catch((e) => {\n                logger.error(\"Error uploading one-time keys\", e.stack || e);\n            })\n            .finally(() => {\n                // reset oneTimeKeyCount to prevent start uploading based on old data.\n                // it will be set again on the next /sync-response\n                this.oneTimeKeyCount = undefined;\n                this.oneTimeKeyCheckInProgress = false;\n            });\n    }\n\n    // returns a promise which resolves to the response\n    private async uploadOneTimeKeys(): Promise<IKeysUploadResponse> {\n        const promises: Promise<unknown>[] = [];\n\n        let fallbackJson: Record<string, IOneTimeKey> | undefined;\n        if (this.getNeedsNewFallback()) {\n            fallbackJson = {};\n            const fallbackKeys = await this.olmDevice.getFallbackKey();\n            for (const [keyId, key] of Object.entries(fallbackKeys.curve25519)) {\n                const k = { key, fallback: true };\n                fallbackJson[\"signed_curve25519:\" + keyId] = k;\n                promises.push(this.signObject(k));\n            }\n            this.setNeedsNewFallback(false);\n        }\n\n        const oneTimeKeys = await this.olmDevice.getOneTimeKeys();\n        const oneTimeJson: Record<string, { key: string }> = {};\n\n        for (const keyId in oneTimeKeys.curve25519) {\n            if (oneTimeKeys.curve25519.hasOwnProperty(keyId)) {\n                const k = {\n                    key: oneTimeKeys.curve25519[keyId],\n                };\n                oneTimeJson[\"signed_curve25519:\" + keyId] = k;\n                promises.push(this.signObject(k));\n            }\n        }\n\n        await Promise.all(promises);\n\n        const requestBody: Record<string, any> = {\n            one_time_keys: oneTimeJson,\n        };\n\n        if (fallbackJson) {\n            requestBody[\"org.matrix.msc2732.fallback_keys\"] = fallbackJson;\n            requestBody[\"fallback_keys\"] = fallbackJson;\n        }\n\n        const res = await this.baseApis.uploadKeysRequest(requestBody);\n\n        if (fallbackJson) {\n            this.fallbackCleanup = setTimeout(() => {\n                delete this.fallbackCleanup;\n                this.olmDevice.forgetOldFallbackKey();\n            }, 60 * 60 * 1000);\n        }\n\n        await this.olmDevice.markKeysAsPublished();\n        return res;\n    }\n\n    /**\n     * Download the keys for a list of users and stores the keys in the session\n     * store.\n     * @param userIds - The users to fetch.\n     * @param forceDownload - Always download the keys even if cached.\n     *\n     * @returns A promise which resolves to a map `userId->deviceId->{@link DeviceInfo}`.\n     */\n    public downloadKeys(userIds: string[], forceDownload?: boolean): Promise<DeviceInfoMap> {\n        return this.deviceList.downloadKeys(userIds, !!forceDownload);\n    }\n\n    /**\n     * Get the stored device keys for a user id\n     *\n     * @param userId - the user to list keys for.\n     *\n     * @returns list of devices, or null if we haven't\n     * managed to get a list of devices for this user yet.\n     */\n    public getStoredDevicesForUser(userId: string): Array<DeviceInfo> | null {\n        return this.deviceList.getStoredDevicesForUser(userId);\n    }\n\n    /**\n     * Get the stored keys for a single device\n     *\n     *\n     * @returns device, or undefined\n     * if we don't know about this device\n     */\n    public getStoredDevice(userId: string, deviceId: string): DeviceInfo | undefined {\n        return this.deviceList.getStoredDevice(userId, deviceId);\n    }\n\n    /**\n     * Save the device list, if necessary\n     *\n     * @param delay - Time in ms before which the save actually happens.\n     *     By default, the save is delayed for a short period in order to batch\n     *     multiple writes, but this behaviour can be disabled by passing 0.\n     *\n     * @returns true if the data was saved, false if\n     *     it was not (eg. because no changes were pending). The promise\n     *     will only resolve once the data is saved, so may take some time\n     *     to resolve.\n     */\n    public saveDeviceList(delay: number): Promise<boolean> {\n        return this.deviceList.saveIfDirty(delay);\n    }\n\n    /**\n     * Update the blocked/verified state of the given device\n     *\n     * @param userId - owner of the device\n     * @param deviceId - unique identifier for the device or user's\n     * cross-signing public key ID.\n     *\n     * @param verified - whether to mark the device as verified. Null to\n     *     leave unchanged.\n     *\n     * @param blocked - whether to mark the device as blocked. Null to\n     *      leave unchanged.\n     *\n     * @param known - whether to mark that the user has been made aware of\n     *      the existence of this device. Null to leave unchanged\n     *\n     * @param keys - The list of keys that was present\n     * during the device verification. This will be double checked with the list\n     * of keys the given device has currently.\n     *\n     * @returns updated DeviceInfo\n     */\n    public async setDeviceVerification(\n        userId: string,\n        deviceId: string,\n        verified: boolean | null = null,\n        blocked: boolean | null = null,\n        known: boolean | null = null,\n        keys?: Record<string, string>,\n    ): Promise<DeviceInfo | CrossSigningInfo> {\n        // Check if the 'device' is actually a cross signing key\n        // The js-sdk's verification treats cross-signing keys as devices\n        // and so uses this method to mark them verified.\n        const xsk = this.deviceList.getStoredCrossSigningForUser(userId);\n        if (xsk && xsk.getId() === deviceId) {\n            if (blocked !== null || known !== null) {\n                throw new Error(\"Cannot set blocked or known for a cross-signing key\");\n            }\n            if (!verified) {\n                throw new Error(\"Cannot set a cross-signing key as unverified\");\n            }\n            const gotKeyId = keys ? Object.values(keys)[0] : null;\n            if (keys && (Object.values(keys).length !== 1 || gotKeyId !== xsk.getId())) {\n                throw new Error(`Key did not match expected value: expected ${xsk.getId()}, got ${gotKeyId}`);\n            }\n\n            if (!this.crossSigningInfo.getId() && userId === this.crossSigningInfo.userId) {\n                this.storeTrustedSelfKeys(xsk.keys);\n                // This will cause our own user trust to change, so emit the event\n                this.emit(CryptoEvent.UserTrustStatusChanged, this.userId, this.checkUserTrust(userId));\n            }\n\n            // Now sign the master key with our user signing key (unless it's ourself)\n            if (userId !== this.userId) {\n                logger.info(\"Master key \" + xsk.getId() + \" for \" + userId + \" marked verified. Signing...\");\n                const device = await this.crossSigningInfo.signUser(xsk);\n                if (device) {\n                    const upload = async ({ shouldEmit = false }): Promise<void> => {\n                        logger.info(\"Uploading signature for \" + userId + \"...\");\n                        const response = await this.baseApis.uploadKeySignatures({\n                            [userId]: {\n                                [deviceId]: device,\n                            },\n                        });\n                        const { failures } = response || {};\n                        if (Object.keys(failures || []).length > 0) {\n                            if (shouldEmit) {\n                                this.baseApis.emit(\n                                    CryptoEvent.KeySignatureUploadFailure,\n                                    failures,\n                                    \"setDeviceVerification\",\n                                    upload,\n                                );\n                            }\n                            /* Throwing here causes the process to be cancelled and the other\n                             * user to be notified */\n                            throw new KeySignatureUploadError(\"Key upload failed\", { failures });\n                        }\n                    };\n                    await upload({ shouldEmit: true });\n\n                    // This will emit events when it comes back down the sync\n                    // (we could do local echo to speed things up)\n                }\n                return device as any; // TODO types\n            } else {\n                return xsk;\n            }\n        }\n\n        const devices = this.deviceList.getRawStoredDevicesForUser(userId);\n        if (!devices || !devices[deviceId]) {\n            throw new Error(\"Unknown device \" + userId + \":\" + deviceId);\n        }\n\n        const dev = devices[deviceId];\n        let verificationStatus = dev.verified;\n\n        if (verified) {\n            if (keys) {\n                for (const [keyId, key] of Object.entries(keys)) {\n                    if (dev.keys[keyId] !== key) {\n                        throw new Error(`Key did not match expected value: expected ${key}, got ${dev.keys[keyId]}`);\n                    }\n                }\n            }\n            verificationStatus = DeviceVerification.VERIFIED;\n        } else if (verified !== null && verificationStatus == DeviceVerification.VERIFIED) {\n            verificationStatus = DeviceVerification.UNVERIFIED;\n        }\n\n        if (blocked) {\n            verificationStatus = DeviceVerification.BLOCKED;\n        } else if (blocked !== null && verificationStatus == DeviceVerification.BLOCKED) {\n            verificationStatus = DeviceVerification.UNVERIFIED;\n        }\n\n        let knownStatus = dev.known;\n        if (known !== null) {\n            knownStatus = known;\n        }\n\n        if (dev.verified !== verificationStatus || dev.known !== knownStatus) {\n            dev.verified = verificationStatus;\n            dev.known = knownStatus;\n            this.deviceList.storeDevicesForUser(userId, devices);\n            this.deviceList.saveIfDirty();\n        }\n\n        // do cross-signing\n        if (verified && userId === this.userId) {\n            logger.info(\"Own device \" + deviceId + \" marked verified: signing\");\n\n            // Signing only needed if other device not already signed\n            let device: ISignedKey | undefined;\n            const deviceTrust = this.checkDeviceTrust(userId, deviceId);\n            if (deviceTrust.isCrossSigningVerified()) {\n                logger.log(`Own device ${deviceId} already cross-signing verified`);\n            } else {\n                device = (await this.crossSigningInfo.signDevice(userId, DeviceInfo.fromStorage(dev, deviceId)))!;\n            }\n\n            if (device) {\n                const upload = async ({ shouldEmit = false }): Promise<void> => {\n                    logger.info(\"Uploading signature for \" + deviceId);\n                    const response = await this.baseApis.uploadKeySignatures({\n                        [userId]: {\n                            [deviceId]: device!,\n                        },\n                    });\n                    const { failures } = response || {};\n                    if (Object.keys(failures || []).length > 0) {\n                        if (shouldEmit) {\n                            this.baseApis.emit(\n                                CryptoEvent.KeySignatureUploadFailure,\n                                failures,\n                                \"setDeviceVerification\",\n                                upload, // continuation\n                            );\n                        }\n                        throw new KeySignatureUploadError(\"Key upload failed\", { failures });\n                    }\n                };\n                await upload({ shouldEmit: true });\n                // XXX: we'll need to wait for the device list to be updated\n            }\n\n            // redo key requests after verification\n            this.cancelAndResendAllOutgoingKeyRequests();\n        }\n\n        const deviceObj = DeviceInfo.fromStorage(dev, deviceId);\n        this.emit(CryptoEvent.DeviceVerificationChanged, userId, deviceId, deviceObj);\n        return deviceObj;\n    }\n\n    public findVerificationRequestDMInProgress(roomId: string): VerificationRequest | undefined {\n        return this.inRoomVerificationRequests.findRequestInProgress(roomId);\n    }\n\n    public getVerificationRequestsToDeviceInProgress(userId: string): VerificationRequest[] {\n        return this.toDeviceVerificationRequests.getRequestsInProgress(userId);\n    }\n\n    public requestVerificationDM(userId: string, roomId: string): Promise<VerificationRequest> {\n        const existingRequest = this.inRoomVerificationRequests.findRequestInProgress(roomId);\n        if (existingRequest) {\n            return Promise.resolve(existingRequest);\n        }\n        const channel = new InRoomChannel(this.baseApis, roomId, userId);\n        return this.requestVerificationWithChannel(userId, channel, this.inRoomVerificationRequests);\n    }\n\n    public requestVerification(userId: string, devices?: string[]): Promise<VerificationRequest> {\n        if (!devices) {\n            devices = Object.keys(this.deviceList.getRawStoredDevicesForUser(userId));\n        }\n        const existingRequest = this.toDeviceVerificationRequests.findRequestInProgress(userId, devices);\n        if (existingRequest) {\n            return Promise.resolve(existingRequest);\n        }\n        const channel = new ToDeviceChannel(this.baseApis, userId, devices, ToDeviceChannel.makeTransactionId());\n        return this.requestVerificationWithChannel(userId, channel, this.toDeviceVerificationRequests);\n    }\n\n    private async requestVerificationWithChannel(\n        userId: string,\n        channel: IVerificationChannel,\n        requestsMap: IRequestsMap,\n    ): Promise<VerificationRequest> {\n        let request = new VerificationRequest(channel, this.verificationMethods, this.baseApis);\n        // if transaction id is already known, add request\n        if (channel.transactionId) {\n            requestsMap.setRequestByChannel(channel, request);\n        }\n        await request.sendRequest();\n        // don't replace the request created by a racing remote echo\n        const racingRequest = requestsMap.getRequestByChannel(channel);\n        if (racingRequest) {\n            request = racingRequest;\n        } else {\n            logger.log(\n                `Crypto: adding new request to ` + `requestsByTxnId with id ${channel.transactionId} ${channel.roomId}`,\n            );\n            requestsMap.setRequestByChannel(channel, request);\n        }\n        return request;\n    }\n\n    public beginKeyVerification(\n        method: string,\n        userId: string,\n        deviceId: string,\n        transactionId: string | null = null,\n    ): VerificationBase<any, any> {\n        let request: Request | undefined;\n        if (transactionId) {\n            request = this.toDeviceVerificationRequests.getRequestBySenderAndTxnId(userId, transactionId);\n            if (!request) {\n                throw new Error(`No request found for user ${userId} with ` + `transactionId ${transactionId}`);\n            }\n        } else {\n            transactionId = ToDeviceChannel.makeTransactionId();\n            const channel = new ToDeviceChannel(this.baseApis, userId, [deviceId], transactionId, deviceId);\n            request = new VerificationRequest(channel, this.verificationMethods, this.baseApis);\n            this.toDeviceVerificationRequests.setRequestBySenderAndTxnId(userId, transactionId, request);\n        }\n        return request.beginKeyVerification(method, { userId, deviceId });\n    }\n\n    public async legacyDeviceVerification(\n        userId: string,\n        deviceId: string,\n        method: VerificationMethod,\n    ): Promise<VerificationRequest> {\n        const transactionId = ToDeviceChannel.makeTransactionId();\n        const channel = new ToDeviceChannel(this.baseApis, userId, [deviceId], transactionId, deviceId);\n        const request = new VerificationRequest(channel, this.verificationMethods, this.baseApis);\n        this.toDeviceVerificationRequests.setRequestBySenderAndTxnId(userId, transactionId, request);\n        const verifier = request.beginKeyVerification(method, { userId, deviceId });\n        // either reject by an error from verify() while sending .start\n        // or resolve when the request receives the\n        // local (fake remote) echo for sending the .start event\n        await Promise.race([verifier.verify(), request.waitFor((r) => r.started)]);\n        return request;\n    }\n\n    /**\n     * Get information on the active olm sessions with a user\n     * <p>\n     * Returns a map from device id to an object with keys 'deviceIdKey' (the\n     * device's curve25519 identity key) and 'sessions' (an array of objects in the\n     * same format as that returned by\n     * {@link OlmDevice#getSessionInfoForDevice}).\n     * <p>\n     * This method is provided for debugging purposes.\n     *\n     * @param userId - id of user to inspect\n     */\n    public async getOlmSessionsForUser(userId: string): Promise<Record<string, IUserOlmSession>> {\n        const devices = this.getStoredDevicesForUser(userId) || [];\n        const result: { [deviceId: string]: IUserOlmSession } = {};\n        for (const device of devices) {\n            const deviceKey = device.getIdentityKey();\n            const sessions = await this.olmDevice.getSessionInfoForDevice(deviceKey);\n\n            result[device.deviceId] = {\n                deviceIdKey: deviceKey,\n                sessions: sessions,\n            };\n        }\n        return result;\n    }\n\n    /**\n     * Get the device which sent an event\n     *\n     * @param event - event to be checked\n     */\n    public getEventSenderDeviceInfo(event: MatrixEvent): DeviceInfo | null {\n        const senderKey = event.getSenderKey();\n        const algorithm = event.getWireContent().algorithm;\n\n        if (!senderKey || !algorithm) {\n            return null;\n        }\n\n        if (event.isKeySourceUntrusted()) {\n            // we got the key for this event from a source that we consider untrusted\n            return null;\n        }\n\n        // senderKey is the Curve25519 identity key of the device which the event\n        // was sent from. In the case of Megolm, it's actually the Curve25519\n        // identity key of the device which set up the Megolm session.\n\n        const device = this.deviceList.getDeviceByIdentityKey(algorithm, senderKey);\n\n        if (device === null) {\n            // we haven't downloaded the details of this device yet.\n            return null;\n        }\n\n        // so far so good, but now we need to check that the sender of this event\n        // hadn't advertised someone else's Curve25519 key as their own. We do that\n        // by checking the Ed25519 claimed by the event (or, in the case of megolm,\n        // the event which set up the megolm session), to check that it matches the\n        // fingerprint of the purported sending device.\n        //\n        // (see https://github.com/vector-im/vector-web/issues/2215)\n\n        const claimedKey = event.getClaimedEd25519Key();\n        if (!claimedKey) {\n            logger.warn(\"Event \" + event.getId() + \" claims no ed25519 key: \" + \"cannot verify sending device\");\n            return null;\n        }\n\n        if (claimedKey !== device.getFingerprint()) {\n            logger.warn(\n                \"Event \" +\n                    event.getId() +\n                    \" claims ed25519 key \" +\n                    claimedKey +\n                    \" but sender device has key \" +\n                    device.getFingerprint(),\n            );\n            return null;\n        }\n\n        return device;\n    }\n\n    /**\n     * Get information about the encryption of an event\n     *\n     * @param event - event to be checked\n     *\n     * @returns An object with the fields:\n     *    - encrypted: whether the event is encrypted (if not encrypted, some of the\n     *      other properties may not be set)\n     *    - senderKey: the sender's key\n     *    - algorithm: the algorithm used to encrypt the event\n     *    - authenticated: whether we can be sure that the owner of the senderKey\n     *      sent the event\n     *    - sender: the sender's device information, if available\n     *    - mismatchedSender: if the event's ed25519 and curve25519 keys don't match\n     *      (only meaningful if `sender` is set)\n     */\n    public getEventEncryptionInfo(event: MatrixEvent): IEncryptedEventInfo {\n        const ret: Partial<IEncryptedEventInfo> = {};\n\n        ret.senderKey = event.getSenderKey() ?? undefined;\n        ret.algorithm = event.getWireContent().algorithm;\n\n        if (!ret.senderKey || !ret.algorithm) {\n            ret.encrypted = false;\n            return ret as IEncryptedEventInfo;\n        }\n        ret.encrypted = true;\n\n        if (event.isKeySourceUntrusted()) {\n            // we got the key this event from somewhere else\n            // TODO: check if we can trust the forwarders.\n            ret.authenticated = false;\n        } else {\n            ret.authenticated = true;\n        }\n\n        // senderKey is the Curve25519 identity key of the device which the event\n        // was sent from. In the case of Megolm, it's actually the Curve25519\n        // identity key of the device which set up the Megolm session.\n\n        ret.sender = this.deviceList.getDeviceByIdentityKey(ret.algorithm, ret.senderKey) ?? undefined;\n\n        // so far so good, but now we need to check that the sender of this event\n        // hadn't advertised someone else's Curve25519 key as their own. We do that\n        // by checking the Ed25519 claimed by the event (or, in the case of megolm,\n        // the event which set up the megolm session), to check that it matches the\n        // fingerprint of the purported sending device.\n        //\n        // (see https://github.com/vector-im/vector-web/issues/2215)\n\n        const claimedKey = event.getClaimedEd25519Key();\n        if (!claimedKey) {\n            logger.warn(\"Event \" + event.getId() + \" claims no ed25519 key: \" + \"cannot verify sending device\");\n            ret.mismatchedSender = true;\n        }\n\n        if (ret.sender && claimedKey !== ret.sender.getFingerprint()) {\n            logger.warn(\n                \"Event \" +\n                    event.getId() +\n                    \" claims ed25519 key \" +\n                    claimedKey +\n                    \"but sender device has key \" +\n                    ret.sender.getFingerprint(),\n            );\n            ret.mismatchedSender = true;\n        }\n\n        return ret as IEncryptedEventInfo;\n    }\n\n    /**\n     * Forces the current outbound group session to be discarded such\n     * that another one will be created next time an event is sent.\n     *\n     * @param roomId - The ID of the room to discard the session for\n     *\n     * This should not normally be necessary.\n     */\n    public forceDiscardSession(roomId: string): void {\n        const alg = this.roomEncryptors.get(roomId);\n        if (alg === undefined) throw new Error(\"Room not encrypted\");\n        if (alg.forceDiscardSession === undefined) {\n            throw new Error(\"Room encryption algorithm doesn't support session discarding\");\n        }\n        alg.forceDiscardSession();\n    }\n\n    /**\n     * Configure a room to use encryption (ie, save a flag in the cryptoStore).\n     *\n     * @param roomId - The room ID to enable encryption in.\n     *\n     * @param config - The encryption config for the room.\n     *\n     * @param inhibitDeviceQuery - true to suppress device list query for\n     *   users in the room (for now). In case lazy loading is enabled,\n     *   the device query is always inhibited as the members are not tracked.\n     *\n     * @deprecated It is normally incorrect to call this method directly. Encryption\n     *   is enabled by receiving an `m.room.encryption` event (which we may have sent\n     *   previously).\n     */\n    public async setRoomEncryption(\n        roomId: string,\n        config: IRoomEncryption,\n        inhibitDeviceQuery?: boolean,\n    ): Promise<void> {\n        const room = this.clientStore.getRoom(roomId);\n        if (!room) {\n            throw new Error(`Unable to enable encryption tracking devices in unknown room ${roomId}`);\n        }\n        await this.setRoomEncryptionImpl(room, config);\n        if (!this.lazyLoadMembers && !inhibitDeviceQuery) {\n            this.deviceList.refreshOutdatedDeviceLists();\n        }\n    }\n\n    /**\n     * Set up encryption for a room.\n     *\n     * This is called when an <tt>m.room.encryption</tt> event is received. It saves a flag\n     * for the room in the cryptoStore (if it wasn't already set), sets up an \"encryptor\" for\n     * the room, and enables device-list tracking for the room.\n     *\n     * It does <em>not</em> initiate a device list query for the room. That is normally\n     * done once we finish processing the sync, in onSyncCompleted.\n     *\n     * @param room - The room to enable encryption in.\n     * @param config - The encryption config for the room.\n     */\n    private async setRoomEncryptionImpl(room: Room, config: IRoomEncryption): Promise<void> {\n        const roomId = room.roomId;\n\n        // ignore crypto events with no algorithm defined\n        // This will happen if a crypto event is redacted before we fetch the room state\n        // It would otherwise just throw later as an unknown algorithm would, but we may\n        // as well catch this here\n        if (!config.algorithm) {\n            logger.log(\"Ignoring setRoomEncryption with no algorithm\");\n            return;\n        }\n\n        // if state is being replayed from storage, we might already have a configuration\n        // for this room as they are persisted as well.\n        // We just need to make sure the algorithm is initialized in this case.\n        // However, if the new config is different,\n        // we should bail out as room encryption can't be changed once set.\n        const existingConfig = this.roomList.getRoomEncryption(roomId);\n        if (existingConfig) {\n            if (JSON.stringify(existingConfig) != JSON.stringify(config)) {\n                logger.error(\"Ignoring m.room.encryption event which requests \" + \"a change of config in \" + roomId);\n                return;\n            }\n        }\n        // if we already have encryption in this room, we should ignore this event,\n        // as it would reset the encryption algorithm.\n        // This is at least expected to be called twice, as sync calls onCryptoEvent\n        // for both the timeline and state sections in the /sync response,\n        // the encryption event would appear in both.\n        // If it's called more than twice though,\n        // it signals a bug on client or server.\n        const existingAlg = this.roomEncryptors.get(roomId);\n        if (existingAlg) {\n            return;\n        }\n\n        // _roomList.getRoomEncryption will not race with _roomList.setRoomEncryption\n        // because it first stores in memory. We should await the promise only\n        // after all the in-memory state (roomEncryptors and _roomList) has been updated\n        // to avoid races when calling this method multiple times. Hence keep a hold of the promise.\n        let storeConfigPromise: Promise<void> | null = null;\n        if (!existingConfig) {\n            storeConfigPromise = this.roomList.setRoomEncryption(roomId, config);\n        }\n\n        const AlgClass = algorithms.ENCRYPTION_CLASSES.get(config.algorithm);\n        if (!AlgClass) {\n            throw new Error(\"Unable to encrypt with \" + config.algorithm);\n        }\n\n        const alg = new AlgClass({\n            userId: this.userId,\n            deviceId: this.deviceId,\n            crypto: this,\n            olmDevice: this.olmDevice,\n            baseApis: this.baseApis,\n            roomId,\n            config,\n        });\n        this.roomEncryptors.set(roomId, alg);\n\n        if (storeConfigPromise) {\n            await storeConfigPromise;\n        }\n\n        logger.log(`Enabling encryption in ${roomId}`);\n\n        // we don't want to force a download of the full membership list of this room, but as soon as we have that\n        // list we can start tracking the device list.\n        if (room.membersLoaded()) {\n            await this.trackRoomDevicesImpl(room);\n        } else {\n            // wait for the membership list to be loaded\n            const onState = (_state: RoomState): void => {\n                room.off(RoomStateEvent.Update, onState);\n                if (room.membersLoaded()) {\n                    this.trackRoomDevicesImpl(room).catch((e) => {\n                        logger.error(`Error enabling device tracking in ${roomId}`, e);\n                    });\n                }\n            };\n            room.on(RoomStateEvent.Update, onState);\n        }\n    }\n\n    /**\n     * Make sure we are tracking the device lists for all users in this room.\n     *\n     * @param roomId - The room ID to start tracking devices in.\n     * @returns when all devices for the room have been fetched and marked to track\n     * @deprecated there's normally no need to call this function: device list tracking\n     *    will be enabled as soon as we have the full membership list.\n     */\n    public trackRoomDevices(roomId: string): Promise<void> {\n        const room = this.clientStore.getRoom(roomId);\n        if (!room) {\n            throw new Error(`Unable to start tracking devices in unknown room ${roomId}`);\n        }\n        return this.trackRoomDevicesImpl(room);\n    }\n\n    /**\n     * Make sure we are tracking the device lists for all users in this room.\n     *\n     * This is normally called when we are about to send an encrypted event, to make sure\n     * we have all the devices in the room; but it is also called when processing an\n     * m.room.encryption state event (if lazy-loading is disabled), or when members are\n     * loaded (if lazy-loading is enabled), to prepare the device list.\n     *\n     * @param room - Room to enable device-list tracking in\n     */\n    private trackRoomDevicesImpl(room: Room): Promise<void> {\n        const roomId = room.roomId;\n        const trackMembers = async (): Promise<void> => {\n            // not an encrypted room\n            if (!this.roomEncryptors.has(roomId)) {\n                return;\n            }\n            logger.log(`Starting to track devices for room ${roomId} ...`);\n            const members = await room.getEncryptionTargetMembers();\n            members.forEach((m) => {\n                this.deviceList.startTrackingDeviceList(m.userId);\n            });\n        };\n\n        let promise = this.roomDeviceTrackingState[roomId];\n        if (!promise) {\n            promise = trackMembers();\n            this.roomDeviceTrackingState[roomId] = promise.catch((err) => {\n                delete this.roomDeviceTrackingState[roomId];\n                throw err;\n            });\n        }\n        return promise;\n    }\n\n    /**\n     * Try to make sure we have established olm sessions for all known devices for\n     * the given users.\n     *\n     * @param users - list of user ids\n     * @param force - If true, force a new Olm session to be created. Default false.\n     *\n     * @returns resolves once the sessions are complete, to\n     *    an Object mapping from userId to deviceId to\n     *    {@link OlmSessionResult}\n     */\n    public ensureOlmSessionsForUsers(\n        users: string[],\n        force?: boolean,\n    ): Promise<Record<string, Record<string, olmlib.IOlmSessionResult>>> {\n        const devicesByUser: Record<string, DeviceInfo[]> = {};\n\n        for (const userId of users) {\n            devicesByUser[userId] = [];\n\n            const devices = this.getStoredDevicesForUser(userId) || [];\n            for (const deviceInfo of devices) {\n                const key = deviceInfo.getIdentityKey();\n                if (key == this.olmDevice.deviceCurve25519Key) {\n                    // don't bother setting up session to ourself\n                    continue;\n                }\n                if (deviceInfo.verified == DeviceVerification.BLOCKED) {\n                    // don't bother setting up sessions with blocked users\n                    continue;\n                }\n\n                devicesByUser[userId].push(deviceInfo);\n            }\n        }\n\n        return olmlib.ensureOlmSessionsForDevices(this.olmDevice, this.baseApis, devicesByUser, force);\n    }\n\n    /**\n     * Get a list containing all of the room keys\n     *\n     * @returns a list of session export objects\n     */\n    public async exportRoomKeys(): Promise<IMegolmSessionData[]> {\n        const exportedSessions: IMegolmSessionData[] = [];\n        await this.cryptoStore.doTxn(\"readonly\", [IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS], (txn) => {\n            this.cryptoStore.getAllEndToEndInboundGroupSessions(txn, (s) => {\n                if (s === null) return;\n\n                const sess = this.olmDevice.exportInboundGroupSession(s.senderKey, s.sessionId, s.sessionData!);\n                delete sess.first_known_index;\n                sess.algorithm = olmlib.MEGOLM_ALGORITHM;\n                exportedSessions.push(sess);\n            });\n        });\n\n        return exportedSessions;\n    }\n\n    /**\n     * Import a list of room keys previously exported by exportRoomKeys\n     *\n     * @param keys - a list of session export objects\n     * @returns a promise which resolves once the keys have been imported\n     */\n    public importRoomKeys(keys: IMegolmSessionData[], opts: IImportRoomKeysOpts = {}): Promise<void> {\n        let successes = 0;\n        let failures = 0;\n        const total = keys.length;\n\n        function updateProgress(): void {\n            opts.progressCallback?.({\n                stage: \"load_keys\",\n                successes,\n                failures,\n                total,\n            });\n        }\n\n        return Promise.all(\n            keys.map((key) => {\n                if (!key.room_id || !key.algorithm) {\n                    logger.warn(\"ignoring room key entry with missing fields\", key);\n                    failures++;\n                    if (opts.progressCallback) {\n                        updateProgress();\n                    }\n                    return null;\n                }\n\n                const alg = this.getRoomDecryptor(key.room_id, key.algorithm);\n                return alg.importRoomKey(key, opts).finally(() => {\n                    successes++;\n                    if (opts.progressCallback) {\n                        updateProgress();\n                    }\n                });\n            }),\n        ).then();\n    }\n\n    /**\n     * Counts the number of end to end session keys that are waiting to be backed up\n     * @returns Promise which resolves to the number of sessions requiring backup\n     */\n    public countSessionsNeedingBackup(): Promise<number> {\n        return this.backupManager.countSessionsNeedingBackup();\n    }\n\n    /**\n     * Perform any background tasks that can be done before a message is ready to\n     * send, in order to speed up sending of the message.\n     *\n     * @param room - the room the event is in\n     */\n    public prepareToEncrypt(room: Room): void {\n        const alg = this.roomEncryptors.get(room.roomId);\n        if (alg) {\n            alg.prepareToEncrypt(room);\n        }\n    }\n\n    /**\n     * Encrypt an event according to the configuration of the room.\n     *\n     * @param event -  event to be sent\n     *\n     * @param room - destination room.\n     *\n     * @returns Promise which resolves when the event has been\n     *     encrypted, or null if nothing was needed\n     */\n    public async encryptEvent(event: MatrixEvent, room?: Room): Promise<void> {\n        if (!room) {\n            throw new Error(\"Cannot send encrypted messages in unknown rooms\");\n        }\n\n        const roomId = event.getRoomId()!;\n\n        const alg = this.roomEncryptors.get(roomId);\n        if (!alg) {\n            // MatrixClient has already checked that this room should be encrypted,\n            // so this is an unexpected situation.\n            throw new Error(\n                \"Room \" +\n                    roomId +\n                    \" was previously configured to use encryption, but is \" +\n                    \"no longer. Perhaps the homeserver is hiding the \" +\n                    \"configuration event.\",\n            );\n        }\n\n        // wait for all the room devices to be loaded\n        await this.trackRoomDevicesImpl(room);\n\n        let content = event.getContent();\n        // If event has an m.relates_to then we need\n        // to put this on the wrapping event instead\n        const mRelatesTo = content[\"m.relates_to\"];\n        if (mRelatesTo) {\n            // Clone content here so we don't remove `m.relates_to` from the local-echo\n            content = Object.assign({}, content);\n            delete content[\"m.relates_to\"];\n        }\n\n        // Treat element's performance metrics the same as `m.relates_to` (when present)\n        const elementPerfMetrics = content[\"io.element.performance_metrics\"];\n        if (elementPerfMetrics) {\n            content = Object.assign({}, content);\n            delete content[\"io.element.performance_metrics\"];\n        }\n\n        const encryptedContent = (await alg.encryptMessage(room, event.getType(), content)) as IContent;\n\n        if (mRelatesTo) {\n            encryptedContent[\"m.relates_to\"] = mRelatesTo;\n        }\n        if (elementPerfMetrics) {\n            encryptedContent[\"io.element.performance_metrics\"] = elementPerfMetrics;\n        }\n\n        event.makeEncrypted(\n            \"m.room.encrypted\",\n            encryptedContent,\n            this.olmDevice.deviceCurve25519Key!,\n            this.olmDevice.deviceEd25519Key!,\n        );\n    }\n\n    /**\n     * Decrypt a received event\n     *\n     *\n     * @returns resolves once we have\n     *  finished decrypting. Rejects with an `algorithms.DecryptionError` if there\n     *  is a problem decrypting the event.\n     */\n    public async decryptEvent(event: MatrixEvent): Promise<IEventDecryptionResult> {\n        if (event.isRedacted()) {\n            const redactionEvent = new MatrixEvent({\n                room_id: event.getRoomId(),\n                ...event.getUnsigned().redacted_because,\n            });\n            const decryptedEvent = await this.decryptEvent(redactionEvent);\n\n            return {\n                clearEvent: {\n                    room_id: event.getRoomId(),\n                    type: \"m.room.message\",\n                    content: {},\n                    unsigned: {\n                        redacted_because: decryptedEvent.clearEvent as IEvent,\n                    },\n                },\n            };\n        } else {\n            const content = event.getWireContent();\n            const alg = this.getRoomDecryptor(event.getRoomId()!, content.algorithm);\n            return alg.decryptEvent(event);\n        }\n    }\n\n    /**\n     * Handle the notification from /sync or /keys/changes that device lists have\n     * been changed.\n     *\n     * @param syncData - Object containing sync tokens associated with this sync\n     * @param syncDeviceLists - device_lists field from /sync, or response from\n     * /keys/changes\n     */\n    public async handleDeviceListChanges(\n        syncData: ISyncStateData,\n        syncDeviceLists: Required<ISyncResponse>[\"device_lists\"],\n    ): Promise<void> {\n        // Initial syncs don't have device change lists. We'll either get the complete list\n        // of changes for the interval or will have invalidated everything in willProcessSync\n        if (!syncData.oldSyncToken) return;\n\n        // Here, we're relying on the fact that we only ever save the sync data after\n        // sucessfully saving the device list data, so we're guaranteed that the device\n        // list store is at least as fresh as the sync token from the sync store, ie.\n        // any device changes received in sync tokens prior to the 'next' token here\n        // have been processed and are reflected in the current device list.\n        // If we didn't make this assumption, we'd have to use the /keys/changes API\n        // to get key changes between the sync token in the device list and the 'old'\n        // sync token used here to make sure we didn't miss any.\n        await this.evalDeviceListChanges(syncDeviceLists);\n    }\n\n    /**\n     * Send a request for some room keys, if we have not already done so\n     *\n     * @param resend - whether to resend the key request if there is\n     *    already one\n     *\n     * @returns a promise that resolves when the key request is queued\n     */\n    public requestRoomKey(\n        requestBody: IRoomKeyRequestBody,\n        recipients: IRoomKeyRequestRecipient[],\n        resend = false,\n    ): Promise<void> {\n        return this.outgoingRoomKeyRequestManager\n            .queueRoomKeyRequest(requestBody, recipients, resend)\n            .then(() => {\n                if (this.sendKeyRequestsImmediately) {\n                    this.outgoingRoomKeyRequestManager.sendQueuedRequests();\n                }\n            })\n            .catch((e) => {\n                // this normally means we couldn't talk to the store\n                logger.error(\"Error requesting key for event\", e);\n            });\n    }\n\n    /**\n     * Cancel any earlier room key request\n     *\n     * @param requestBody - parameters to match for cancellation\n     */\n    public cancelRoomKeyRequest(requestBody: IRoomKeyRequestBody): void {\n        this.outgoingRoomKeyRequestManager.cancelRoomKeyRequest(requestBody).catch((e) => {\n            logger.warn(\"Error clearing pending room key requests\", e);\n        });\n    }\n\n    /**\n     * Re-send any outgoing key requests, eg after verification\n     * @returns\n     */\n    public async cancelAndResendAllOutgoingKeyRequests(): Promise<void> {\n        await this.outgoingRoomKeyRequestManager.cancelAndResendAllOutgoingRequests();\n    }\n\n    /**\n     * handle an m.room.encryption event\n     *\n     * @param room - in which the event was received\n     * @param event - encryption event to be processed\n     */\n    public async onCryptoEvent(room: Room, event: MatrixEvent): Promise<void> {\n        const content = event.getContent<IRoomEncryption>();\n        await this.setRoomEncryptionImpl(room, content);\n    }\n\n    /**\n     * Called before the result of a sync is processed\n     *\n     * @param syncData -  the data from the 'MatrixClient.sync' event\n     */\n    public async onSyncWillProcess(syncData: ISyncStateData): Promise<void> {\n        if (!syncData.oldSyncToken) {\n            // If there is no old sync token, we start all our tracking from\n            // scratch, so mark everything as untracked. onCryptoEvent will\n            // be called for all e2e rooms during the processing of the sync,\n            // at which point we'll start tracking all the users of that room.\n            logger.log(\"Initial sync performed - resetting device tracking state\");\n            this.deviceList.stopTrackingAllDeviceLists();\n            // we always track our own device list (for key backups etc)\n            this.deviceList.startTrackingDeviceList(this.userId);\n            this.roomDeviceTrackingState = {};\n        }\n\n        this.sendKeyRequestsImmediately = false;\n    }\n\n    /**\n     * handle the completion of a /sync\n     *\n     * This is called after the processing of each successful /sync response.\n     * It is an opportunity to do a batch process on the information received.\n     *\n     * @param syncData -  the data from the 'MatrixClient.sync' event\n     */\n    public async onSyncCompleted(syncData: ISyncStateData): Promise<void> {\n        this.deviceList.setSyncToken(syncData.nextSyncToken ?? null);\n        this.deviceList.saveIfDirty();\n\n        // we always track our own device list (for key backups etc)\n        this.deviceList.startTrackingDeviceList(this.userId);\n\n        this.deviceList.refreshOutdatedDeviceLists();\n\n        // we don't start uploading one-time keys until we've caught up with\n        // to-device messages, to help us avoid throwing away one-time-keys that we\n        // are about to receive messages for\n        // (https://github.com/vector-im/element-web/issues/2782).\n        if (!syncData.catchingUp) {\n            this.maybeUploadOneTimeKeys();\n            this.processReceivedRoomKeyRequests();\n\n            // likewise don't start requesting keys until we've caught up\n            // on to_device messages, otherwise we'll request keys that we're\n            // just about to get.\n            this.outgoingRoomKeyRequestManager.sendQueuedRequests();\n\n            // Sync has finished so send key requests straight away.\n            this.sendKeyRequestsImmediately = true;\n        }\n    }\n\n    /**\n     * Trigger the appropriate invalidations and removes for a given\n     * device list\n     *\n     * @param deviceLists - device_lists field from /sync, or response from\n     * /keys/changes\n     */\n    private async evalDeviceListChanges(deviceLists: Required<ISyncResponse>[\"device_lists\"]): Promise<void> {\n        if (Array.isArray(deviceLists?.changed)) {\n            deviceLists.changed.forEach((u) => {\n                this.deviceList.invalidateUserDeviceList(u);\n            });\n        }\n\n        if (Array.isArray(deviceLists?.left) && deviceLists.left.length) {\n            // Check we really don't share any rooms with these users\n            // any more: the server isn't required to give us the\n            // exact correct set.\n            const e2eUserIds = new Set(await this.getTrackedE2eUsers());\n\n            deviceLists.left.forEach((u) => {\n                if (!e2eUserIds.has(u)) {\n                    this.deviceList.stopTrackingDeviceList(u);\n                }\n            });\n        }\n    }\n\n    /**\n     * Get a list of all the IDs of users we share an e2e room with\n     * for which we are tracking devices already\n     *\n     * @returns List of user IDs\n     */\n    private async getTrackedE2eUsers(): Promise<string[]> {\n        const e2eUserIds: string[] = [];\n        for (const room of this.getTrackedE2eRooms()) {\n            const members = await room.getEncryptionTargetMembers();\n            for (const member of members) {\n                e2eUserIds.push(member.userId);\n            }\n        }\n        return e2eUserIds;\n    }\n\n    /**\n     * Get a list of the e2e-enabled rooms we are members of,\n     * and for which we are already tracking the devices\n     *\n     * @returns\n     */\n    private getTrackedE2eRooms(): Room[] {\n        return this.clientStore.getRooms().filter((room) => {\n            // check for rooms with encryption enabled\n            const alg = this.roomEncryptors.get(room.roomId);\n            if (!alg) {\n                return false;\n            }\n            if (!this.roomDeviceTrackingState[room.roomId]) {\n                return false;\n            }\n\n            // ignore any rooms which we have left\n            const myMembership = room.getMyMembership();\n            return myMembership === \"join\" || myMembership === \"invite\";\n        });\n    }\n\n    /**\n     * Encrypts and sends a given object via Olm to-device messages to a given\n     * set of devices.\n     * @param userDeviceInfoArr - the devices to send to\n     * @param payload - fields to include in the encrypted payload\n     * @returns Promise which\n     *     resolves once the message has been encrypted and sent to the given\n     *     userDeviceMap, and returns the `{ contentMap, deviceInfoByDeviceId }`\n     *     of the successfully sent messages.\n     */\n    public async encryptAndSendToDevices(userDeviceInfoArr: IOlmDevice<DeviceInfo>[], payload: object): Promise<void> {\n        const toDeviceBatch: ToDeviceBatch = {\n            eventType: EventType.RoomMessageEncrypted,\n            batch: [],\n        };\n\n        try {\n            await Promise.all(\n                userDeviceInfoArr.map(async ({ userId, deviceInfo }) => {\n                    const deviceId = deviceInfo.deviceId;\n                    const encryptedContent: IEncryptedContent = {\n                        algorithm: olmlib.OLM_ALGORITHM,\n                        sender_key: this.olmDevice.deviceCurve25519Key!,\n                        ciphertext: {},\n                        [ToDeviceMessageId]: uuidv4(),\n                    };\n\n                    toDeviceBatch.batch.push({\n                        userId,\n                        deviceId,\n                        payload: encryptedContent,\n                    });\n\n                    await olmlib.ensureOlmSessionsForDevices(this.olmDevice, this.baseApis, { [userId]: [deviceInfo] });\n                    await olmlib.encryptMessageForDevice(\n                        encryptedContent.ciphertext,\n                        this.userId,\n                        this.deviceId,\n                        this.olmDevice,\n                        userId,\n                        deviceInfo,\n                        payload,\n                    );\n                }),\n            );\n\n            // prune out any devices that encryptMessageForDevice could not encrypt for,\n            // in which case it will have just not added anything to the ciphertext object.\n            // There's no point sending messages to devices if we couldn't encrypt to them,\n            // since that's effectively a blank message.\n            toDeviceBatch.batch = toDeviceBatch.batch.filter((msg) => {\n                if (Object.keys(msg.payload.ciphertext).length > 0) {\n                    return true;\n                } else {\n                    logger.log(`No ciphertext for device ${msg.userId}:${msg.deviceId}: pruning`);\n                    return false;\n                }\n            });\n\n            try {\n                await this.baseApis.queueToDevice(toDeviceBatch);\n            } catch (e) {\n                logger.error(\"sendToDevice failed\", e);\n                throw e;\n            }\n        } catch (e) {\n            logger.error(\"encryptAndSendToDevices promises failed\", e);\n            throw e;\n        }\n    }\n\n    private onMembership = (event: MatrixEvent, member: RoomMember, oldMembership?: string): void => {\n        try {\n            this.onRoomMembership(event, member, oldMembership);\n        } catch (e) {\n            logger.error(\"Error handling membership change:\", e);\n        }\n    };\n\n    private onToDeviceEvent = (event: MatrixEvent): void => {\n        try {\n            logger.log(\n                `received to-device ${event.getType()} from: ` +\n                    `${event.getSender()} id: ${event.getContent()[ToDeviceMessageId]}`,\n            );\n\n            if (event.getType() == \"m.room_key\" || event.getType() == \"m.forwarded_room_key\") {\n                this.onRoomKeyEvent(event);\n            } else if (event.getType() == \"m.room_key_request\") {\n                this.onRoomKeyRequestEvent(event);\n            } else if (event.getType() === \"m.secret.request\") {\n                this.secretStorage.onRequestReceived(event);\n            } else if (event.getType() === \"m.secret.send\") {\n                this.secretStorage.onSecretReceived(event);\n            } else if (event.getType() === \"m.room_key.withheld\") {\n                this.onRoomKeyWithheldEvent(event);\n            } else if (event.getContent().transaction_id) {\n                this.onKeyVerificationMessage(event);\n            } else if (event.getContent().msgtype === \"m.bad.encrypted\") {\n                this.onToDeviceBadEncrypted(event);\n            } else if (event.isBeingDecrypted() || event.shouldAttemptDecryption()) {\n                if (!event.isBeingDecrypted()) {\n                    event.attemptDecryption(this);\n                }\n                // once the event has been decrypted, try again\n                event.once(MatrixEventEvent.Decrypted, (ev) => {\n                    this.onToDeviceEvent(ev);\n                });\n            }\n        } catch (e) {\n            logger.error(\"Error handling toDeviceEvent:\", e);\n        }\n    };\n\n    /**\n     * Handle a key event\n     *\n     * @internal\n     * @param event - key event\n     */\n    private onRoomKeyEvent(event: MatrixEvent): void {\n        const content = event.getContent();\n\n        if (!content.room_id || !content.algorithm) {\n            logger.error(\"key event is missing fields\");\n            return;\n        }\n\n        if (!this.backupManager.checkedForBackup) {\n            // don't bother awaiting on this - the important thing is that we retry if we\n            // haven't managed to check before\n            this.backupManager.checkAndStart();\n        }\n\n        const alg = this.getRoomDecryptor(content.room_id, content.algorithm);\n        alg.onRoomKeyEvent(event);\n    }\n\n    /**\n     * Handle a key withheld event\n     *\n     * @internal\n     * @param event - key withheld event\n     */\n    private onRoomKeyWithheldEvent(event: MatrixEvent): void {\n        const content = event.getContent();\n\n        if (\n            (content.code !== \"m.no_olm\" && (!content.room_id || !content.session_id)) ||\n            !content.algorithm ||\n            !content.sender_key\n        ) {\n            logger.error(\"key withheld event is missing fields\");\n            return;\n        }\n\n        logger.info(\n            `Got room key withheld event from ${event.getSender()} ` +\n                `for ${content.algorithm} session ${content.sender_key}|${content.session_id} ` +\n                `in room ${content.room_id} with code ${content.code} (${content.reason})`,\n        );\n\n        const alg = this.getRoomDecryptor(content.room_id, content.algorithm);\n        if (alg.onRoomKeyWithheldEvent) {\n            alg.onRoomKeyWithheldEvent(event);\n        }\n        if (!content.room_id) {\n            // retry decryption for all events sent by the sender_key.  This will\n            // update the events to show a message indicating that the olm session was\n            // wedged.\n            const roomDecryptors = this.getRoomDecryptors(content.algorithm);\n            for (const decryptor of roomDecryptors) {\n                decryptor.retryDecryptionFromSender(content.sender_key);\n            }\n        }\n    }\n\n    /**\n     * Handle a general key verification event.\n     *\n     * @internal\n     * @param event - verification start event\n     */\n    private onKeyVerificationMessage(event: MatrixEvent): void {\n        if (!ToDeviceChannel.validateEvent(event, this.baseApis)) {\n            return;\n        }\n        const createRequest = (event: MatrixEvent): VerificationRequest | undefined => {\n            if (!ToDeviceChannel.canCreateRequest(ToDeviceChannel.getEventType(event))) {\n                return;\n            }\n            const content = event.getContent();\n            const deviceId = content && content.from_device;\n            if (!deviceId) {\n                return;\n            }\n            const userId = event.getSender()!;\n            const channel = new ToDeviceChannel(this.baseApis, userId, [deviceId]);\n            return new VerificationRequest(channel, this.verificationMethods, this.baseApis);\n        };\n        this.handleVerificationEvent(event, this.toDeviceVerificationRequests, createRequest);\n    }\n\n    /**\n     * Handle key verification requests sent as timeline events\n     *\n     * @internal\n     * @param event - the timeline event\n     * @param room - not used\n     * @param atStart - not used\n     * @param removed - not used\n     * @param whether - this is a live event\n     */\n    private onTimelineEvent = (\n        event: MatrixEvent,\n        room: Room,\n        atStart: boolean,\n        removed: boolean,\n        { liveEvent = true } = {},\n    ): void => {\n        if (!InRoomChannel.validateEvent(event, this.baseApis)) {\n            return;\n        }\n        const createRequest = (event: MatrixEvent): VerificationRequest => {\n            const channel = new InRoomChannel(this.baseApis, event.getRoomId()!);\n            return new VerificationRequest(channel, this.verificationMethods, this.baseApis);\n        };\n        this.handleVerificationEvent(event, this.inRoomVerificationRequests, createRequest, liveEvent);\n    };\n\n    private async handleVerificationEvent(\n        event: MatrixEvent,\n        requestsMap: IRequestsMap,\n        createRequest: (event: MatrixEvent) => VerificationRequest | undefined,\n        isLiveEvent = true,\n    ): Promise<void> {\n        // Wait for event to get its final ID with pendingEventOrdering: \"chronological\", since DM channels depend on it.\n        if (event.isSending() && event.status != EventStatus.SENT) {\n            let eventIdListener: () => void;\n            let statusListener: () => void;\n            try {\n                await new Promise<void>((resolve, reject) => {\n                    eventIdListener = resolve;\n                    statusListener = (): void => {\n                        if (event.status == EventStatus.CANCELLED) {\n                            reject(new Error(\"Event status set to CANCELLED.\"));\n                        }\n                    };\n                    event.once(MatrixEventEvent.LocalEventIdReplaced, eventIdListener);\n                    event.on(MatrixEventEvent.Status, statusListener);\n                });\n            } catch (err) {\n                logger.error(\"error while waiting for the verification event to be sent: \", err);\n                return;\n            } finally {\n                event.removeListener(MatrixEventEvent.LocalEventIdReplaced, eventIdListener!);\n                event.removeListener(MatrixEventEvent.Status, statusListener!);\n            }\n        }\n        let request: VerificationRequest | undefined = requestsMap.getRequest(event);\n        let isNewRequest = false;\n        if (!request) {\n            request = createRequest(event);\n            // a request could not be made from this event, so ignore event\n            if (!request) {\n                logger.log(\n                    `Crypto: could not find VerificationRequest for ` +\n                        `${event.getType()}, and could not create one, so ignoring.`,\n                );\n                return;\n            }\n            isNewRequest = true;\n            requestsMap.setRequest(event, request);\n        }\n        event.setVerificationRequest(request);\n        try {\n            await request.channel.handleEvent(event, request, isLiveEvent);\n        } catch (err) {\n            logger.error(\"error while handling verification event\", err);\n        }\n        const shouldEmit =\n            isNewRequest &&\n            !request.initiatedByMe &&\n            !request.invalid && // check it has enough events to pass the UNSENT stage\n            !request.observeOnly;\n        if (shouldEmit) {\n            this.baseApis.emit(CryptoEvent.VerificationRequest, request);\n        }\n    }\n\n    /**\n     * Handle a toDevice event that couldn't be decrypted\n     *\n     * @internal\n     * @param event - undecryptable event\n     */\n    private async onToDeviceBadEncrypted(event: MatrixEvent): Promise<void> {\n        const content = event.getWireContent();\n        const sender = event.getSender();\n        const algorithm = content.algorithm;\n        const deviceKey = content.sender_key;\n\n        // retry decryption for all events sent by the sender_key.  This will\n        // update the events to show a message indicating that the olm session was\n        // wedged.\n        const retryDecryption = (): void => {\n            const roomDecryptors = this.getRoomDecryptors(olmlib.MEGOLM_ALGORITHM);\n            for (const decryptor of roomDecryptors) {\n                decryptor.retryDecryptionFromSender(deviceKey);\n            }\n        };\n\n        if (sender === undefined || deviceKey === undefined || deviceKey === undefined) {\n            return;\n        }\n\n        // check when we last forced a new session with this device: if we've already done so\n        // recently, don't do it again.\n        this.lastNewSessionForced[sender] = this.lastNewSessionForced[sender] || {};\n        const lastNewSessionForced = this.lastNewSessionForced[sender][deviceKey] || 0;\n        if (lastNewSessionForced + MIN_FORCE_SESSION_INTERVAL_MS > Date.now()) {\n            logger.debug(\n                \"New session already forced with device \" +\n                    sender +\n                    \":\" +\n                    deviceKey +\n                    \" at \" +\n                    lastNewSessionForced +\n                    \": not forcing another\",\n            );\n            await this.olmDevice.recordSessionProblem(deviceKey, \"wedged\", true);\n            retryDecryption();\n            return;\n        }\n\n        // establish a new olm session with this device since we're failing to decrypt messages\n        // on a current session.\n        // Note that an undecryptable message from another device could easily be spoofed -\n        // is there anything we can do to mitigate this?\n        let device = this.deviceList.getDeviceByIdentityKey(algorithm, deviceKey);\n        if (!device) {\n            // if we don't know about the device, fetch the user's devices again\n            // and retry before giving up\n            await this.downloadKeys([sender], false);\n            device = this.deviceList.getDeviceByIdentityKey(algorithm, deviceKey);\n            if (!device) {\n                logger.info(\"Couldn't find device for identity key \" + deviceKey + \": not re-establishing session\");\n                await this.olmDevice.recordSessionProblem(deviceKey, \"wedged\", false);\n                retryDecryption();\n                return;\n            }\n        }\n        const devicesByUser: Record<string, DeviceInfo[]> = {};\n        devicesByUser[sender] = [device];\n        await olmlib.ensureOlmSessionsForDevices(this.olmDevice, this.baseApis, devicesByUser, true);\n\n        this.lastNewSessionForced[sender][deviceKey] = Date.now();\n\n        // Now send a blank message on that session so the other side knows about it.\n        // (The keyshare request is sent in the clear so that won't do)\n        // We send this first such that, as long as the toDevice messages arrive in the\n        // same order we sent them, the other end will get this first, set up the new session,\n        // then get the keyshare request and send the key over this new session (because it\n        // is the session it has most recently received a message on).\n        const encryptedContent: IEncryptedContent = {\n            algorithm: olmlib.OLM_ALGORITHM,\n            sender_key: this.olmDevice.deviceCurve25519Key!,\n            ciphertext: {},\n            [ToDeviceMessageId]: uuidv4(),\n        };\n        await olmlib.encryptMessageForDevice(\n            encryptedContent.ciphertext,\n            this.userId,\n            this.deviceId,\n            this.olmDevice,\n            sender,\n            device,\n            { type: \"m.dummy\" },\n        );\n\n        await this.olmDevice.recordSessionProblem(deviceKey, \"wedged\", true);\n        retryDecryption();\n\n        await this.baseApis.sendToDevice(\"m.room.encrypted\", {\n            [sender]: {\n                [device.deviceId]: encryptedContent,\n            },\n        });\n\n        // Most of the time this probably won't be necessary since we'll have queued up a key request when\n        // we failed to decrypt the message and will be waiting a bit for the key to arrive before sending\n        // it. This won't always be the case though so we need to re-send any that have already been sent\n        // to avoid races.\n        const requestsToResend = await this.outgoingRoomKeyRequestManager.getOutgoingSentRoomKeyRequest(\n            sender,\n            device.deviceId,\n        );\n        for (const keyReq of requestsToResend) {\n            this.requestRoomKey(keyReq.requestBody, keyReq.recipients, true);\n        }\n    }\n\n    /**\n     * Handle a change in the membership state of a member of a room\n     *\n     * @internal\n     * @param event -  event causing the change\n     * @param member -  user whose membership changed\n     * @param oldMembership -  previous membership\n     */\n    private onRoomMembership(event: MatrixEvent, member: RoomMember, oldMembership?: string): void {\n        // this event handler is registered on the *client* (as opposed to the room\n        // member itself), which means it is only called on changes to the *live*\n        // membership state (ie, it is not called when we back-paginate, nor when\n        // we load the state in the initialsync).\n        //\n        // Further, it is automatically registered and called when new members\n        // arrive in the room.\n\n        const roomId = member.roomId;\n\n        const alg = this.roomEncryptors.get(roomId);\n        if (!alg) {\n            // not encrypting in this room\n            return;\n        }\n        // only mark users in this room as tracked if we already started tracking in this room\n        // this way we don't start device queries after sync on behalf of this room which we won't use\n        // the result of anyway, as we'll need to do a query again once all the members are fetched\n        // by calling _trackRoomDevices\n        if (roomId in this.roomDeviceTrackingState) {\n            if (member.membership == \"join\") {\n                logger.log(\"Join event for \" + member.userId + \" in \" + roomId);\n                // make sure we are tracking the deviceList for this user\n                this.deviceList.startTrackingDeviceList(member.userId);\n            } else if (\n                member.membership == \"invite\" &&\n                this.clientStore.getRoom(roomId)?.shouldEncryptForInvitedMembers()\n            ) {\n                logger.log(\"Invite event for \" + member.userId + \" in \" + roomId);\n                this.deviceList.startTrackingDeviceList(member.userId);\n            }\n        }\n\n        alg.onRoomMembership(event, member, oldMembership);\n    }\n\n    /**\n     * Called when we get an m.room_key_request event.\n     *\n     * @internal\n     * @param event - key request event\n     */\n    private onRoomKeyRequestEvent(event: MatrixEvent): void {\n        const content = event.getContent();\n        if (content.action === \"request\") {\n            // Queue it up for now, because they tend to arrive before the room state\n            // events at initial sync, and we want to see if we know anything about the\n            // room before passing them on to the app.\n            const req = new IncomingRoomKeyRequest(event);\n            this.receivedRoomKeyRequests.push(req);\n        } else if (content.action === \"request_cancellation\") {\n            const req = new IncomingRoomKeyRequestCancellation(event);\n            this.receivedRoomKeyRequestCancellations.push(req);\n        }\n    }\n\n    /**\n     * Process any m.room_key_request events which were queued up during the\n     * current sync.\n     *\n     * @internal\n     */\n    private async processReceivedRoomKeyRequests(): Promise<void> {\n        if (this.processingRoomKeyRequests) {\n            // we're still processing last time's requests; keep queuing new ones\n            // up for now.\n            return;\n        }\n        this.processingRoomKeyRequests = true;\n\n        try {\n            // we need to grab and clear the queues in the synchronous bit of this method,\n            // so that we don't end up racing with the next /sync.\n            const requests = this.receivedRoomKeyRequests;\n            this.receivedRoomKeyRequests = [];\n            const cancellations = this.receivedRoomKeyRequestCancellations;\n            this.receivedRoomKeyRequestCancellations = [];\n\n            // Process all of the requests, *then* all of the cancellations.\n            //\n            // This makes sure that if we get a request and its cancellation in the\n            // same /sync result, then we process the request before the\n            // cancellation (and end up with a cancelled request), rather than the\n            // cancellation before the request (and end up with an outstanding\n            // request which should have been cancelled.)\n            await Promise.all(requests.map((req) => this.processReceivedRoomKeyRequest(req)));\n            await Promise.all(\n                cancellations.map((cancellation) => this.processReceivedRoomKeyRequestCancellation(cancellation)),\n            );\n        } catch (e) {\n            logger.error(`Error processing room key requsts: ${e}`);\n        } finally {\n            this.processingRoomKeyRequests = false;\n        }\n    }\n\n    /**\n     * Helper for processReceivedRoomKeyRequests\n     *\n     */\n    private async processReceivedRoomKeyRequest(req: IncomingRoomKeyRequest): Promise<void> {\n        const userId = req.userId;\n        const deviceId = req.deviceId;\n\n        const body = req.requestBody;\n        const roomId = body.room_id;\n        const alg = body.algorithm;\n\n        logger.log(\n            `m.room_key_request from ${userId}:${deviceId}` +\n                ` for ${roomId} / ${body.session_id} (id ${req.requestId})`,\n        );\n\n        if (userId !== this.userId) {\n            if (!this.roomEncryptors.get(roomId)) {\n                logger.debug(`room key request for unencrypted room ${roomId}`);\n                return;\n            }\n            const encryptor = this.roomEncryptors.get(roomId)!;\n            const device = this.deviceList.getStoredDevice(userId, deviceId);\n            if (!device) {\n                logger.debug(`Ignoring keyshare for unknown device ${userId}:${deviceId}`);\n                return;\n            }\n\n            try {\n                await encryptor.reshareKeyWithDevice!(body.sender_key, body.session_id, userId, device);\n            } catch (e) {\n                logger.warn(\n                    \"Failed to re-share keys for session \" +\n                        body.session_id +\n                        \" with device \" +\n                        userId +\n                        \":\" +\n                        device.deviceId,\n                    e,\n                );\n            }\n            return;\n        }\n\n        if (deviceId === this.deviceId) {\n            // We'll always get these because we send room key requests to\n            // '*' (ie. 'all devices') which includes the sending device,\n            // so ignore requests from ourself because apart from it being\n            // very silly, it won't work because an Olm session cannot send\n            // messages to itself.\n            // The log here is probably superfluous since we know this will\n            // always happen, but let's log anyway for now just in case it\n            // causes issues.\n            logger.log(\"Ignoring room key request from ourselves\");\n            return;\n        }\n\n        // todo: should we queue up requests we don't yet have keys for,\n        // in case they turn up later?\n\n        // if we don't have a decryptor for this room/alg, we don't have\n        // the keys for the requested events, and can drop the requests.\n        if (!this.roomDecryptors.has(roomId)) {\n            logger.log(`room key request for unencrypted room ${roomId}`);\n            return;\n        }\n\n        const decryptor = this.roomDecryptors.get(roomId)!.get(alg);\n        if (!decryptor) {\n            logger.log(`room key request for unknown alg ${alg} in room ${roomId}`);\n            return;\n        }\n\n        if (!(await decryptor.hasKeysForKeyRequest(req))) {\n            logger.log(`room key request for unknown session ${roomId} / ` + body.session_id);\n            return;\n        }\n\n        req.share = (): void => {\n            decryptor.shareKeysWithDevice(req);\n        };\n\n        // if the device is verified already, share the keys\n        if (this.checkDeviceTrust(userId, deviceId).isVerified()) {\n            logger.log(\"device is already verified: sharing keys\");\n            req.share();\n            return;\n        }\n\n        this.emit(CryptoEvent.RoomKeyRequest, req);\n    }\n\n    /**\n     * Helper for processReceivedRoomKeyRequests\n     *\n     */\n    private async processReceivedRoomKeyRequestCancellation(\n        cancellation: IncomingRoomKeyRequestCancellation,\n    ): Promise<void> {\n        logger.log(\n            `m.room_key_request cancellation for ${cancellation.userId}:` +\n                `${cancellation.deviceId} (id ${cancellation.requestId})`,\n        );\n\n        // we should probably only notify the app of cancellations we told it\n        // about, but we don't currently have a record of that, so we just pass\n        // everything through.\n        this.emit(CryptoEvent.RoomKeyRequestCancellation, cancellation);\n    }\n\n    /**\n     * Get a decryptor for a given room and algorithm.\n     *\n     * If we already have a decryptor for the given room and algorithm, return\n     * it. Otherwise try to instantiate it.\n     *\n     * @internal\n     *\n     * @param roomId -   room id for decryptor. If undefined, a temporary\n     * decryptor is instantiated.\n     *\n     * @param algorithm -  crypto algorithm\n     *\n     * @throws {@link DecryptionError} if the algorithm is unknown\n     */\n    public getRoomDecryptor(roomId: string | null, algorithm: string): DecryptionAlgorithm {\n        let decryptors: Map<string, DecryptionAlgorithm> | undefined;\n        let alg: DecryptionAlgorithm | undefined;\n\n        if (roomId) {\n            decryptors = this.roomDecryptors.get(roomId);\n            if (!decryptors) {\n                decryptors = new Map<string, DecryptionAlgorithm>();\n                this.roomDecryptors.set(roomId, decryptors);\n            }\n\n            alg = decryptors.get(algorithm);\n            if (alg) {\n                return alg;\n            }\n        }\n\n        const AlgClass = algorithms.DECRYPTION_CLASSES.get(algorithm);\n        if (!AlgClass) {\n            throw new algorithms.DecryptionError(\n                \"UNKNOWN_ENCRYPTION_ALGORITHM\",\n                'Unknown encryption algorithm \"' + algorithm + '\".',\n            );\n        }\n        alg = new AlgClass({\n            userId: this.userId,\n            crypto: this,\n            olmDevice: this.olmDevice,\n            baseApis: this.baseApis,\n            roomId: roomId ?? undefined,\n        });\n\n        if (decryptors) {\n            decryptors.set(algorithm, alg);\n        }\n        return alg;\n    }\n\n    /**\n     * Get all the room decryptors for a given encryption algorithm.\n     *\n     * @param algorithm - The encryption algorithm\n     *\n     * @returns An array of room decryptors\n     */\n    private getRoomDecryptors(algorithm: string): DecryptionAlgorithm[] {\n        const decryptors: DecryptionAlgorithm[] = [];\n        for (const d of this.roomDecryptors.values()) {\n            if (d.has(algorithm)) {\n                decryptors.push(d.get(algorithm)!);\n            }\n        }\n        return decryptors;\n    }\n\n    /**\n     * sign the given object with our ed25519 key\n     *\n     * @param obj -  Object to which we will add a 'signatures' property\n     */\n    public async signObject<T extends ISignableObject & object>(obj: T): Promise<void> {\n        const sigs = obj.signatures || {};\n        const unsigned = obj.unsigned;\n\n        delete obj.signatures;\n        delete obj.unsigned;\n\n        sigs[this.userId] = sigs[this.userId] || {};\n        sigs[this.userId][\"ed25519:\" + this.deviceId] = await this.olmDevice.sign(anotherjson.stringify(obj));\n        obj.signatures = sigs;\n        if (unsigned !== undefined) obj.unsigned = unsigned;\n    }\n}\n\n/**\n * Fix up the backup key, that may be in the wrong format due to a bug in a\n * migration step.  Some backup keys were stored as a comma-separated list of\n * integers, rather than a base64-encoded byte array.  If this function is\n * passed a string that looks like a list of integers rather than a base64\n * string, it will attempt to convert it to the right format.\n *\n * @param key - the key to check\n * @returns If the key is in the wrong format, then the fixed\n * key will be returned. Otherwise null will be returned.\n *\n */\nexport function fixBackupKey(key?: string): string | null {\n    if (typeof key !== \"string\" || key.indexOf(\",\") < 0) {\n        return null;\n    }\n    const fixedKey = Uint8Array.from(key.split(\",\"), (x) => parseInt(x));\n    return olmlib.encodeBase64(fixedKey);\n}\n\n/**\n * Represents a received m.room_key_request event\n */\nexport class IncomingRoomKeyRequest {\n    /** user requesting the key */\n    public readonly userId: string;\n    /** device requesting the key */\n    public readonly deviceId: string;\n    /** unique id for the request */\n    public readonly requestId: string;\n    public readonly requestBody: IRoomKeyRequestBody;\n    /**\n     * callback which, when called, will ask\n     *    the relevant crypto algorithm implementation to share the keys for\n     *    this request.\n     */\n    public share: () => void;\n\n    public constructor(event: MatrixEvent) {\n        const content = event.getContent();\n\n        this.userId = event.getSender()!;\n        this.deviceId = content.requesting_device_id;\n        this.requestId = content.request_id;\n        this.requestBody = content.body || {};\n        this.share = (): void => {\n            throw new Error(\"don't know how to share keys for this request yet\");\n        };\n    }\n}\n\n/**\n * Represents a received m.room_key_request cancellation\n */\nclass IncomingRoomKeyRequestCancellation {\n    /** user requesting the cancellation */\n    public readonly userId: string;\n    /** device requesting the cancellation */\n    public readonly deviceId: string;\n    /** unique id for the request to be cancelled */\n    public readonly requestId: string;\n\n    public constructor(event: MatrixEvent) {\n        const content = event.getContent();\n\n        this.userId = event.getSender()!;\n        this.deviceId = content.requesting_device_id;\n        this.requestId = content.request_id;\n    }\n}\n\n// a number of types are re-exported for backwards compatibility, in case any applications are referencing it.\nexport type { IEventDecryptionResult, IMegolmSessionData } from \"../@types/crypto\";\n"],"mappings":"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"}