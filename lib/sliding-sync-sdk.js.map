{"version":3,"file":"sliding-sync-sdk.js","names":["FAILED_SYNC_ERROR_THRESHOLD","ExtensionE2EE","constructor","crypto","name","when","ExtensionState","PreProcess","onRequest","isInitial","undefined","enabled","onResponse","data","handleDeviceListChanges","oldSyncToken","currentCount","signed_curve25519","updateOneTimeKeyCount","unusedFallbackKeys","setNeedsNewFallback","Array","includes","ExtensionToDevice","client","extReq","since","nextBatch","cancelledKeyVerificationTxns","map","getEventMapper","toDeviceEvent","getType","txnId","getContent","push","forEach","content","msgtype","logger","log","getSender","flagCancelled","emit","ClientEvent","ToDeviceEvent","ExtensionAccountData","PostProcess","global","length","processGlobalAccountData","roomId","rooms","accountDataEvents","mapEvents","room","getRoom","warn","addAccountData","e","Event","globalAccountData","events","prevEventsMap","reduce","m","c","getId","store","getAccountData","storeAccountDataEvents","accountDataEvent","EventType","PushRules","rules","pushRules","PushProcessor","rewriteDefaultRules","prevEvent","AccountData","SlidingSyncSdk","slidingSync","opts","initialSyncLimit","resolveInvitesToProfiles","pollTimeout","pendingEventOrdering","PendingEventOrdering","Chronological","experimentalThreadSupport","canResetEntireTimeline","_roomId","getNotifTimelineSet","reEmitter","reEmit","RoomEvent","Timeline","TimelineReset","on","SlidingSyncEvent","Lifecycle","onLifecycle","bind","RoomData","onRoomData","extensions","ext","registerExtension","roomData","initial","debug","_createAndReEmitRoom","processRoomData","state","resp","err","SlidingSyncState","Complete","purgeNotifications","lastPos","updateSyncState","SyncState","Prepared","nextSyncToken","pos","catchingUp","fromCache","Syncing","RequestFinished","failCount","Error","Reconnecting","error","MatrixError","shouldAbortSync","syncLeftRooms","peek","stopPeeking","getSyncState","syncState","getSyncStateData","syncStateData","errcode","stop","ensureNameEvent","stateEvents","required_state","timelineEvents","timeline","ephemeralEvents","knownEvents","Set","getLiveTimeline","getEvents","add","oldEvents","newEvents","seenKnownEvent","i","recvEvent","has","unshift","addEventsToTimeline","prev_batch","encrypted","isRoomEncrypted","notification_count","setUnreadNotificationCount","NotificationCountType","Total","highlight_count","getUnreadNotificationCount","Highlight","invite_state","inviteStateEvents","processRoomEvents","recalculate","storeRoom","Room","updateMyMembership","setPaginationToken","EventTimeline","BACKWARDS","addEphemeralEvents","addNotifications","processRoomEvent","isState","RoomEncryption","onCryptoEvent","utils","promiseMapSeries","decryptCriticalEvents","stateEventList","timelineEventList","liveTimeline","timelineWasEmpty","ev","getPushActionsForEvent","initialiseState","oldState","setStateEvents","currentState","addLiveEvents","resolveInvites","getMembersWithMembership","member","_requestedProfileInfo","user","getUser","userId","promise","Promise","resolve","avatar_url","avatarUrl","displayname","displayName","getProfileInfo","then","info","inviteEvent","membership","setMembershipEvent","_err","retryImmediately","sync","isGuest","result","getPushRules","start","newState","old","Sync","timelineEvent","pushActions","notify","tweaks","highlight","notifEvents","sort","a","b","getTs","event","addLiveEvent","stateEvent","type","RoomName","state_key","event_id","sender","getUserId","origin_server_ts","Date","getTime","decrypt","mapper"],"sources":["../src/sliding-sync-sdk.ts"],"sourcesContent":["/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { NotificationCountType, Room, RoomEvent } from \"./models/room\";\nimport { logger } from './logger';\nimport * as utils from \"./utils\";\nimport { EventTimeline } from \"./models/event-timeline\";\nimport { ClientEvent, IStoredClientOpts, MatrixClient, PendingEventOrdering } from \"./client\";\nimport { ISyncStateData, SyncState, _createAndReEmitRoom } from \"./sync\";\nimport { MatrixEvent } from \"./models/event\";\nimport { Crypto } from \"./crypto\";\nimport { IMinimalEvent, IRoomEvent, IStateEvent, IStrippedState } from \"./sync-accumulator\";\nimport { MatrixError } from \"./http-api\";\nimport {\n    Extension,\n    ExtensionState,\n    MSC3575RoomData,\n    MSC3575SlidingSyncResponse,\n    SlidingSync,\n    SlidingSyncEvent,\n    SlidingSyncState,\n} from \"./sliding-sync\";\nimport { EventType, IPushRules } from \"./matrix\";\nimport { PushProcessor } from \"./pushprocessor\";\n\n// Number of consecutive failed syncs that will lead to a syncState of ERROR as opposed\n// to RECONNECTING. This is needed to inform the client of server issues when the\n// keepAlive is successful but the server /sync fails.\nconst FAILED_SYNC_ERROR_THRESHOLD = 3;\n\nclass ExtensionE2EE implements Extension {\n    constructor(private readonly crypto: Crypto) {}\n\n    public name(): string {\n        return \"e2ee\";\n    }\n\n    public when(): ExtensionState {\n        return ExtensionState.PreProcess;\n    }\n\n    public onRequest(isInitial: boolean): object {\n        if (!isInitial) {\n            return undefined;\n        }\n        return {\n            enabled: true, // this is sticky so only send it on the initial request\n        };\n    }\n\n    public async onResponse(data: object): Promise<void> {\n        // Handle device list updates\n        if (data[\"device_lists\"]) {\n            await this.crypto.handleDeviceListChanges({\n                oldSyncToken: \"yep\", // XXX need to do this so the device list changes get processed :(\n            }, data[\"device_lists\"]);\n        }\n\n        // Handle one_time_keys_count\n        if (data[\"device_one_time_keys_count\"]) {\n            const currentCount = data[\"device_one_time_keys_count\"].signed_curve25519 || 0;\n            this.crypto.updateOneTimeKeyCount(currentCount);\n        }\n        if (data[\"device_unused_fallback_key_types\"] ||\n                data[\"org.matrix.msc2732.device_unused_fallback_key_types\"]) {\n            // The presence of device_unused_fallback_key_types indicates that the\n            // server supports fallback keys. If there's no unused\n            // signed_curve25519 fallback key we need a new one.\n            const unusedFallbackKeys = data[\"device_unused_fallback_key_types\"] ||\n                data[\"org.matrix.msc2732.device_unused_fallback_key_types\"];\n            this.crypto.setNeedsNewFallback(\n                unusedFallbackKeys instanceof Array &&\n                !unusedFallbackKeys.includes(\"signed_curve25519\"),\n            );\n        }\n    }\n}\n\nclass ExtensionToDevice implements Extension {\n    private nextBatch?: string = null;\n\n    constructor(private readonly client: MatrixClient) {}\n\n    public name(): string {\n        return \"to_device\";\n    }\n\n    public when(): ExtensionState {\n        return ExtensionState.PreProcess;\n    }\n\n    public onRequest(isInitial: boolean): object {\n        const extReq = {\n            since: this.nextBatch !== null ? this.nextBatch : undefined,\n        };\n        if (isInitial) {\n            extReq[\"limit\"] = 100;\n            extReq[\"enabled\"] = true;\n        }\n        return extReq;\n    }\n\n    public async onResponse(data: object): Promise<void> {\n        const cancelledKeyVerificationTxns = [];\n        data[\"events\"] = data[\"events\"] || [];\n        data[\"events\"]\n            .map(this.client.getEventMapper())\n            .map((toDeviceEvent) => { // map is a cheap inline forEach\n                // We want to flag m.key.verification.start events as cancelled\n                // if there's an accompanying m.key.verification.cancel event, so\n                // we pull out the transaction IDs from the cancellation events\n                // so we can flag the verification events as cancelled in the loop\n                // below.\n                if (toDeviceEvent.getType() === \"m.key.verification.cancel\") {\n                    const txnId = toDeviceEvent.getContent()['transaction_id'];\n                    if (txnId) {\n                        cancelledKeyVerificationTxns.push(txnId);\n                    }\n                }\n\n                // as mentioned above, .map is a cheap inline forEach, so return\n                // the unmodified event.\n                return toDeviceEvent;\n            })\n            .forEach(\n                (toDeviceEvent) => {\n                    const content = toDeviceEvent.getContent();\n                    if (\n                        toDeviceEvent.getType() == \"m.room.message\" &&\n                        content.msgtype == \"m.bad.encrypted\"\n                    ) {\n                        // the mapper already logged a warning.\n                        logger.log(\n                            'Ignoring undecryptable to-device event from ' +\n                            toDeviceEvent.getSender(),\n                        );\n                        return;\n                    }\n\n                    if (toDeviceEvent.getType() === \"m.key.verification.start\"\n                        || toDeviceEvent.getType() === \"m.key.verification.request\") {\n                        const txnId = content['transaction_id'];\n                        if (cancelledKeyVerificationTxns.includes(txnId)) {\n                            toDeviceEvent.flagCancelled();\n                        }\n                    }\n\n                    this.client.emit(ClientEvent.ToDeviceEvent, toDeviceEvent);\n                },\n            );\n\n        this.nextBatch = data[\"next_batch\"];\n    }\n}\n\nclass ExtensionAccountData implements Extension {\n    constructor(private readonly client: MatrixClient) {}\n\n    public name(): string {\n        return \"account_data\";\n    }\n\n    public when(): ExtensionState {\n        return ExtensionState.PostProcess;\n    }\n\n    public onRequest(isInitial: boolean): object {\n        if (!isInitial) {\n            return undefined;\n        }\n        return {\n            enabled: true,\n        };\n    }\n\n    public onResponse(data: {global: object[], rooms: Record<string, object[]>}): void {\n        if (data.global && data.global.length > 0) {\n            this.processGlobalAccountData(data.global);\n        }\n\n        for (const roomId in data.rooms) {\n            const accountDataEvents = mapEvents(this.client, roomId, data.rooms[roomId]);\n            const room = this.client.getRoom(roomId);\n            if (!room) {\n                logger.warn(\"got account data for room but room doesn't exist on client:\", roomId);\n                continue;\n            }\n            room.addAccountData(accountDataEvents);\n            accountDataEvents.forEach((e) => {\n                this.client.emit(ClientEvent.Event, e);\n            });\n        }\n    }\n\n    private processGlobalAccountData(globalAccountData: object[]): void {\n        const events = mapEvents(this.client, undefined, globalAccountData);\n        const prevEventsMap = events.reduce((m, c) => {\n            m[c.getId()] = this.client.store.getAccountData(c.getType());\n            return m;\n        }, {});\n        this.client.store.storeAccountDataEvents(events);\n        events.forEach(\n            (accountDataEvent) => {\n                // Honour push rules that come down the sync stream but also\n                // honour push rules that were previously cached. Base rules\n                // will be updated when we receive push rules via getPushRules\n                // (see sync) before syncing over the network.\n                if (accountDataEvent.getType() === EventType.PushRules) {\n                    const rules = accountDataEvent.getContent<IPushRules>();\n                    this.client.pushRules = PushProcessor.rewriteDefaultRules(rules);\n                }\n                const prevEvent = prevEventsMap[accountDataEvent.getId()];\n                this.client.emit(ClientEvent.AccountData, accountDataEvent, prevEvent);\n                return accountDataEvent;\n            },\n        );\n    }\n}\n\n/**\n * A copy of SyncApi such that it can be used as a drop-in replacement for sync v2. For the actual\n * sliding sync API, see sliding-sync.ts or the class SlidingSync.\n */\nexport class SlidingSyncSdk {\n    private syncState: SyncState = null;\n    private syncStateData: ISyncStateData;\n    private lastPos: string = null;\n    private failCount = 0;\n    private notifEvents: MatrixEvent[] = []; // accumulator of sync events in the current sync response\n\n    constructor(\n        private readonly slidingSync: SlidingSync,\n        private readonly client: MatrixClient,\n        private readonly opts: Partial<IStoredClientOpts> = {},\n    ) {\n        this.opts.initialSyncLimit = this.opts.initialSyncLimit ?? 8;\n        this.opts.resolveInvitesToProfiles = this.opts.resolveInvitesToProfiles || false;\n        this.opts.pollTimeout = this.opts.pollTimeout || (30 * 1000);\n        this.opts.pendingEventOrdering = this.opts.pendingEventOrdering || PendingEventOrdering.Chronological;\n        this.opts.experimentalThreadSupport = this.opts.experimentalThreadSupport === true;\n\n        if (!opts.canResetEntireTimeline) {\n            opts.canResetEntireTimeline = (_roomId: string) => {\n                return false;\n            };\n        }\n\n        if (client.getNotifTimelineSet()) {\n            client.reEmitter.reEmit(client.getNotifTimelineSet(), [\n                RoomEvent.Timeline,\n                RoomEvent.TimelineReset,\n            ]);\n        }\n\n        this.slidingSync.on(SlidingSyncEvent.Lifecycle, this.onLifecycle.bind(this));\n        this.slidingSync.on(SlidingSyncEvent.RoomData, this.onRoomData.bind(this));\n        const extensions: Extension[] = [\n            new ExtensionToDevice(this.client),\n            new ExtensionAccountData(this.client),\n        ];\n        if (this.opts.crypto) {\n            extensions.push(\n                new ExtensionE2EE(this.opts.crypto),\n            );\n        }\n        extensions.forEach((ext) => {\n            this.slidingSync.registerExtension(ext);\n        });\n    }\n\n    private onRoomData(roomId: string, roomData: MSC3575RoomData): void {\n        let room = this.client.store.getRoom(roomId);\n        if (!room) {\n            if (!roomData.initial) {\n                logger.debug(\"initial flag not set but no stored room exists for room \", roomId, roomData);\n                return;\n            }\n            room = _createAndReEmitRoom(this.client, roomId, this.opts);\n        }\n        this.processRoomData(this.client, room, roomData);\n    }\n\n    private onLifecycle(state: SlidingSyncState, resp: MSC3575SlidingSyncResponse, err?: Error): void {\n        if (err) {\n            logger.debug(\"onLifecycle\", state, err);\n        }\n        switch (state) {\n            case SlidingSyncState.Complete:\n                this.purgeNotifications();\n                // Element won't stop showing the initial loading spinner unless we fire SyncState.Prepared\n                if (!this.lastPos) {\n                    this.updateSyncState(SyncState.Prepared, {\n                        oldSyncToken: this.lastPos,\n                        nextSyncToken: resp.pos,\n                        catchingUp: false,\n                        fromCache: false,\n                    });\n                }\n                // Conversely, Element won't show the room list unless there is at least 1x SyncState.Syncing\n                // so hence for the very first sync we will fire prepared then immediately syncing.\n                this.updateSyncState(SyncState.Syncing, {\n                    oldSyncToken: this.lastPos,\n                    nextSyncToken: resp.pos,\n                    catchingUp: false,\n                    fromCache: false,\n                });\n                this.lastPos = resp.pos;\n                break;\n            case SlidingSyncState.RequestFinished:\n                if (err) {\n                    this.failCount += 1;\n                    this.updateSyncState(\n                        this.failCount > FAILED_SYNC_ERROR_THRESHOLD ? SyncState.Error : SyncState.Reconnecting,\n                        {\n                            error: new MatrixError(err),\n                        },\n                    );\n                    if (this.shouldAbortSync(new MatrixError(err))) {\n                        return; // shouldAbortSync actually stops syncing too so we don't need to do anything.\n                    }\n                } else {\n                    this.failCount = 0;\n                }\n                break;\n        }\n    }\n\n    /**\n     * Sync rooms the user has left.\n     * @return {Promise} Resolved when they've been added to the store.\n     */\n    public async syncLeftRooms() {\n        return []; // TODO\n    }\n\n    /**\n     * Peek into a room. This will result in the room in question being synced so it\n     * is accessible via getRooms(). Live updates for the room will be provided.\n     * @param {string} roomId The room ID to peek into.\n     * @return {Promise} A promise which resolves once the room has been added to the\n     * store.\n     */\n    public async peek(_roomId: string): Promise<Room> {\n        return null; // TODO\n    }\n\n    /**\n     * Stop polling for updates in the peeked room. NOPs if there is no room being\n     * peeked.\n     */\n    public stopPeeking(): void {\n        // TODO\n    }\n\n    /**\n     * Returns the current state of this sync object\n     * @see module:client~MatrixClient#event:\"sync\"\n     * @return {?String}\n     */\n    public getSyncState(): SyncState {\n        return this.syncState;\n    }\n\n    /**\n     * Returns the additional data object associated with\n     * the current sync state, or null if there is no\n     * such data.\n     * Sync errors, if available, are put in the 'error' key of\n     * this object.\n     * @return {?Object}\n     */\n    public getSyncStateData(): ISyncStateData {\n        return this.syncStateData;\n    }\n\n    private shouldAbortSync(error: MatrixError): boolean {\n        if (error.errcode === \"M_UNKNOWN_TOKEN\") {\n            // The logout already happened, we just need to stop.\n            logger.warn(\"Token no longer valid - assuming logout\");\n            this.stop();\n            this.updateSyncState(SyncState.Error, { error });\n            return true;\n        }\n        return false;\n    }\n\n    private async processRoomData(client: MatrixClient, room: Room, roomData: MSC3575RoomData) {\n        roomData = ensureNameEvent(client, room.roomId, roomData);\n        const stateEvents = mapEvents(this.client, room.roomId, roomData.required_state);\n        // Prevent events from being decrypted ahead of time\n        // this helps large account to speed up faster\n        // room::decryptCriticalEvent is in charge of decrypting all the events\n        // required for a client to function properly\n        let timelineEvents = mapEvents(this.client, room.roomId, roomData.timeline, false);\n        const ephemeralEvents = []; // TODO this.mapSyncEventsFormat(joinObj.ephemeral);\n\n        // TODO: handle threaded / beacon events\n\n        if (roomData.initial) {\n            // we should not know about any of these timeline entries if this is a genuinely new room.\n            // If we do, then we've effectively done scrollback (e.g requesting timeline_limit: 1 for\n            // this room, then timeline_limit: 50).\n            const knownEvents = new Set<string>();\n            room.getLiveTimeline().getEvents().forEach((e) => {\n                knownEvents.add(e.getId());\n            });\n            // all unknown events BEFORE a known event must be scrollback e.g:\n            //       D E   <-- what we know\n            // A B C D E F <-- what we just received\n            // means:\n            // A B C       <-- scrollback\n            //       D E   <-- dupes\n            //           F <-- new event\n            // We bucket events based on if we have seen a known event yet.\n            const oldEvents: MatrixEvent[] = [];\n            const newEvents: MatrixEvent[] = [];\n            let seenKnownEvent = false;\n            for (let i = timelineEvents.length-1; i >= 0; i--) {\n                const recvEvent = timelineEvents[i];\n                if (knownEvents.has(recvEvent.getId())) {\n                    seenKnownEvent = true;\n                    continue; // don't include this event, it's a dupe\n                }\n                if (seenKnownEvent) {\n                    // old -> new\n                    oldEvents.push(recvEvent);\n                } else {\n                    // old -> new\n                    newEvents.unshift(recvEvent);\n                }\n            }\n            timelineEvents = newEvents;\n            if (oldEvents.length > 0) {\n                // old events are scrollback, insert them now\n                room.addEventsToTimeline(oldEvents, true, room.getLiveTimeline(), roomData.prev_batch);\n            }\n        }\n\n        const encrypted = this.client.isRoomEncrypted(room.roomId);\n        // we do this first so it's correct when any of the events fire\n        if (roomData.notification_count != null) {\n            room.setUnreadNotificationCount(\n                NotificationCountType.Total,\n                roomData.notification_count,\n            );\n        }\n\n        if (roomData.highlight_count != null) {\n            // We track unread notifications ourselves in encrypted rooms, so don't\n            // bother setting it here. We trust our calculations better than the\n            // server's for this case, and therefore will assume that our non-zero\n            // count is accurate.\n            if (!encrypted\n                || (encrypted && room.getUnreadNotificationCount(NotificationCountType.Highlight) <= 0)) {\n                room.setUnreadNotificationCount(\n                    NotificationCountType.Highlight,\n                    roomData.highlight_count,\n                );\n            }\n        }\n\n        if (roomData.invite_state) {\n            const inviteStateEvents = mapEvents(this.client, room.roomId, roomData.invite_state);\n            this.processRoomEvents(room, inviteStateEvents);\n            if (roomData.initial) {\n                room.recalculate();\n                this.client.store.storeRoom(room);\n                this.client.emit(ClientEvent.Room, room);\n            }\n            inviteStateEvents.forEach((e) => {\n                this.client.emit(ClientEvent.Event, e);\n            });\n            room.updateMyMembership(\"invite\");\n            return;\n        }\n\n        if (roomData.initial) {\n            // set the back-pagination token. Do this *before* adding any\n            // events so that clients can start back-paginating.\n            room.getLiveTimeline().setPaginationToken(\n                roomData.prev_batch, EventTimeline.BACKWARDS);\n        }\n\n        /* TODO\n        else if (roomData.limited) {\n\n            let limited = true;\n\n            // we've got a limited sync, so we *probably* have a gap in the\n            // timeline, so should reset. But we might have been peeking or\n            // paginating and already have some of the events, in which\n            // case we just want to append any subsequent events to the end\n            // of the existing timeline.\n            //\n            // This is particularly important in the case that we already have\n            // *all* of the events in the timeline - in that case, if we reset\n            // the timeline, we'll end up with an entirely empty timeline,\n            // which we'll try to paginate but not get any new events (which\n            // will stop us linking the empty timeline into the chain).\n            //\n            for (let i = timelineEvents.length - 1; i >= 0; i--) {\n                const eventId = timelineEvents[i].getId();\n                if (room.getTimelineForEvent(eventId)) {\n                    logger.debug(\"Already have event \" + eventId + \" in limited \" +\n                        \"sync - not resetting\");\n                    limited = false;\n\n                    // we might still be missing some of the events before i;\n                    // we don't want to be adding them to the end of the\n                    // timeline because that would put them out of order.\n                    timelineEvents.splice(0, i);\n\n                    // XXX: there's a problem here if the skipped part of the\n                    // timeline modifies the state set in stateEvents, because\n                    // we'll end up using the state from stateEvents rather\n                    // than the later state from timelineEvents. We probably\n                    // need to wind stateEvents forward over the events we're\n                    // skipping.\n                    break;\n                }\n            }\n\n            if (limited) {\n                room.resetLiveTimeline(\n                    roomData.prev_batch,\n                    null, // TODO this.opts.canResetEntireTimeline(room.roomId) ? null : syncEventData.oldSyncToken,\n                );\n\n                // We have to assume any gap in any timeline is\n                // reason to stop incrementally tracking notifications and\n                // reset the timeline.\n                this.client.resetNotifTimelineSet();\n            }\n        } */\n\n        this.processRoomEvents(room, stateEvents, timelineEvents, false);\n\n        // we deliberately don't add ephemeral events to the timeline\n        room.addEphemeralEvents(ephemeralEvents);\n\n        // local fields must be set before any async calls because call site assumes\n        // synchronous execution prior to emitting SlidingSyncState.Complete\n        room.updateMyMembership(\"join\");\n\n        room.recalculate();\n        if (roomData.initial) {\n            client.store.storeRoom(room);\n            client.emit(ClientEvent.Room, room);\n        }\n\n        // check if any timeline events should bing and add them to the notifEvents array:\n        // we'll purge this once we've fully processed the sync response\n        this.addNotifications(timelineEvents);\n\n        const processRoomEvent = async (e: MatrixEvent) => {\n            client.emit(ClientEvent.Event, e);\n            if (e.isState() && e.getType() == EventType.RoomEncryption && this.opts.crypto) {\n                await this.opts.crypto.onCryptoEvent(e);\n            }\n        };\n\n        await utils.promiseMapSeries(stateEvents, processRoomEvent);\n        await utils.promiseMapSeries(timelineEvents, processRoomEvent);\n        ephemeralEvents.forEach(function(e) {\n            client.emit(ClientEvent.Event, e);\n        });\n\n        // Decrypt only the last message in all rooms to make sure we can generate a preview\n        // And decrypt all events after the recorded read receipt to ensure an accurate\n        // notification count\n        room.decryptCriticalEvents();\n    }\n\n    /**\n     * @param {Room} room\n     * @param {MatrixEvent[]} stateEventList A list of state events. This is the state\n     * at the *START* of the timeline list if it is supplied.\n     * @param {MatrixEvent[]} [timelineEventList] A list of timeline events. Lower index\n     * @param {boolean} fromCache whether the sync response came from cache\n     * is earlier in time. Higher index is later.\n     */\n    private processRoomEvents(\n        room: Room,\n        stateEventList: MatrixEvent[],\n        timelineEventList?: MatrixEvent[],\n        fromCache = false,\n    ): void {\n        timelineEventList = timelineEventList || [];\n        stateEventList = stateEventList || [];\n\n        // If there are no events in the timeline yet, initialise it with\n        // the given state events\n        const liveTimeline = room.getLiveTimeline();\n        const timelineWasEmpty = liveTimeline.getEvents().length == 0;\n        if (timelineWasEmpty) {\n            // Passing these events into initialiseState will freeze them, so we need\n            // to compute and cache the push actions for them now, otherwise sync dies\n            // with an attempt to assign to read only property.\n            // XXX: This is pretty horrible and is assuming all sorts of behaviour from\n            // these functions that it shouldn't be. We should probably either store the\n            // push actions cache elsewhere so we can freeze MatrixEvents, or otherwise\n            // find some solution where MatrixEvents are immutable but allow for a cache\n            // field.\n            for (const ev of stateEventList) {\n                this.client.getPushActionsForEvent(ev);\n            }\n            liveTimeline.initialiseState(stateEventList);\n        }\n\n        // If the timeline wasn't empty, we process the state events here: they're\n        // defined as updates to the state before the start of the timeline, so this\n        // starts to roll the state forward.\n        // XXX: That's what we *should* do, but this can happen if we were previously\n        // peeking in a room, in which case we obviously do *not* want to add the\n        // state events here onto the end of the timeline. Historically, the js-sdk\n        // has just set these new state events on the old and new state. This seems\n        // very wrong because there could be events in the timeline that diverge the\n        // state, in which case this is going to leave things out of sync. However,\n        // for now I think it;s best to behave the same as the code has done previously.\n        if (!timelineWasEmpty) {\n            // XXX: As above, don't do this...\n            //room.addLiveEvents(stateEventList || []);\n            // Do this instead...\n            room.oldState.setStateEvents(stateEventList);\n            room.currentState.setStateEvents(stateEventList);\n        }\n\n        // execute the timeline events. This will continue to diverge the current state\n        // if the timeline has any state events in it.\n        // This also needs to be done before running push rules on the events as they need\n        // to be decorated with sender etc.\n        room.addLiveEvents(timelineEventList, {\n            fromCache: fromCache,\n        });\n\n        room.recalculate();\n\n        // resolve invites now we have set the latest state\n        this.resolveInvites(room);\n    }\n\n    private resolveInvites(room: Room): void {\n        if (!room || !this.opts.resolveInvitesToProfiles) {\n            return;\n        }\n        const client = this.client;\n        // For each invited room member we want to give them a displayname/avatar url\n        // if they have one (the m.room.member invites don't contain this).\n        room.getMembersWithMembership(\"invite\").forEach(function(member) {\n            if (member._requestedProfileInfo) return;\n            member._requestedProfileInfo = true;\n            // try to get a cached copy first.\n            const user = client.getUser(member.userId);\n            let promise;\n            if (user) {\n                promise = Promise.resolve({\n                    avatar_url: user.avatarUrl,\n                    displayname: user.displayName,\n                });\n            } else {\n                promise = client.getProfileInfo(member.userId);\n            }\n            promise.then(function(info) {\n                // slightly naughty by doctoring the invite event but this means all\n                // the code paths remain the same between invite/join display name stuff\n                // which is a worthy trade-off for some minor pollution.\n                const inviteEvent = member.events.member;\n                if (inviteEvent.getContent().membership !== \"invite\") {\n                    // between resolving and now they have since joined, so don't clobber\n                    return;\n                }\n                inviteEvent.getContent().avatar_url = info.avatar_url;\n                inviteEvent.getContent().displayname = info.displayname;\n                // fire listeners\n                member.setMembershipEvent(inviteEvent, room.currentState);\n            }, function(_err) {\n                // OH WELL.\n            });\n        });\n    }\n\n    public retryImmediately(): boolean {\n        return true;\n    }\n\n    /**\n     * Main entry point. Blocks until stop() is called.\n     */\n    public async sync() {\n        logger.debug(\"Sliding sync init loop\");\n\n        //   1) We need to get push rules so we can check if events should bing as we get\n        //      them from /sync.\n        while (!this.client.isGuest()) {\n            try {\n                logger.debug(\"Getting push rules...\");\n                const result = await this.client.getPushRules();\n                logger.debug(\"Got push rules\");\n                this.client.pushRules = result;\n                break;\n            } catch (err) {\n                logger.error(\"Getting push rules failed\", err);\n                if (this.shouldAbortSync(err)) {\n                    return;\n                }\n            }\n        }\n\n        // start syncing\n        await this.slidingSync.start();\n    }\n\n    /**\n     * Stops the sync object from syncing.\n     */\n    public stop(): void {\n        logger.debug(\"SyncApi.stop\");\n        this.slidingSync.stop();\n    }\n\n    /**\n     * Sets the sync state and emits an event to say so\n     * @param {String} newState The new state string\n     * @param {Object} data Object of additional data to emit in the event\n     */\n    private updateSyncState(newState: SyncState, data?: ISyncStateData): void {\n        const old = this.syncState;\n        this.syncState = newState;\n        this.syncStateData = data;\n        this.client.emit(ClientEvent.Sync, this.syncState, old, data);\n    }\n\n    /**\n     * Takes a list of timelineEvents and adds and adds to notifEvents\n     * as appropriate.\n     * This must be called after the room the events belong to has been stored.\n     *\n     * @param {MatrixEvent[]} [timelineEventList] A list of timeline events. Lower index\n     * is earlier in time. Higher index is later.\n     */\n    private addNotifications(timelineEventList: MatrixEvent[]): void {\n        // gather our notifications into this.notifEvents\n        if (!this.client.getNotifTimelineSet()) {\n            return;\n        }\n        for (const timelineEvent of timelineEventList) {\n            const pushActions = this.client.getPushActionsForEvent(timelineEvent);\n            if (pushActions && pushActions.notify &&\n                pushActions.tweaks && pushActions.tweaks.highlight) {\n                this.notifEvents.push(timelineEvent);\n            }\n        }\n    }\n\n    /**\n     * Purge any events in the notifEvents array. Used after a /sync has been complete.\n     * This should not be called at a per-room scope (e.g in onRoomData) because otherwise the ordering\n     * will be messed up e.g room A gets a bing, room B gets a newer bing, but both in the same /sync\n     * response. If we purge at a per-room scope then we could process room B before room A leading to\n     * room B appearing earlier in the notifications timeline, even though it has the higher origin_server_ts.\n     */\n    private purgeNotifications(): void {\n        this.notifEvents.sort(function(a, b) {\n            return a.getTs() - b.getTs();\n        });\n        this.notifEvents.forEach((event) => {\n            this.client.getNotifTimelineSet().addLiveEvent(event);\n        });\n        this.notifEvents = [];\n    }\n}\n\nfunction ensureNameEvent(client: MatrixClient, roomId: string, roomData: MSC3575RoomData): MSC3575RoomData {\n    // make sure m.room.name is in required_state if there is a name, replacing anything previously\n    // there if need be. This ensures clients transparently 'calculate' the right room name. Native\n    // sliding sync clients should just read the \"name\" field.\n    if (!roomData.name) {\n        return roomData;\n    }\n    for (const stateEvent of roomData.required_state) {\n        if (stateEvent.type === EventType.RoomName && stateEvent.state_key === \"\") {\n            stateEvent.content = {\n                name: roomData.name,\n            };\n            return roomData;\n        }\n    }\n    roomData.required_state.push({\n        event_id: \"$fake-sliding-sync-name-event-\" + roomId,\n        state_key: \"\",\n        type: EventType.RoomName,\n        content: {\n            name: roomData.name,\n        },\n        sender: client.getUserId(),\n        origin_server_ts: new Date().getTime(),\n    });\n    return roomData;\n}\n\n// Helper functions which set up JS SDK structs are below and are identical to the sync v2 counterparts,\n// just outside the class.\n\nfunction mapEvents(client: MatrixClient, roomId: string, events: object[], decrypt = true): MatrixEvent[] {\n    const mapper = client.getEventMapper({ decrypt });\n    return (events as Array<IStrippedState | IRoomEvent | IStateEvent | IMinimalEvent>).map(function(e) {\n        e[\"room_id\"] = roomId;\n        return mapper(e);\n    });\n}\n"],"mappings":"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"}