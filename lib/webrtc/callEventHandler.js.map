{"version":3,"file":"callEventHandler.js","names":["RING_GRACE_PERIOD","CallEventHandlerEvent","CallEventHandler","constructor","client","Map","currentEventBuffer","callEventBuffer","eventBufferPromiseChain","then","evaluateEventBuffer","event","push","content","getContent","call_id","nextSeqByCall","has","set","seq","undefined","nextSeq","get","toDeviceEventBuffers","buffer","index","findIndex","e","splice","callId","nextEvent","shift","calls","candidateEventsByCall","start","on","ClientEvent","Sync","onSync","RoomEvent","Timeline","onRoomTimeline","ToDeviceEvent","onToDeviceEvent","stop","removeListener","eventBuffer","Promise","all","map","decryptEventIfNeeded","callEvents","filter","eventType","getType","startsWith","ignoreCallIds","Set","EventType","CallAnswer","CallHangup","add","CallInvite","handleCallEvent","logger","error","emit","ReceivedVoipEvent","callRoomId","getRoomId","groupCallEventHandler","getGroupCallById","conf_id","room","roomId","groupCallId","type","senderId","getSender","call","opponentDeviceId","groupCall","warn","device_id","GroupCallEvent","Error","GroupCallUnknownDeviceError","dest_session_id","getSessionId","weSentTheEvent","credentials","userId","getDeviceId","getLocalAge","lifetime","state","CallState","Ended","log","invitee","getUserId","timeUntilTurnCresExpire","getTurnServersExpiry","Date","now","info","createNewMatrixCall","forceTURN","opponentSessionId","sender_session_id","initWithInvite","CallError","code","GroupCallErrorCode","UnknownDevice","ev","onRemoteIceCandidatesReceived","existingCall","thisCall","values","isCalling","WaitLocalMedia","CreateOffer","InviteSent","includes","direction","CallDirection","Outbound","getOpponentMember","replacedBy","hangup","CallErrorCode","Replaced","Incoming","CallCandidates","CallReject","initWithHangup","onHangupReceived","onRejectReceived","delete","hasPeerConnection","getId","party_id","ourPartyId","Ringing","onAnsweredElsewhere","onAnswerReceived","CallSelectAnswer","onSelectAnswerReceived","CallNegotiate","onNegotiateReceived","CallAssertedIdentity","CallAssertedIdentityPrefix","onAssertedIdentityReceived","CallSDPStreamMetadataChanged","CallSDPStreamMetadataChangedPrefix","onSDPStreamMetadataChangedReceived"],"sources":["../../src/webrtc/callEventHandler.ts"],"sourcesContent":["/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { MatrixEvent } from \"../models/event\";\nimport { logger } from \"../logger\";\nimport { CallDirection, CallError, CallErrorCode, CallState, createNewMatrixCall, MatrixCall } from \"./call\";\nimport { EventType } from \"../@types/event\";\nimport { ClientEvent, MatrixClient } from \"../client\";\nimport { MCallAnswer, MCallHangupReject } from \"./callEventTypes\";\nimport { GroupCall, GroupCallErrorCode, GroupCallEvent, GroupCallUnknownDeviceError } from \"./groupCall\";\nimport { RoomEvent } from \"../models/room\";\n\n// Don't ring unless we'd be ringing for at least 3 seconds: the user needs some\n// time to press the 'accept' button\nconst RING_GRACE_PERIOD = 3000;\n\nexport enum CallEventHandlerEvent {\n    Incoming = \"Call.incoming\",\n}\n\nexport type CallEventHandlerEventHandlerMap = {\n    /**\n     * Fires whenever an incoming call arrives.\n     * @param call - The incoming call.\n     * @example\n     * ```\n     * matrixClient.on(\"Call.incoming\", function(call){\n     *   call.answer(); // auto-answer\n     * });\n     * ```\n     */\n    [CallEventHandlerEvent.Incoming]: (call: MatrixCall) => void;\n};\n\nexport class CallEventHandler {\n    // XXX: Most of these are only public because of the tests\n    public calls: Map<string, MatrixCall>;\n    public callEventBuffer: MatrixEvent[];\n    public nextSeqByCall: Map<string, number> = new Map();\n    public toDeviceEventBuffers: Map<string, Array<MatrixEvent>> = new Map();\n\n    private client: MatrixClient;\n    private candidateEventsByCall: Map<string, Array<MatrixEvent>>;\n    private eventBufferPromiseChain?: Promise<void>;\n\n    public constructor(client: MatrixClient) {\n        this.client = client;\n        this.calls = new Map<string, MatrixCall>();\n        // The sync code always emits one event at a time, so it will patiently\n        // wait for us to finish processing a call invite before delivering the\n        // next event, even if that next event is a hangup. We therefore accumulate\n        // all our call events and then process them on the 'sync' event, ie.\n        // each time a sync has completed. This way, we can avoid emitting incoming\n        // call events if we get both the invite and answer/hangup in the same sync.\n        // This happens quite often, eg. replaying sync from storage, catchup sync\n        // after loading and after we've been offline for a bit.\n        this.callEventBuffer = [];\n        this.candidateEventsByCall = new Map<string, Array<MatrixEvent>>();\n    }\n\n    public start(): void {\n        this.client.on(ClientEvent.Sync, this.onSync);\n        this.client.on(RoomEvent.Timeline, this.onRoomTimeline);\n        this.client.on(ClientEvent.ToDeviceEvent, this.onToDeviceEvent);\n    }\n\n    public stop(): void {\n        this.client.removeListener(ClientEvent.Sync, this.onSync);\n        this.client.removeListener(RoomEvent.Timeline, this.onRoomTimeline);\n        this.client.removeListener(ClientEvent.ToDeviceEvent, this.onToDeviceEvent);\n    }\n\n    private onSync = (): void => {\n        // Process the current event buffer and start queuing into a new one.\n        const currentEventBuffer = this.callEventBuffer;\n        this.callEventBuffer = [];\n\n        // Ensure correct ordering by only processing this queue after the previous one has finished processing\n        if (this.eventBufferPromiseChain) {\n            this.eventBufferPromiseChain = this.eventBufferPromiseChain.then(() =>\n                this.evaluateEventBuffer(currentEventBuffer),\n            );\n        } else {\n            this.eventBufferPromiseChain = this.evaluateEventBuffer(currentEventBuffer);\n        }\n    };\n\n    private async evaluateEventBuffer(eventBuffer: MatrixEvent[]): Promise<void> {\n        await Promise.all(eventBuffer.map((event) => this.client.decryptEventIfNeeded(event)));\n\n        const callEvents = eventBuffer.filter((event) => {\n            const eventType = event.getType();\n            return eventType.startsWith(\"m.call.\") || eventType.startsWith(\"org.matrix.call.\");\n        });\n\n        const ignoreCallIds = new Set<string>();\n\n        // inspect the buffer and mark all calls which have been answered\n        // or hung up before passing them to the call event handler.\n        for (const event of callEvents) {\n            const eventType = event.getType();\n\n            if (eventType === EventType.CallAnswer || eventType === EventType.CallHangup) {\n                ignoreCallIds.add(event.getContent().call_id);\n            }\n        }\n\n        // Process call events in the order that they were received\n        for (const event of callEvents) {\n            const eventType = event.getType();\n            const callId = event.getContent().call_id;\n\n            if (eventType === EventType.CallInvite && ignoreCallIds.has(callId)) {\n                // This call has previously been answered or hung up: ignore it\n                continue;\n            }\n\n            try {\n                await this.handleCallEvent(event);\n            } catch (e) {\n                logger.error(\"Caught exception handling call event\", e);\n            }\n        }\n    }\n\n    private onRoomTimeline = (event: MatrixEvent): void => {\n        this.callEventBuffer.push(event);\n    };\n\n    private onToDeviceEvent = (event: MatrixEvent): void => {\n        const content = event.getContent();\n\n        if (!content.call_id) {\n            this.callEventBuffer.push(event);\n            return;\n        }\n\n        if (!this.nextSeqByCall.has(content.call_id)) {\n            this.nextSeqByCall.set(content.call_id, 0);\n        }\n\n        if (content.seq === undefined) {\n            this.callEventBuffer.push(event);\n            return;\n        }\n\n        const nextSeq = this.nextSeqByCall.get(content.call_id) || 0;\n\n        if (content.seq !== nextSeq) {\n            if (!this.toDeviceEventBuffers.has(content.call_id)) {\n                this.toDeviceEventBuffers.set(content.call_id, []);\n            }\n\n            const buffer = this.toDeviceEventBuffers.get(content.call_id)!;\n            const index = buffer.findIndex((e) => e.getContent().seq > content.seq);\n\n            if (index === -1) {\n                buffer.push(event);\n            } else {\n                buffer.splice(index, 0, event);\n            }\n        } else {\n            const callId = content.call_id;\n            this.callEventBuffer.push(event);\n            this.nextSeqByCall.set(callId, content.seq + 1);\n\n            const buffer = this.toDeviceEventBuffers.get(callId);\n\n            let nextEvent = buffer && buffer.shift();\n\n            while (nextEvent && nextEvent.getContent().seq === this.nextSeqByCall.get(callId)) {\n                this.callEventBuffer.push(nextEvent);\n                this.nextSeqByCall.set(callId, nextEvent.getContent().seq + 1);\n                nextEvent = buffer!.shift();\n            }\n        }\n    };\n\n    private async handleCallEvent(event: MatrixEvent): Promise<void> {\n        this.client.emit(ClientEvent.ReceivedVoipEvent, event);\n\n        const content = event.getContent();\n        const callRoomId =\n            event.getRoomId() || this.client.groupCallEventHandler!.getGroupCallById(content.conf_id)?.room?.roomId;\n        const groupCallId = content.conf_id;\n        const type = event.getType() as EventType;\n        const senderId = event.getSender()!;\n        let call = content.call_id ? this.calls.get(content.call_id) : undefined;\n\n        let opponentDeviceId: string | undefined;\n\n        let groupCall: GroupCall | undefined;\n        if (groupCallId) {\n            groupCall = this.client.groupCallEventHandler!.getGroupCallById(groupCallId);\n\n            if (!groupCall) {\n                logger.warn(`Cannot find a group call ${groupCallId} for event ${type}. Ignoring event.`);\n                return;\n            }\n\n            opponentDeviceId = content.device_id;\n\n            if (!opponentDeviceId) {\n                logger.warn(`Cannot find a device id for ${senderId}. Ignoring event.`);\n                groupCall.emit(GroupCallEvent.Error, new GroupCallUnknownDeviceError(senderId));\n                return;\n            }\n\n            if (content.dest_session_id !== this.client.getSessionId()) {\n                logger.warn(\"Call event does not match current session id, ignoring.\");\n                return;\n            }\n        }\n\n        const weSentTheEvent =\n            senderId === this.client.credentials.userId &&\n            (opponentDeviceId === undefined || opponentDeviceId === this.client.getDeviceId()!);\n\n        if (!callRoomId) return;\n\n        if (type === EventType.CallInvite) {\n            // ignore invites you send\n            if (weSentTheEvent) return;\n            // expired call\n            if (event.getLocalAge() > content.lifetime - RING_GRACE_PERIOD) return;\n            // stale/old invite event\n            if (call && call.state === CallState.Ended) return;\n\n            if (call) {\n                logger.log(\n                    `WARN: Already have a MatrixCall with id ${content.call_id} but got an ` + `invite. Clobbering.`,\n                );\n            }\n\n            if (content.invitee && content.invitee !== this.client.getUserId()) {\n                return; // This invite was meant for another user in the room\n            }\n\n            const timeUntilTurnCresExpire = (this.client.getTurnServersExpiry() ?? 0) - Date.now();\n            logger.info(\"Current turn creds expire in \" + timeUntilTurnCresExpire + \" ms\");\n            call =\n                createNewMatrixCall(this.client, callRoomId, {\n                    forceTURN: this.client.forceTURN,\n                    opponentDeviceId,\n                    groupCallId,\n                    opponentSessionId: content.sender_session_id,\n                }) ?? undefined;\n            if (!call) {\n                logger.log(\"Incoming call ID \" + content.call_id + \" but this client \" + \"doesn't support WebRTC\");\n                // don't hang up the call: there could be other clients\n                // connected that do support WebRTC and declining the\n                // the call on their behalf would be really annoying.\n                return;\n            }\n\n            call.callId = content.call_id;\n            try {\n                await call.initWithInvite(event);\n            } catch (e) {\n                if (e instanceof CallError) {\n                    if (e.code === GroupCallErrorCode.UnknownDevice) {\n                        groupCall?.emit(GroupCallEvent.Error, e);\n                    } else {\n                        logger.error(e);\n                    }\n                }\n            }\n            this.calls.set(call.callId, call);\n\n            // if we stashed candidate events for that call ID, play them back now\n            if (this.candidateEventsByCall.get(call.callId)) {\n                for (const ev of this.candidateEventsByCall.get(call.callId)!) {\n                    call.onRemoteIceCandidatesReceived(ev);\n                }\n            }\n\n            // Were we trying to call that user (room)?\n            let existingCall: MatrixCall | undefined;\n            for (const thisCall of this.calls.values()) {\n                const isCalling = [CallState.WaitLocalMedia, CallState.CreateOffer, CallState.InviteSent].includes(\n                    thisCall.state,\n                );\n\n                if (\n                    call.roomId === thisCall.roomId &&\n                    thisCall.direction === CallDirection.Outbound &&\n                    call.getOpponentMember()?.userId === thisCall.invitee &&\n                    isCalling\n                ) {\n                    existingCall = thisCall;\n                    break;\n                }\n            }\n\n            if (existingCall) {\n                if (existingCall.callId > call.callId) {\n                    logger.log(\n                        \"Glare detected: answering incoming call \" +\n                            call.callId +\n                            \" and canceling outgoing call \" +\n                            existingCall.callId,\n                    );\n                    existingCall.replacedBy(call);\n                } else {\n                    logger.log(\n                        \"Glare detected: rejecting incoming call \" +\n                            call.callId +\n                            \" and keeping outgoing call \" +\n                            existingCall.callId,\n                    );\n                    call.hangup(CallErrorCode.Replaced, true);\n                }\n            } else {\n                this.client.emit(CallEventHandlerEvent.Incoming, call);\n            }\n            return;\n        } else if (type === EventType.CallCandidates) {\n            if (weSentTheEvent) return;\n\n            if (!call) {\n                // store the candidates; we may get a call eventually.\n                if (!this.candidateEventsByCall.has(content.call_id)) {\n                    this.candidateEventsByCall.set(content.call_id, []);\n                }\n                this.candidateEventsByCall.get(content.call_id)!.push(event);\n            } else {\n                call.onRemoteIceCandidatesReceived(event);\n            }\n            return;\n        } else if ([EventType.CallHangup, EventType.CallReject].includes(type)) {\n            // Note that we also observe our own hangups here so we can see\n            // if we've already rejected a call that would otherwise be valid\n            if (!call) {\n                // if not live, store the fact that the call has ended because\n                // we're probably getting events backwards so\n                // the hangup will come before the invite\n                call =\n                    createNewMatrixCall(this.client, callRoomId, {\n                        opponentDeviceId,\n                        opponentSessionId: content.sender_session_id,\n                    }) ?? undefined;\n                if (call) {\n                    call.callId = content.call_id;\n                    call.initWithHangup(event);\n                    this.calls.set(content.call_id, call);\n                }\n            } else {\n                if (call.state !== CallState.Ended) {\n                    if (type === EventType.CallHangup) {\n                        call.onHangupReceived(content as MCallHangupReject);\n                    } else {\n                        call.onRejectReceived(content as MCallHangupReject);\n                    }\n\n                    // @ts-expect-error typescript thinks the state can't be 'ended' because we're\n                    // inside the if block where it wasn't, but it could have changed because\n                    // on[Hangup|Reject]Received are side-effecty.\n                    if (call.state === CallState.Ended) this.calls.delete(content.call_id);\n                }\n            }\n            return;\n        }\n\n        // The following events need a call and a peer connection\n        if (!call || !call.hasPeerConnection) {\n            logger.info(`Discarding possible call event ${event.getId()} as we don't have a call/peerConn`, type);\n            return;\n        }\n        // Ignore remote echo\n        if (event.getContent().party_id === call.ourPartyId) return;\n\n        switch (type) {\n            case EventType.CallAnswer:\n                if (weSentTheEvent) {\n                    if (call.state === CallState.Ringing) {\n                        call.onAnsweredElsewhere(content as MCallAnswer);\n                    }\n                } else {\n                    call.onAnswerReceived(event);\n                }\n                break;\n            case EventType.CallSelectAnswer:\n                call.onSelectAnswerReceived(event);\n                break;\n\n            case EventType.CallNegotiate:\n                call.onNegotiateReceived(event);\n                break;\n\n            case EventType.CallAssertedIdentity:\n            case EventType.CallAssertedIdentityPrefix:\n                call.onAssertedIdentityReceived(event);\n                break;\n\n            case EventType.CallSDPStreamMetadataChanged:\n            case EventType.CallSDPStreamMetadataChangedPrefix:\n                call.onSDPStreamMetadataChangedReceived(event);\n                break;\n        }\n    }\n}\n"],"mappings":"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"}