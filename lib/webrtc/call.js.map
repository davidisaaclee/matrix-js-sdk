{"version":3,"file":"call.js","names":["MediaType","CodecName","CallState","CallType","CallDirection","CallParty","CallEvent","CallErrorCode","VOIP_PROTO_VERSION","FALLBACK_ICE_SERVER","CALL_TIMEOUT_MS","CALL_LENGTH_INTERVAL","ICE_DISCONNECTED_TIMEOUT","CallError","Error","constructor","code","msg","err","genCallID","Date","now","toString","randomString","getCodecParamMods","isPtt","mods","mediaType","codec","enableDtx","maxAverageBitrate","undefined","getTransceiverKey","purpose","kind","MatrixCall","TypedEventEmitter","opts","Fledgling","Map","event","candidate","candidatesEnded","logger","warn","debug","callId","sdpMid","callHasEnded","queueCandidate","peerConn","iceGatheringState","error","emit","LocalOfferFailed","terminate","Local","successor","getUserMediaFailed","NoUserMedia","iceConnectionState","includes","clearTimeout","iceDisconnectedTimeout","state","Connected","callLengthInterval","callStartTime","setInterval","LengthChanged","Math","round","restartIce","info","hangup","IceFailed","setTimeout","Connecting","feed","getRemoteFeeds","setAudioVideoMuted","signalingState","ev","streams","length","track","stream","pushRemoteFeed","removeTrackListeners","has","onRemoveTrack","getTracks","id","deleteFeedByStream","removeEventListener","delete","addEventListener","set","DataChannel","channel","CreateOffer","opponentVersion","queueGotLocalOffer","partyIdMatches","Ringing","Remote","reason","UserHangup","party_id","opponentPartyId","shouldTerminate","InviteSent","direction","Inbound","AnsweredElsewhere","roomId","invitee","client","deviceId","forceTURN","ourPartyId","opponentDeviceId","opponentSessionId","groupCallId","turnServers","isFallbackICEServerAllowed","push","urls","server","utils","checkObjectHasKeys","placeVoiceCall","placeCall","placeVideoCall","createDataChannel","label","options","dataChannel","getOpponentMember","opponentMember","getOpponentDeviceId","getOpponentSessionId","opponentCanBeTransferred","Boolean","opponentCaps","opponentSupportsDTMF","getRemoteAssertedIdentity","remoteAssertedIdentity","_state","oldState","State","type","hasLocalUserMediaVideoTrack","hasRemoteUserMediaVideoTrack","Video","Voice","localUsermediaStream","getVideoTracks","some","SDPStreamMetadataPurpose","Usermedia","hasLocalUserMediaAudioTrack","getAudioTracks","hasRemoteUserMediaAudioTrack","localUsermediaFeed","getLocalFeeds","find","localScreensharingFeed","Screenshare","localScreensharingStream","remoteUsermediaFeed","remoteScreensharingFeed","remoteUsermediaStream","remoteScreensharingStream","getFeedByStreamId","streamId","getFeeds","feeds","filter","isLocal","initOpponentCrypto","getUseE2eForGroupCall","isCryptoEnabled","opponentDeviceInfo","DeviceInfo","crypto","userId","deviceInfoMap","deviceList","downloadKeys","GroupCallUnknownDeviceError","getLocalSDPStreamMetadata","updateStreamIds","metadata","localFeed","sdpMetadataStreamId","audio_muted","isAudioMuted","video_muted","isVideoMuted","noIncomingFeeds","opponentSupportsSDPStreamMetadata","pushRemoteFeedWithoutMetadata","remoteSDPStreamMetadata","audioMuted","videoMuted","CallFeed","call","FeedsChanged","active","oldRemoteStream","pushNewLocalFeed","addToPeerConnection","getUserId","setTracksEnabled","pushLocalFeed","callFeed","enabled","tKey","transceivers","transceiver","get","sender","setStreams","replaceTrack","newSender","addTrack","newTransciever","getTransceivers","t","removeLocalFeed","audioTransceiverKey","videoTransceiverKey","transceiverKey","removeTrack","getMediaHandler","stopScreensharingStream","deleteFeed","deleteAllFeeds","dispose","splice","indexOf","getCurrentCallStats","callStatsAtEnd","collectCallStats","statsReport","getStats","stats","forEach","item","initWithInvite","invite","getContent","haveTurnCreds","checkTurnServers","sdpStreamMetadata","SDPStreamMetadataKey","updateRemoteSDPStreamMetadata","createPeerConnection","chooseOpponent","setRemoteDescription","offer","addBufferedIceCandidates","e","SetRemoteDescription","remoteStream","getLocalAge","ringingTimer","hangupParty","Ended","stopAllMedia","close","Hangup","lifetime","onState","off","on","initWithHangup","shouldAnswerWithMediaType","wantedValue","valueOfTheOtherSide","isNullOrUndefined","answer","audio","video","inviteOrAnswerSent","waitForLocalAVStream","prevState","answerWithAudio","answerWithVideo","WaitLocalMedia","getUserMediaStream","usermediaFeed","getDeviceId","answerWithCallFeeds","callFeeds","queueGotCallFeedsForAnswer","replacedBy","newCall","Outbound","map","clone","Replaced","suppressEvent","content","sendVoipEvent","EventType","CallHangup","reject","CallReject","upgradeCall","getAudio","getVideo","updateLocalUsermediaStream","isScreensharing","setScreensharingEnabled","setScreensharingEnabledWithoutMetadataSupport","getScreensharingStream","audioTransceiver","videoTransceiver","forceAudio","forceVideo","audioEnabled","remoteOnHold","videoEnabled","log","stop","oldSender","added","setLocalVideoMuted","muted","hasVideoDevice","isLocalVideoMuted","updateMuteStatus","sendMetadataUpdate","setMicrophoneMuted","hasAudioDevice","isMicrophoneMuted","isRemoteOnHold","setRemoteOnHold","onHold","RemoteHoldUnhold","isLocalOnHold","callOnHold","trackOnHold","currentDirection","sendDtmfDigit","digit","getSenders","dtmf","insertDTMF","micShouldBeMuted","vidShouldBeMuted","CallSDPStreamMetadataChangedPrefix","gotCallFeedsForInvite","requestScreenshareFeed","addTransceiver","sendAnswer","answerContent","sdp","localDescription","capabilities","supportsCallTransfer","discardCount","discardDuplicateCandidates","CallAnswer","MatrixError","cancelPendingEvent","SendAnswer","message","name","UnknownDevices","sendCandidateQueue","responsePromiseChain","then","gotCallFeedsForAnswer","mungeSdp","description","parseSdp","media","payloadTypeToCodecMap","codecToPayloadTypeMap","rtp","payload","mod","extraconfig","found","fmtp","config","join","writeSdp","createOffer","createAnswer","CreateAnswer","getRidOfRTXCodecs","setLocalDescription","Promise","resolve","SetLocalDescription","onRemoteIceCandidatesReceived","candidates","fromPartyId","version","bufferedCandidates","remoteCandidateBuffer","addIceCandidates","onAnswerReceived","CallSelectAnswer","selected_party_id","onSelectAnswerReceived","selectedPartyId","onNegotiateReceived","polite","offerCollision","makingOffer","ignoreOffer","prevLocalOnHold","CallNegotiate","toJSON","newLocalOnHold","LocalHoldUnhold","HoldUnhold","recursivelyAssign","onSDPStreamMetadataChangedReceived","onAssertedIdentityReceived","asserted_identity","displayName","display_name","AssertedIdentityChanged","wrappedGotLocalOffer","gotLocalOffer","getLocalOfferFailed","eventType","CallInvite","SignallingFailed","SendInvite","inviteTimeout","InviteTimeout","RTCRtpReceiver","getCapabilities","RTCRtpSender","recvCodecs","codecs","sendCodecs","mimeType","rtxCodecIndex","screenshareVideoTransceiver","setCodecPreferences","realContent","Object","assign","call_id","conf_id","toDeviceSeq","device_id","sender_session_id","getSessionId","dest_session_id","seq","ToDeviceMessageId","uuidv4","SendVoipEvent","encryptAndSendToDevices","deviceInfo","sendToDevice","sendEvent","candidateSendQueue","delay","candidateSendTries","newQueue","i","transfer","targetUserId","profileInfo","getProfileInfo","replacementId","body","replacement_id","target_user","displayname","avatar_url","create_call","CallReplaces","Transfered","transferToCall","transferTargetCall","targetProfileInfo","opponentUserId","transfereeProfileInfo","newCallId","bodyToTransferTarget","await_call","bodyToTransferee","hangupReason","shouldEmit","clearInterval","listener","clear","callEventHandler","calls","stopUserMediaStream","checkForErrorListener","listeners","EventEmitterEvents","CallCandidates","delayMs","pow","placeCallWithCallFeeds","pc","window","RTCPeerConnection","iceTransportPolicy","iceServers","iceCandidatePoolSize","bundlePolicy","onIceConnectionStateChanged","onSignallingStateChanged","gotLocalIceCandidate","onIceGatheringStateChange","onTrack","onNegotiationNeeded","onDataChannel","msgPartyId","getRoom","getMember","getSender","sdpMLineIndex","addIceCandidate","hasPeerConnection","tracks","supportsMatrixCall","document","supported","RTCSessionDescription","RTCIceCandidate","navigator","mediaDevices","process","env","NODE_ENV","createNewMatrixCall","optionsForceTURN","getTurnServers","reEmitter","reEmit","values"],"sources":["../../src/webrtc/call.ts"],"sourcesContent":["/*\nCopyright 2015, 2016 OpenMarket Ltd\nCopyright 2017 New Vector Ltd\nCopyright 2019, 2020 The Matrix.org Foundation C.I.C.\nCopyright 2021 - 2022 Å imon Brandner <simon.bra.ag@gmail.com>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * This is an internal module. See {@link createNewMatrixCall} for the public API.\n */\n\nimport { v4 as uuidv4 } from \"uuid\";\nimport { parse as parseSdp, write as writeSdp } from \"sdp-transform\";\n\nimport { logger } from \"../logger\";\nimport * as utils from \"../utils\";\nimport { IContent, MatrixEvent } from \"../models/event\";\nimport { EventType, ToDeviceMessageId } from \"../@types/event\";\nimport { RoomMember } from \"../models/room-member\";\nimport { randomString } from \"../randomstring\";\nimport {\n    MCallReplacesEvent,\n    MCallAnswer,\n    MCallInviteNegotiate,\n    CallCapabilities,\n    SDPStreamMetadataPurpose,\n    SDPStreamMetadata,\n    SDPStreamMetadataKey,\n    MCallSDPStreamMetadataChanged,\n    MCallSelectAnswer,\n    MCAllAssertedIdentity,\n    MCallCandidates,\n    MCallBase,\n    MCallHangupReject,\n} from \"./callEventTypes\";\nimport { CallFeed } from \"./callFeed\";\nimport { MatrixClient } from \"../client\";\nimport { EventEmitterEvents, TypedEventEmitter } from \"../models/typed-event-emitter\";\nimport { DeviceInfo } from \"../crypto/deviceinfo\";\nimport { GroupCallUnknownDeviceError } from \"./groupCall\";\nimport { IScreensharingOpts } from \"./mediaHandler\";\nimport { MatrixError } from \"../http-api\";\n\ninterface CallOpts {\n    // The room ID for this call.\n    roomId?: string;\n    invitee?: string;\n    // The Matrix Client instance to send events to.\n    client: MatrixClient;\n    /**\n     * Whether relay through TURN should be forced.\n     * @deprecated use opts.forceTURN when creating the matrix client\n     * since it's only possible to set this option on outbound calls.\n     */\n    forceTURN?: boolean;\n    // A list of TURN servers.\n    turnServers?: Array<TurnServer>;\n    opponentDeviceId?: string;\n    opponentSessionId?: string;\n    groupCallId?: string;\n}\n\ninterface TurnServer {\n    urls: Array<string>;\n    username?: string;\n    password?: string;\n    ttl?: number;\n}\n\ninterface AssertedIdentity {\n    id: string;\n    displayName: string;\n}\n\nenum MediaType {\n    AUDIO = \"audio\",\n    VIDEO = \"video\",\n}\n\nenum CodecName {\n    OPUS = \"opus\",\n    // add more as needed\n}\n\n// Used internally to specify modifications to codec parameters in SDP\ninterface CodecParamsMod {\n    mediaType: MediaType;\n    codec: CodecName;\n    enableDtx?: boolean; // true to enable discontinuous transmission, false to disable, undefined to leave as-is\n    maxAverageBitrate?: number; // sets the max average bitrate, or undefined to leave as-is\n}\n\nexport enum CallState {\n    Fledgling = \"fledgling\",\n    InviteSent = \"invite_sent\",\n    WaitLocalMedia = \"wait_local_media\",\n    CreateOffer = \"create_offer\",\n    CreateAnswer = \"create_answer\",\n    Connecting = \"connecting\",\n    Connected = \"connected\",\n    Ringing = \"ringing\",\n    Ended = \"ended\",\n}\n\nexport enum CallType {\n    Voice = \"voice\",\n    Video = \"video\",\n}\n\nexport enum CallDirection {\n    Inbound = \"inbound\",\n    Outbound = \"outbound\",\n}\n\nexport enum CallParty {\n    Local = \"local\",\n    Remote = \"remote\",\n}\n\nexport enum CallEvent {\n    Hangup = \"hangup\",\n    State = \"state\",\n    Error = \"error\",\n    Replaced = \"replaced\",\n\n    // The value of isLocalOnHold() has changed\n    LocalHoldUnhold = \"local_hold_unhold\",\n    // The value of isRemoteOnHold() has changed\n    RemoteHoldUnhold = \"remote_hold_unhold\",\n    // backwards compat alias for LocalHoldUnhold: remove in a major version bump\n    HoldUnhold = \"hold_unhold\",\n    // Feeds have changed\n    FeedsChanged = \"feeds_changed\",\n\n    AssertedIdentityChanged = \"asserted_identity_changed\",\n\n    LengthChanged = \"length_changed\",\n\n    DataChannel = \"datachannel\",\n\n    SendVoipEvent = \"send_voip_event\",\n}\n\nexport enum CallErrorCode {\n    /** The user chose to end the call */\n    UserHangup = \"user_hangup\",\n\n    /** An error code when the local client failed to create an offer. */\n    LocalOfferFailed = \"local_offer_failed\",\n    /**\n     * An error code when there is no local mic/camera to use. This may be because\n     * the hardware isn't plugged in, or the user has explicitly denied access.\n     */\n    NoUserMedia = \"no_user_media\",\n\n    /**\n     * Error code used when a call event failed to send\n     * because unknown devices were present in the room\n     */\n    UnknownDevices = \"unknown_devices\",\n\n    /**\n     * Error code used when we fail to send the invite\n     * for some reason other than there being unknown devices\n     */\n    SendInvite = \"send_invite\",\n\n    /**\n     * An answer could not be created\n     */\n    CreateAnswer = \"create_answer\",\n\n    /**\n     * An offer could not be created\n     */\n    CreateOffer = \"create_offer\",\n\n    /**\n     * Error code used when we fail to send the answer\n     * for some reason other than there being unknown devices\n     */\n    SendAnswer = \"send_answer\",\n\n    /**\n     * The session description from the other side could not be set\n     */\n    SetRemoteDescription = \"set_remote_description\",\n\n    /**\n     * The session description from this side could not be set\n     */\n    SetLocalDescription = \"set_local_description\",\n\n    /**\n     * A different device answered the call\n     */\n    AnsweredElsewhere = \"answered_elsewhere\",\n\n    /**\n     * No media connection could be established to the other party\n     */\n    IceFailed = \"ice_failed\",\n\n    /**\n     * The invite timed out whilst waiting for an answer\n     */\n    InviteTimeout = \"invite_timeout\",\n\n    /**\n     * The call was replaced by another call\n     */\n    Replaced = \"replaced\",\n\n    /**\n     * Signalling for the call could not be sent (other than the initial invite)\n     */\n    SignallingFailed = \"signalling_timeout\",\n\n    /**\n     * The remote party is busy\n     */\n    UserBusy = \"user_busy\",\n\n    /**\n     * We transferred the call off to somewhere else\n     */\n    Transfered = \"transferred\",\n\n    /**\n     * A call from the same user was found with a new session id\n     */\n    NewSession = \"new_session\",\n}\n\n/**\n * The version field that we set in m.call.* events\n */\nconst VOIP_PROTO_VERSION = \"1\";\n\n/** The fallback ICE server to use for STUN or TURN protocols. */\nconst FALLBACK_ICE_SERVER = \"stun:turn.matrix.org\";\n\n/** The length of time a call can be ringing for. */\nconst CALL_TIMEOUT_MS = 60 * 1000; // ms\n/** The time after which we increment callLength */\nconst CALL_LENGTH_INTERVAL = 1000; // ms\n/** The time after which we end the call, if ICE got disconnected */\nconst ICE_DISCONNECTED_TIMEOUT = 30 * 1000; // ms\n\nexport class CallError extends Error {\n    public readonly code: string;\n\n    public constructor(code: CallErrorCode, msg: string, err: Error) {\n        // Still don't think there's any way to have proper nested errors\n        super(msg + \": \" + err);\n\n        this.code = code;\n    }\n}\n\nexport function genCallID(): string {\n    return Date.now().toString() + randomString(16);\n}\n\nfunction getCodecParamMods(isPtt: boolean): CodecParamsMod[] {\n    const mods = [\n        {\n            mediaType: \"audio\",\n            codec: \"opus\",\n            enableDtx: true,\n            maxAverageBitrate: isPtt ? 12000 : undefined,\n        },\n    ] as CodecParamsMod[];\n\n    return mods;\n}\n\nexport type CallEventHandlerMap = {\n    [CallEvent.DataChannel]: (channel: RTCDataChannel) => void;\n    [CallEvent.FeedsChanged]: (feeds: CallFeed[]) => void;\n    [CallEvent.Replaced]: (newCall: MatrixCall) => void;\n    [CallEvent.Error]: (error: CallError) => void;\n    [CallEvent.RemoteHoldUnhold]: (onHold: boolean) => void;\n    [CallEvent.LocalHoldUnhold]: (onHold: boolean) => void;\n    [CallEvent.LengthChanged]: (length: number) => void;\n    [CallEvent.State]: (state: CallState, oldState?: CallState) => void;\n    [CallEvent.Hangup]: (call: MatrixCall) => void;\n    [CallEvent.AssertedIdentityChanged]: () => void;\n    /* @deprecated */\n    [CallEvent.HoldUnhold]: (onHold: boolean) => void;\n    [CallEvent.SendVoipEvent]: (event: Record<string, any>) => void;\n};\n\n// The key of the transceiver map (purpose + media type, separated by ':')\ntype TransceiverKey = string;\n\n// generates keys for the map of transceivers\n// kind is unfortunately a string rather than MediaType as this is the type of\n// track.kind\nfunction getTransceiverKey(purpose: SDPStreamMetadataPurpose, kind: TransceiverKey): string {\n    return purpose + \":\" + kind;\n}\n\nexport class MatrixCall extends TypedEventEmitter<CallEvent, CallEventHandlerMap> {\n    public roomId?: string;\n    public callId: string;\n    public invitee?: string;\n    public hangupParty?: CallParty;\n    public hangupReason?: string;\n    public direction?: CallDirection;\n    public ourPartyId: string;\n    public peerConn?: RTCPeerConnection;\n    public toDeviceSeq = 0;\n\n    // whether this call should have push-to-talk semantics\n    // This should be set by the consumer on incoming & outgoing calls.\n    public isPtt = false;\n\n    private _state = CallState.Fledgling;\n    private readonly client: MatrixClient;\n    private readonly forceTURN?: boolean;\n    private readonly turnServers: Array<TurnServer>;\n    // A queue for candidates waiting to go out.\n    // We try to amalgamate candidates into a single candidate message where\n    // possible\n    private candidateSendQueue: Array<RTCIceCandidate> = [];\n    private candidateSendTries = 0;\n    private candidatesEnded = false;\n    private feeds: Array<CallFeed> = [];\n\n    // our transceivers for each purpose and type of media\n    private transceivers = new Map<TransceiverKey, RTCRtpTransceiver>();\n\n    private inviteOrAnswerSent = false;\n    private waitForLocalAVStream = false;\n    private successor?: MatrixCall;\n    private opponentMember?: RoomMember;\n    private opponentVersion?: number | string;\n    // The party ID of the other side: undefined if we haven't chosen a partner\n    // yet, null if we have but they didn't send a party ID.\n    private opponentPartyId: string | null | undefined;\n    private opponentCaps?: CallCapabilities;\n    private iceDisconnectedTimeout?: ReturnType<typeof setTimeout>;\n    private inviteTimeout?: ReturnType<typeof setTimeout>;\n    private readonly removeTrackListeners = new Map<MediaStream, () => void>();\n\n    // The logic of when & if a call is on hold is nontrivial and explained in is*OnHold\n    // This flag represents whether we want the other party to be on hold\n    private remoteOnHold = false;\n\n    // the stats for the call at the point it ended. We can't get these after we\n    // tear the call down, so we just grab a snapshot before we stop the call.\n    // The typescript definitions have this type as 'any' :(\n    private callStatsAtEnd?: any[];\n\n    // Perfect negotiation state: https://www.w3.org/TR/webrtc/#perfect-negotiation-example\n    private makingOffer = false;\n    private ignoreOffer = false;\n\n    private responsePromiseChain?: Promise<void>;\n\n    // If candidates arrive before we've picked an opponent (which, in particular,\n    // will happen if the opponent sends candidates eagerly before the user answers\n    // the call) we buffer them up here so we can then add the ones from the party we pick\n    private remoteCandidateBuffer = new Map<string, RTCIceCandidate[]>();\n\n    private remoteAssertedIdentity?: AssertedIdentity;\n    private remoteSDPStreamMetadata?: SDPStreamMetadata;\n\n    private callLengthInterval?: ReturnType<typeof setInterval>;\n    private callStartTime?: number;\n\n    private opponentDeviceId?: string;\n    private opponentDeviceInfo?: DeviceInfo;\n    private opponentSessionId?: string;\n    public groupCallId?: string;\n\n    /**\n     * Construct a new Matrix Call.\n     * @param opts - Config options.\n     */\n    public constructor(opts: CallOpts) {\n        super();\n\n        this.roomId = opts.roomId;\n        this.invitee = opts.invitee;\n        this.client = opts.client;\n\n        if (!this.client.deviceId) throw new Error(\"Client must have a device ID to start calls\");\n\n        this.forceTURN = opts.forceTURN ?? false;\n        this.ourPartyId = this.client.deviceId;\n        this.opponentDeviceId = opts.opponentDeviceId;\n        this.opponentSessionId = opts.opponentSessionId;\n        this.groupCallId = opts.groupCallId;\n        // Array of Objects with urls, username, credential keys\n        this.turnServers = opts.turnServers || [];\n        if (this.turnServers.length === 0 && this.client.isFallbackICEServerAllowed()) {\n            this.turnServers.push({\n                urls: [FALLBACK_ICE_SERVER],\n            });\n        }\n        for (const server of this.turnServers) {\n            utils.checkObjectHasKeys(server, [\"urls\"]);\n        }\n        this.callId = genCallID();\n    }\n\n    /**\n     * Place a voice call to this room.\n     * @throws If you have not specified a listener for 'error' events.\n     */\n    public async placeVoiceCall(): Promise<void> {\n        await this.placeCall(true, false);\n    }\n\n    /**\n     * Place a video call to this room.\n     * @throws If you have not specified a listener for 'error' events.\n     */\n    public async placeVideoCall(): Promise<void> {\n        await this.placeCall(true, true);\n    }\n\n    /**\n     * Create a datachannel using this call's peer connection.\n     * @param label - A human readable label for this datachannel\n     * @param options - An object providing configuration options for the data channel.\n     */\n    public createDataChannel(label: string, options: RTCDataChannelInit | undefined): RTCDataChannel {\n        const dataChannel = this.peerConn!.createDataChannel(label, options);\n        this.emit(CallEvent.DataChannel, dataChannel);\n        return dataChannel;\n    }\n\n    public getOpponentMember(): RoomMember | undefined {\n        return this.opponentMember;\n    }\n\n    public getOpponentDeviceId(): string | undefined {\n        return this.opponentDeviceId;\n    }\n\n    public getOpponentSessionId(): string | undefined {\n        return this.opponentSessionId;\n    }\n\n    public opponentCanBeTransferred(): boolean {\n        return Boolean(this.opponentCaps && this.opponentCaps[\"m.call.transferee\"]);\n    }\n\n    public opponentSupportsDTMF(): boolean {\n        return Boolean(this.opponentCaps && this.opponentCaps[\"m.call.dtmf\"]);\n    }\n\n    public getRemoteAssertedIdentity(): AssertedIdentity | undefined {\n        return this.remoteAssertedIdentity;\n    }\n\n    public get state(): CallState {\n        return this._state;\n    }\n\n    private set state(state: CallState) {\n        const oldState = this._state;\n        this._state = state;\n        this.emit(CallEvent.State, state, oldState);\n    }\n\n    public get type(): CallType {\n        return this.hasLocalUserMediaVideoTrack || this.hasRemoteUserMediaVideoTrack ? CallType.Video : CallType.Voice;\n    }\n\n    public get hasLocalUserMediaVideoTrack(): boolean {\n        return !!this.localUsermediaStream?.getVideoTracks().length;\n    }\n\n    public get hasRemoteUserMediaVideoTrack(): boolean {\n        return this.getRemoteFeeds().some((feed) => {\n            return feed.purpose === SDPStreamMetadataPurpose.Usermedia && feed.stream?.getVideoTracks().length;\n        });\n    }\n\n    public get hasLocalUserMediaAudioTrack(): boolean {\n        return !!this.localUsermediaStream?.getAudioTracks().length;\n    }\n\n    public get hasRemoteUserMediaAudioTrack(): boolean {\n        return this.getRemoteFeeds().some((feed) => {\n            return feed.purpose === SDPStreamMetadataPurpose.Usermedia && !!feed.stream?.getAudioTracks().length;\n        });\n    }\n\n    public get localUsermediaFeed(): CallFeed | undefined {\n        return this.getLocalFeeds().find((feed) => feed.purpose === SDPStreamMetadataPurpose.Usermedia);\n    }\n\n    public get localScreensharingFeed(): CallFeed | undefined {\n        return this.getLocalFeeds().find((feed) => feed.purpose === SDPStreamMetadataPurpose.Screenshare);\n    }\n\n    public get localUsermediaStream(): MediaStream | undefined {\n        return this.localUsermediaFeed?.stream;\n    }\n\n    public get localScreensharingStream(): MediaStream | undefined {\n        return this.localScreensharingFeed?.stream;\n    }\n\n    public get remoteUsermediaFeed(): CallFeed | undefined {\n        return this.getRemoteFeeds().find((feed) => feed.purpose === SDPStreamMetadataPurpose.Usermedia);\n    }\n\n    public get remoteScreensharingFeed(): CallFeed | undefined {\n        return this.getRemoteFeeds().find((feed) => feed.purpose === SDPStreamMetadataPurpose.Screenshare);\n    }\n\n    public get remoteUsermediaStream(): MediaStream | undefined {\n        return this.remoteUsermediaFeed?.stream;\n    }\n\n    public get remoteScreensharingStream(): MediaStream | undefined {\n        return this.remoteScreensharingFeed?.stream;\n    }\n\n    private getFeedByStreamId(streamId: string): CallFeed | undefined {\n        return this.getFeeds().find((feed) => feed.stream.id === streamId);\n    }\n\n    /**\n     * Returns an array of all CallFeeds\n     * @returns CallFeeds\n     */\n    public getFeeds(): Array<CallFeed> {\n        return this.feeds;\n    }\n\n    /**\n     * Returns an array of all local CallFeeds\n     * @returns local CallFeeds\n     */\n    public getLocalFeeds(): Array<CallFeed> {\n        return this.feeds.filter((feed) => feed.isLocal());\n    }\n\n    /**\n     * Returns an array of all remote CallFeeds\n     * @returns remote CallFeeds\n     */\n    public getRemoteFeeds(): Array<CallFeed> {\n        return this.feeds.filter((feed) => !feed.isLocal());\n    }\n\n    private async initOpponentCrypto(): Promise<void> {\n        if (!this.opponentDeviceId) return;\n        if (!this.client.getUseE2eForGroupCall()) return;\n        // It's possible to want E2EE and yet not have the means to manage E2EE\n        // ourselves (for example if the client is a RoomWidgetClient)\n        if (!this.client.isCryptoEnabled()) {\n            // All we know is the device ID\n            this.opponentDeviceInfo = new DeviceInfo(this.opponentDeviceId);\n            return;\n        }\n        // if we've got to this point, we do want to init crypto, so throw if we can't\n        if (!this.client.crypto) throw new Error(\"Crypto is not initialised.\");\n\n        const userId = this.invitee || this.getOpponentMember()?.userId;\n\n        if (!userId) throw new Error(\"Couldn't find opponent user ID to init crypto\");\n\n        const deviceInfoMap = await this.client.crypto.deviceList.downloadKeys([userId], false);\n        this.opponentDeviceInfo = deviceInfoMap[userId][this.opponentDeviceId];\n        if (this.opponentDeviceInfo === undefined) {\n            throw new GroupCallUnknownDeviceError(userId);\n        }\n    }\n\n    /**\n     * Generates and returns localSDPStreamMetadata\n     * @returns localSDPStreamMetadata\n     */\n    private getLocalSDPStreamMetadata(updateStreamIds = false): SDPStreamMetadata {\n        const metadata: SDPStreamMetadata = {};\n        for (const localFeed of this.getLocalFeeds()) {\n            if (updateStreamIds) {\n                localFeed.sdpMetadataStreamId = localFeed.stream.id;\n            }\n\n            metadata[localFeed.sdpMetadataStreamId] = {\n                purpose: localFeed.purpose,\n                audio_muted: localFeed.isAudioMuted(),\n                video_muted: localFeed.isVideoMuted(),\n            };\n        }\n        return metadata;\n    }\n\n    /**\n     * Returns true if there are no incoming feeds,\n     * otherwise returns false\n     * @returns no incoming feeds\n     */\n    public noIncomingFeeds(): boolean {\n        return !this.feeds.some((feed) => !feed.isLocal());\n    }\n\n    private pushRemoteFeed(stream: MediaStream): void {\n        // Fallback to old behavior if the other side doesn't support SDPStreamMetadata\n        if (!this.opponentSupportsSDPStreamMetadata()) {\n            this.pushRemoteFeedWithoutMetadata(stream);\n            return;\n        }\n\n        const userId = this.getOpponentMember()!.userId;\n        const purpose = this.remoteSDPStreamMetadata![stream.id].purpose;\n        const audioMuted = this.remoteSDPStreamMetadata![stream.id].audio_muted;\n        const videoMuted = this.remoteSDPStreamMetadata![stream.id].video_muted;\n\n        if (!purpose) {\n            logger.warn(\n                `Call ${this.callId} Ignoring stream with id ${stream.id} because we didn't get any metadata about it`,\n            );\n            return;\n        }\n\n        if (this.getFeedByStreamId(stream.id)) {\n            logger.warn(`Ignoring stream with id ${stream.id} because we already have a feed for it`);\n            return;\n        }\n\n        this.feeds.push(\n            new CallFeed({\n                client: this.client,\n                call: this,\n                roomId: this.roomId,\n                userId,\n                deviceId: this.getOpponentDeviceId(),\n                stream,\n                purpose,\n                audioMuted,\n                videoMuted,\n            }),\n        );\n\n        this.emit(CallEvent.FeedsChanged, this.feeds);\n\n        logger.info(\n            `Call ${this.callId} pushed remote stream (id=\"${stream.id}\", ` +\n                `active=\"${stream.active}\", purpose=${purpose})`,\n        );\n    }\n\n    /**\n     * This method is used ONLY if the other client doesn't support sending SDPStreamMetadata\n     */\n    private pushRemoteFeedWithoutMetadata(stream: MediaStream): void {\n        const userId = this.getOpponentMember()!.userId;\n        // We can guess the purpose here since the other client can only send one stream\n        const purpose = SDPStreamMetadataPurpose.Usermedia;\n        const oldRemoteStream = this.feeds.find((feed) => !feed.isLocal())?.stream;\n\n        // Note that we check by ID and always set the remote stream: Chrome appears\n        // to make new stream objects when transceiver directionality is changed and the 'active'\n        // status of streams change - Dave\n        // If we already have a stream, check this stream has the same id\n        if (oldRemoteStream && stream.id !== oldRemoteStream.id) {\n            logger.warn(\n                `Call ${this.callId} Ignoring new stream ID ${stream.id}: we already have stream ID ${oldRemoteStream.id}`,\n            );\n            return;\n        }\n\n        if (this.getFeedByStreamId(stream.id)) {\n            logger.warn(`Ignoring stream with id ${stream.id} because we already have a feed for it`);\n            return;\n        }\n\n        this.feeds.push(\n            new CallFeed({\n                client: this.client,\n                call: this,\n                roomId: this.roomId,\n                audioMuted: false,\n                videoMuted: false,\n                userId,\n                deviceId: this.getOpponentDeviceId(),\n                stream,\n                purpose,\n            }),\n        );\n\n        this.emit(CallEvent.FeedsChanged, this.feeds);\n\n        logger.info(`Call ${this.callId} pushed remote stream (id=\"${stream.id}\", active=\"${stream.active}\")`);\n    }\n\n    private pushNewLocalFeed(stream: MediaStream, purpose: SDPStreamMetadataPurpose, addToPeerConnection = true): void {\n        const userId = this.client.getUserId()!;\n\n        // Tracks don't always start off enabled, eg. chrome will give a disabled\n        // audio track if you ask for user media audio and already had one that\n        // you'd set to disabled (presumably because it clones them internally).\n        setTracksEnabled(stream.getAudioTracks(), true);\n        setTracksEnabled(stream.getVideoTracks(), true);\n\n        if (this.getFeedByStreamId(stream.id)) {\n            logger.warn(`Ignoring stream with id ${stream.id} because we already have a feed for it`);\n            return;\n        }\n\n        this.pushLocalFeed(\n            new CallFeed({\n                client: this.client,\n                roomId: this.roomId,\n                audioMuted: false,\n                videoMuted: false,\n                userId,\n                deviceId: this.getOpponentDeviceId(),\n                stream,\n                purpose,\n            }),\n            addToPeerConnection,\n        );\n    }\n\n    /**\n     * Pushes supplied feed to the call\n     * @param callFeed - to push\n     * @param addToPeerConnection - whether to add the tracks to the peer connection\n     */\n    public pushLocalFeed(callFeed: CallFeed, addToPeerConnection = true): void {\n        if (this.feeds.some((feed) => callFeed.stream.id === feed.stream.id)) {\n            logger.info(`Ignoring duplicate local stream ${callFeed.stream.id} in call ${this.callId}`);\n            return;\n        }\n\n        this.feeds.push(callFeed);\n\n        if (addToPeerConnection) {\n            for (const track of callFeed.stream.getTracks()) {\n                logger.info(\n                    `Call ${this.callId} ` +\n                        `Adding track (` +\n                        `id=\"${track.id}\", ` +\n                        `kind=\"${track.kind}\", ` +\n                        `streamId=\"${callFeed.stream.id}\", ` +\n                        `streamPurpose=\"${callFeed.purpose}\", ` +\n                        `enabled=${track.enabled}` +\n                        `) to peer connection`,\n                );\n\n                const tKey = getTransceiverKey(callFeed.purpose, track.kind);\n                if (this.transceivers.has(tKey)) {\n                    // we already have a sender, so we re-use it. We try to re-use transceivers as much\n                    // as possible because they can't be removed once added, so otherwise they just\n                    // accumulate which makes the SDP very large very quickly: in fact it only takes\n                    // about 6 video tracks to exceed the maximum size of an Olm-encrypted\n                    // Matrix event.\n                    const transceiver = this.transceivers.get(tKey)!;\n\n                    // this is what would allow us to use addTransceiver(), but it's not available\n                    // on Firefox yet. We call it anyway if we have it.\n                    if (transceiver.sender.setStreams) transceiver.sender.setStreams(callFeed.stream);\n\n                    transceiver.sender.replaceTrack(track);\n                    // set the direction to indicate we're going to start sending again\n                    // (this will trigger the re-negotiation)\n                    transceiver.direction = transceiver.direction === \"inactive\" ? \"sendonly\" : \"sendrecv\";\n                } else {\n                    // create a new one. We need to use addTrack rather addTransceiver for this because firefox\n                    // doesn't yet implement RTCRTPSender.setStreams()\n                    // (https://bugzilla.mozilla.org/show_bug.cgi?id=1510802) so we'd have no way to group the\n                    // two tracks together into a stream.\n                    const newSender = this.peerConn!.addTrack(track, callFeed.stream);\n\n                    // now go & fish for the new transceiver\n                    const newTransciever = this.peerConn!.getTransceivers().find((t) => t.sender === newSender);\n                    if (newTransciever) {\n                        this.transceivers.set(tKey, newTransciever);\n                    } else {\n                        logger.warn(\"Didn't find a matching transceiver after adding track!\");\n                    }\n                }\n            }\n        }\n\n        logger.info(\n            `Call ${this.callId} ` +\n                `Pushed local stream ` +\n                `(id=\"${callFeed.stream.id}\", ` +\n                `active=\"${callFeed.stream.active}\", ` +\n                `purpose=\"${callFeed.purpose}\")`,\n        );\n\n        this.emit(CallEvent.FeedsChanged, this.feeds);\n    }\n\n    /**\n     * Removes local call feed from the call and its tracks from the peer\n     * connection\n     * @param callFeed - to remove\n     */\n    public removeLocalFeed(callFeed: CallFeed): void {\n        const audioTransceiverKey = getTransceiverKey(callFeed.purpose, \"audio\");\n        const videoTransceiverKey = getTransceiverKey(callFeed.purpose, \"video\");\n\n        for (const transceiverKey of [audioTransceiverKey, videoTransceiverKey]) {\n            // this is slightly mixing the track and transceiver API but is basically just shorthand.\n            // There is no way to actually remove a transceiver, so this just sets it to inactive\n            // (or recvonly) and replaces the source with nothing.\n            if (this.transceivers.has(transceiverKey)) {\n                const transceiver = this.transceivers.get(transceiverKey)!;\n                if (transceiver.sender) this.peerConn!.removeTrack(transceiver.sender);\n            }\n        }\n\n        if (callFeed.purpose === SDPStreamMetadataPurpose.Screenshare) {\n            this.client.getMediaHandler().stopScreensharingStream(callFeed.stream);\n        }\n\n        this.deleteFeed(callFeed);\n    }\n\n    private deleteAllFeeds(): void {\n        for (const feed of this.feeds) {\n            if (!feed.isLocal() || !this.groupCallId) {\n                feed.dispose();\n            }\n        }\n\n        this.feeds = [];\n        this.emit(CallEvent.FeedsChanged, this.feeds);\n    }\n\n    private deleteFeedByStream(stream: MediaStream): void {\n        const feed = this.getFeedByStreamId(stream.id);\n        if (!feed) {\n            logger.warn(`Call ${this.callId} Didn't find the feed with stream id ${stream.id} to delete`);\n            return;\n        }\n        this.deleteFeed(feed);\n    }\n\n    private deleteFeed(feed: CallFeed): void {\n        feed.dispose();\n        this.feeds.splice(this.feeds.indexOf(feed), 1);\n        this.emit(CallEvent.FeedsChanged, this.feeds);\n    }\n\n    // The typescript definitions have this type as 'any' :(\n    public async getCurrentCallStats(): Promise<any[] | undefined> {\n        if (this.callHasEnded()) {\n            return this.callStatsAtEnd;\n        }\n\n        return this.collectCallStats();\n    }\n\n    private async collectCallStats(): Promise<any[] | undefined> {\n        // This happens when the call fails before it starts.\n        // For example when we fail to get capture sources\n        if (!this.peerConn) return;\n\n        const statsReport = await this.peerConn.getStats();\n        const stats: any[] = [];\n        statsReport.forEach((item) => {\n            stats.push(item);\n        });\n\n        return stats;\n    }\n\n    /**\n     * Configure this call from an invite event. Used by MatrixClient.\n     * @param event - The m.call.invite event\n     */\n    public async initWithInvite(event: MatrixEvent): Promise<void> {\n        const invite = event.getContent<MCallInviteNegotiate>();\n        this.direction = CallDirection.Inbound;\n\n        // make sure we have valid turn creds. Unless something's gone wrong, it should\n        // poll and keep the credentials valid so this should be instant.\n        const haveTurnCreds = await this.client.checkTurnServers();\n        if (!haveTurnCreds) {\n            logger.warn(`Call ${this.callId} Failed to get TURN credentials! Proceeding with call anyway...`);\n        }\n\n        const sdpStreamMetadata = invite[SDPStreamMetadataKey];\n        if (sdpStreamMetadata) {\n            this.updateRemoteSDPStreamMetadata(sdpStreamMetadata);\n        } else {\n            logger.debug(\n                `Call ${this.callId} did not get any SDPStreamMetadata! Can not send/receive multiple streams`,\n            );\n        }\n\n        this.peerConn = this.createPeerConnection();\n        // we must set the party ID before await-ing on anything: the call event\n        // handler will start giving us more call events (eg. candidates) so if\n        // we haven't set the party ID, we'll ignore them.\n        this.chooseOpponent(event);\n        await this.initOpponentCrypto();\n        try {\n            await this.peerConn.setRemoteDescription(invite.offer);\n            await this.addBufferedIceCandidates();\n        } catch (e) {\n            logger.debug(`Call ${this.callId} failed to set remote description`, e);\n            this.terminate(CallParty.Local, CallErrorCode.SetRemoteDescription, false);\n            return;\n        }\n\n        const remoteStream = this.feeds.find((feed) => !feed.isLocal())?.stream;\n\n        // According to previous comments in this file, firefox at some point did not\n        // add streams until media started arriving on them. Testing latest firefox\n        // (81 at time of writing), this is no longer a problem, so let's do it the correct way.\n        if (!remoteStream || remoteStream.getTracks().length === 0) {\n            logger.error(`Call ${this.callId} no remote stream or no tracks after setting remote description!`);\n            this.terminate(CallParty.Local, CallErrorCode.SetRemoteDescription, false);\n            return;\n        }\n\n        this.state = CallState.Ringing;\n\n        if (event.getLocalAge()) {\n            // Time out the call if it's ringing for too long\n            const ringingTimer = setTimeout(() => {\n                if (this.state == CallState.Ringing) {\n                    logger.debug(`Call ${this.callId} invite has expired. Hanging up.`);\n                    this.hangupParty = CallParty.Remote; // effectively\n                    this.state = CallState.Ended;\n                    this.stopAllMedia();\n                    if (this.peerConn!.signalingState != \"closed\") {\n                        this.peerConn!.close();\n                    }\n                    this.emit(CallEvent.Hangup, this);\n                }\n            }, invite.lifetime - event.getLocalAge());\n\n            const onState = (state: CallState): void => {\n                if (state !== CallState.Ringing) {\n                    clearTimeout(ringingTimer);\n                    this.off(CallEvent.State, onState);\n                }\n            };\n            this.on(CallEvent.State, onState);\n        }\n    }\n\n    /**\n     * Configure this call from a hangup or reject event. Used by MatrixClient.\n     * @param event - The m.call.hangup event\n     */\n    public initWithHangup(event: MatrixEvent): void {\n        // perverse as it may seem, sometimes we want to instantiate a call with a\n        // hangup message (because when getting the state of the room on load, events\n        // come in reverse order and we want to remember that a call has been hung up)\n        this.state = CallState.Ended;\n    }\n\n    private shouldAnswerWithMediaType(\n        wantedValue: boolean | undefined,\n        valueOfTheOtherSide: boolean,\n        type: \"audio\" | \"video\",\n    ): boolean {\n        if (wantedValue && !valueOfTheOtherSide) {\n            // TODO: Figure out how to do this\n            logger.warn(\n                `Call ${this.callId} Unable to answer with ${type} because the other side isn't sending it either.`,\n            );\n            return false;\n        } else if (\n            !utils.isNullOrUndefined(wantedValue) &&\n            wantedValue !== valueOfTheOtherSide &&\n            !this.opponentSupportsSDPStreamMetadata()\n        ) {\n            logger.warn(\n                `Call ${this.callId} Unable to answer with ${type}=${wantedValue} because the other side doesn't support it. Answering with ${type}=${valueOfTheOtherSide}.`,\n            );\n            return valueOfTheOtherSide!;\n        }\n        return wantedValue ?? valueOfTheOtherSide!;\n    }\n\n    /**\n     * Answer a call.\n     */\n    public async answer(audio?: boolean, video?: boolean): Promise<void> {\n        if (this.inviteOrAnswerSent) return;\n        // TODO: Figure out how to do this\n        if (audio === false && video === false) throw new Error(\"You CANNOT answer a call without media\");\n\n        if (!this.localUsermediaStream && !this.waitForLocalAVStream) {\n            const prevState = this.state;\n            const answerWithAudio = this.shouldAnswerWithMediaType(audio, this.hasRemoteUserMediaAudioTrack, \"audio\");\n            const answerWithVideo = this.shouldAnswerWithMediaType(video, this.hasRemoteUserMediaVideoTrack, \"video\");\n\n            this.state = CallState.WaitLocalMedia;\n            this.waitForLocalAVStream = true;\n\n            try {\n                const stream = await this.client.getMediaHandler().getUserMediaStream(answerWithAudio, answerWithVideo);\n                this.waitForLocalAVStream = false;\n                const usermediaFeed = new CallFeed({\n                    client: this.client,\n                    roomId: this.roomId,\n                    userId: this.client.getUserId()!,\n                    deviceId: this.client.getDeviceId() ?? undefined,\n                    stream,\n                    purpose: SDPStreamMetadataPurpose.Usermedia,\n                    audioMuted: false,\n                    videoMuted: false,\n                });\n\n                const feeds = [usermediaFeed];\n\n                if (this.localScreensharingFeed) {\n                    feeds.push(this.localScreensharingFeed);\n                }\n\n                this.answerWithCallFeeds(feeds);\n            } catch (e) {\n                if (answerWithVideo) {\n                    // Try to answer without video\n                    logger.warn(`Call ${this.callId} Failed to getUserMedia(), trying to getUserMedia() without video`);\n                    this.state = prevState;\n                    this.waitForLocalAVStream = false;\n                    await this.answer(answerWithAudio, false);\n                } else {\n                    this.getUserMediaFailed(<Error>e);\n                    return;\n                }\n            }\n        } else if (this.waitForLocalAVStream) {\n            this.state = CallState.WaitLocalMedia;\n        }\n    }\n\n    public answerWithCallFeeds(callFeeds: CallFeed[]): void {\n        if (this.inviteOrAnswerSent) return;\n\n        this.queueGotCallFeedsForAnswer(callFeeds);\n    }\n\n    /**\n     * Replace this call with a new call, e.g. for glare resolution. Used by\n     * MatrixClient.\n     * @param newCall - The new call.\n     */\n    public replacedBy(newCall: MatrixCall): void {\n        logger.debug(`Call ${this.callId} replaced by ${newCall.callId}`);\n        if (this.state === CallState.WaitLocalMedia) {\n            logger.debug(`Call ${this.callId} telling new call ${newCall.callId} to wait for local media`);\n            newCall.waitForLocalAVStream = true;\n        } else if ([CallState.CreateOffer, CallState.InviteSent].includes(this.state)) {\n            if (newCall.direction === CallDirection.Outbound) {\n                newCall.queueGotCallFeedsForAnswer([]);\n            } else {\n                logger.debug(`Call ${this.callId} handing local stream to new call ${newCall.callId}`);\n                newCall.queueGotCallFeedsForAnswer(this.getLocalFeeds().map((feed) => feed.clone()));\n            }\n        }\n        this.successor = newCall;\n        this.emit(CallEvent.Replaced, newCall);\n        this.hangup(CallErrorCode.Replaced, true);\n    }\n\n    /**\n     * Hangup a call.\n     * @param reason - The reason why the call is being hung up.\n     * @param suppressEvent - True to suppress emitting an event.\n     */\n    public hangup(reason: CallErrorCode, suppressEvent: boolean): void {\n        if (this.callHasEnded()) return;\n\n        logger.debug(`Ending call ${this.callId} with reason ${reason}`);\n        this.terminate(CallParty.Local, reason, !suppressEvent);\n        // We don't want to send hangup here if we didn't even get to sending an invite\n        if ([CallState.Fledgling, CallState.WaitLocalMedia].includes(this.state)) return;\n        const content: IContent = {};\n        // Don't send UserHangup reason to older clients\n        if ((this.opponentVersion && this.opponentVersion !== 0) || reason !== CallErrorCode.UserHangup) {\n            content[\"reason\"] = reason;\n        }\n        this.sendVoipEvent(EventType.CallHangup, content);\n    }\n\n    /**\n     * Reject a call\n     * This used to be done by calling hangup, but is a separate method and protocol\n     * event as of MSC2746.\n     */\n    public reject(): void {\n        if (this.state !== CallState.Ringing) {\n            throw Error(\"Call must be in 'ringing' state to reject!\");\n        }\n\n        if (this.opponentVersion === 0) {\n            logger.info(\n                `Call ${this.callId} Opponent version is less than 1 (${this.opponentVersion}): sending hangup instead of reject`,\n            );\n            this.hangup(CallErrorCode.UserHangup, true);\n            return;\n        }\n\n        logger.debug(\"Rejecting call: \" + this.callId);\n        this.terminate(CallParty.Local, CallErrorCode.UserHangup, true);\n        this.sendVoipEvent(EventType.CallReject, {});\n    }\n\n    /**\n     * Adds an audio and/or video track - upgrades the call\n     * @param audio - should add an audio track\n     * @param video - should add an video track\n     */\n    private async upgradeCall(audio: boolean, video: boolean): Promise<void> {\n        // We don't do call downgrades\n        if (!audio && !video) return;\n        if (!this.opponentSupportsSDPStreamMetadata()) return;\n\n        try {\n            logger.debug(`Upgrading call ${this.callId}: audio?=${audio} video?=${video}`);\n            const getAudio = audio || this.hasLocalUserMediaAudioTrack;\n            const getVideo = video || this.hasLocalUserMediaVideoTrack;\n\n            // updateLocalUsermediaStream() will take the tracks, use them as\n            // replacement and throw the stream away, so it isn't reusable\n            const stream = await this.client.getMediaHandler().getUserMediaStream(getAudio, getVideo, false);\n            await this.updateLocalUsermediaStream(stream, audio, video);\n        } catch (error) {\n            logger.error(`Call ${this.callId} Failed to upgrade the call`, error);\n            this.emit(\n                CallEvent.Error,\n                new CallError(CallErrorCode.NoUserMedia, \"Failed to get camera access: \", <Error>error),\n            );\n        }\n    }\n\n    /**\n     * Returns true if this.remoteSDPStreamMetadata is defined, otherwise returns false\n     * @returns can screenshare\n     */\n    public opponentSupportsSDPStreamMetadata(): boolean {\n        return Boolean(this.remoteSDPStreamMetadata);\n    }\n\n    /**\n     * If there is a screensharing stream returns true, otherwise returns false\n     * @returns is screensharing\n     */\n    public isScreensharing(): boolean {\n        return Boolean(this.localScreensharingStream);\n    }\n\n    /**\n     * Starts/stops screensharing\n     * @param enabled - the desired screensharing state\n     * @param desktopCapturerSourceId - optional id of the desktop capturer source to use\n     * @returns new screensharing state\n     */\n    public async setScreensharingEnabled(enabled: boolean, opts?: IScreensharingOpts): Promise<boolean> {\n        // Skip if there is nothing to do\n        if (enabled && this.isScreensharing()) {\n            logger.warn(`Call ${this.callId} There is already a screensharing stream - there is nothing to do!`);\n            return true;\n        } else if (!enabled && !this.isScreensharing()) {\n            logger.warn(`Call ${this.callId} There already isn't a screensharing stream - there is nothing to do!`);\n            return false;\n        }\n\n        // Fallback to replaceTrack()\n        if (!this.opponentSupportsSDPStreamMetadata()) {\n            return this.setScreensharingEnabledWithoutMetadataSupport(enabled, opts);\n        }\n\n        logger.debug(`Call ${this.callId} set screensharing enabled? ${enabled}`);\n        if (enabled) {\n            try {\n                const stream = await this.client.getMediaHandler().getScreensharingStream(opts);\n                if (!stream) return false;\n                this.pushNewLocalFeed(stream, SDPStreamMetadataPurpose.Screenshare);\n                return true;\n            } catch (err) {\n                logger.error(`Call ${this.callId} Failed to get screen-sharing stream:`, err);\n                return false;\n            }\n        } else {\n            const audioTransceiver = this.transceivers.get(\n                getTransceiverKey(SDPStreamMetadataPurpose.Screenshare, \"audio\"),\n            );\n            const videoTransceiver = this.transceivers.get(\n                getTransceiverKey(SDPStreamMetadataPurpose.Screenshare, \"video\"),\n            );\n\n            for (const transceiver of [audioTransceiver, videoTransceiver]) {\n                // this is slightly mixing the track and transceiver API but is basically just shorthand\n                // for removing the sender.\n                if (transceiver && transceiver.sender) this.peerConn!.removeTrack(transceiver.sender);\n            }\n\n            this.client.getMediaHandler().stopScreensharingStream(this.localScreensharingStream!);\n            this.deleteFeedByStream(this.localScreensharingStream!);\n            return false;\n        }\n    }\n\n    /**\n     * Starts/stops screensharing\n     * Should be used ONLY if the opponent doesn't support SDPStreamMetadata\n     * @param enabled - the desired screensharing state\n     * @param desktopCapturerSourceId - optional id of the desktop capturer source to use\n     * @returns new screensharing state\n     */\n    private async setScreensharingEnabledWithoutMetadataSupport(\n        enabled: boolean,\n        opts?: IScreensharingOpts,\n    ): Promise<boolean> {\n        logger.debug(`Call ${this.callId} Set screensharing enabled? ${enabled} using replaceTrack()`);\n        if (enabled) {\n            try {\n                const stream = await this.client.getMediaHandler().getScreensharingStream(opts);\n                if (!stream) return false;\n\n                const track = stream.getTracks().find((track) => track.kind === \"video\");\n\n                const sender = this.transceivers.get(\n                    getTransceiverKey(SDPStreamMetadataPurpose.Usermedia, \"video\"),\n                )?.sender;\n\n                sender?.replaceTrack(track ?? null);\n\n                this.pushNewLocalFeed(stream, SDPStreamMetadataPurpose.Screenshare, false);\n\n                return true;\n            } catch (err) {\n                logger.error(`Call ${this.callId} Failed to get screen-sharing stream:`, err);\n                return false;\n            }\n        } else {\n            const track = this.localUsermediaStream?.getTracks().find((track) => track.kind === \"video\");\n            const sender = this.transceivers.get(\n                getTransceiverKey(SDPStreamMetadataPurpose.Usermedia, \"video\"),\n            )?.sender;\n            sender?.replaceTrack(track ?? null);\n\n            this.client.getMediaHandler().stopScreensharingStream(this.localScreensharingStream!);\n            this.deleteFeedByStream(this.localScreensharingStream!);\n\n            return false;\n        }\n    }\n\n    /**\n     * Replaces/adds the tracks from the passed stream to the localUsermediaStream\n     * @param stream - to use a replacement for the local usermedia stream\n     */\n    public async updateLocalUsermediaStream(\n        stream: MediaStream,\n        forceAudio = false,\n        forceVideo = false,\n    ): Promise<void> {\n        const callFeed = this.localUsermediaFeed!;\n        const audioEnabled = forceAudio || (!callFeed.isAudioMuted() && !this.remoteOnHold);\n        const videoEnabled = forceVideo || (!callFeed.isVideoMuted() && !this.remoteOnHold);\n        logger.log(\n            `call ${this.callId} updateLocalUsermediaStream stream ${stream.id} audioEnabled ${audioEnabled} videoEnabled ${videoEnabled}`,\n        );\n        setTracksEnabled(stream.getAudioTracks(), audioEnabled);\n        setTracksEnabled(stream.getVideoTracks(), videoEnabled);\n\n        // We want to keep the same stream id, so we replace the tracks rather than the whole stream\n        for (const track of this.localUsermediaStream!.getTracks()) {\n            this.localUsermediaStream!.removeTrack(track);\n            track.stop();\n        }\n        for (const track of stream.getTracks()) {\n            this.localUsermediaStream!.addTrack(track);\n        }\n\n        for (const track of stream.getTracks()) {\n            const tKey = getTransceiverKey(SDPStreamMetadataPurpose.Usermedia, track.kind);\n\n            const oldSender = this.transceivers.get(tKey)?.sender;\n            let added = false;\n            if (oldSender) {\n                try {\n                    logger.info(\n                        `Call ${this.callId} ` +\n                            `Replacing track (` +\n                            `id=\"${track.id}\", ` +\n                            `kind=\"${track.kind}\", ` +\n                            `streamId=\"${stream.id}\", ` +\n                            `streamPurpose=\"${callFeed.purpose}\"` +\n                            `) to peer connection`,\n                    );\n                    await oldSender.replaceTrack(track);\n                    added = true;\n                } catch (error) {\n                    logger.warn(`replaceTrack failed: adding new transceiver instead`, error);\n                }\n            }\n\n            if (!added) {\n                logger.info(\n                    `Call ${this.callId} ` +\n                        `Adding track (` +\n                        `id=\"${track.id}\", ` +\n                        `kind=\"${track.kind}\", ` +\n                        `streamId=\"${stream.id}\", ` +\n                        `streamPurpose=\"${callFeed.purpose}\"` +\n                        `) to peer connection`,\n                );\n\n                const newSender = this.peerConn!.addTrack(track, this.localUsermediaStream!);\n                const newTransciever = this.peerConn!.getTransceivers().find((t) => t.sender === newSender);\n                if (newTransciever) {\n                    this.transceivers.set(tKey, newTransciever);\n                } else {\n                    logger.warn(\"Couldn't find matching transceiver for newly added track!\");\n                }\n            }\n        }\n    }\n\n    /**\n     * Set whether our outbound video should be muted or not.\n     * @param muted - True to mute the outbound video.\n     * @returns the new mute state\n     */\n    public async setLocalVideoMuted(muted: boolean): Promise<boolean> {\n        logger.log(`call ${this.callId} setLocalVideoMuted ${muted}`);\n        if (!(await this.client.getMediaHandler().hasVideoDevice())) {\n            return this.isLocalVideoMuted();\n        }\n\n        if (!this.hasLocalUserMediaVideoTrack && !muted) {\n            await this.upgradeCall(false, true);\n            return this.isLocalVideoMuted();\n        }\n        this.localUsermediaFeed?.setAudioVideoMuted(null, muted);\n        this.updateMuteStatus();\n        await this.sendMetadataUpdate();\n        return this.isLocalVideoMuted();\n    }\n\n    /**\n     * Check if local video is muted.\n     *\n     * If there are multiple video tracks, <i>all</i> of the tracks need to be muted\n     * for this to return true. This means if there are no video tracks, this will\n     * return true.\n     * @returns True if the local preview video is muted, else false\n     * (including if the call is not set up yet).\n     */\n    public isLocalVideoMuted(): boolean {\n        return this.localUsermediaFeed?.isVideoMuted() ?? false;\n    }\n\n    /**\n     * Set whether the microphone should be muted or not.\n     * @param muted - True to mute the mic.\n     * @returns the new mute state\n     */\n    public async setMicrophoneMuted(muted: boolean): Promise<boolean> {\n        logger.log(`call ${this.callId} setMicrophoneMuted ${muted}`);\n        if (!(await this.client.getMediaHandler().hasAudioDevice())) {\n            return this.isMicrophoneMuted();\n        }\n\n        if (!this.hasLocalUserMediaAudioTrack && !muted) {\n            await this.upgradeCall(true, false);\n            return this.isMicrophoneMuted();\n        }\n        this.localUsermediaFeed?.setAudioVideoMuted(muted, null);\n        this.updateMuteStatus();\n        await this.sendMetadataUpdate();\n        return this.isMicrophoneMuted();\n    }\n\n    /**\n     * Check if the microphone is muted.\n     *\n     * If there are multiple audio tracks, <i>all</i> of the tracks need to be muted\n     * for this to return true. This means if there are no audio tracks, this will\n     * return true.\n     * @returns True if the mic is muted, else false (including if the call\n     * is not set up yet).\n     */\n    public isMicrophoneMuted(): boolean {\n        return this.localUsermediaFeed?.isAudioMuted() ?? false;\n    }\n\n    /**\n     * @returns true if we have put the party on the other side of the call on hold\n     * (that is, we are signalling to them that we are not listening)\n     */\n    public isRemoteOnHold(): boolean {\n        return this.remoteOnHold;\n    }\n\n    public setRemoteOnHold(onHold: boolean): void {\n        if (this.isRemoteOnHold() === onHold) return;\n        this.remoteOnHold = onHold;\n\n        for (const transceiver of this.peerConn!.getTransceivers()) {\n            // We don't send hold music or anything so we're not actually\n            // sending anything, but sendrecv is fairly standard for hold and\n            // it makes it a lot easier to figure out who's put who on hold.\n            transceiver.direction = onHold ? \"sendonly\" : \"sendrecv\";\n        }\n        this.updateMuteStatus();\n        this.sendMetadataUpdate();\n\n        this.emit(CallEvent.RemoteHoldUnhold, this.remoteOnHold);\n    }\n\n    /**\n     * Indicates whether we are 'on hold' to the remote party (ie. if true,\n     * they cannot hear us).\n     * @returns true if the other party has put us on hold\n     */\n    public isLocalOnHold(): boolean {\n        if (this.state !== CallState.Connected) return false;\n\n        let callOnHold = true;\n\n        // We consider a call to be on hold only if *all* the tracks are on hold\n        // (is this the right thing to do?)\n        for (const transceiver of this.peerConn!.getTransceivers()) {\n            const trackOnHold = [\"inactive\", \"recvonly\"].includes(transceiver.currentDirection!);\n\n            if (!trackOnHold) callOnHold = false;\n        }\n\n        return callOnHold;\n    }\n\n    /**\n     * Sends a DTMF digit to the other party\n     * @param digit - The digit (nb. string - '#' and '*' are dtmf too)\n     */\n    public sendDtmfDigit(digit: string): void {\n        for (const sender of this.peerConn!.getSenders()) {\n            if (sender.track?.kind === \"audio\" && sender.dtmf) {\n                sender.dtmf.insertDTMF(digit);\n                return;\n            }\n        }\n\n        throw new Error(\"Unable to find a track to send DTMF on\");\n    }\n\n    private updateMuteStatus(): void {\n        const micShouldBeMuted = this.isMicrophoneMuted() || this.remoteOnHold;\n        const vidShouldBeMuted = this.isLocalVideoMuted() || this.remoteOnHold;\n\n        logger.log(\n            `call ${this.callId} updateMuteStatus stream ${\n                this.localUsermediaStream!.id\n            } micShouldBeMuted ${micShouldBeMuted} vidShouldBeMuted ${vidShouldBeMuted}`,\n        );\n        setTracksEnabled(this.localUsermediaStream!.getAudioTracks(), !micShouldBeMuted);\n        setTracksEnabled(this.localUsermediaStream!.getVideoTracks(), !vidShouldBeMuted);\n    }\n\n    public async sendMetadataUpdate(): Promise<void> {\n        await this.sendVoipEvent(EventType.CallSDPStreamMetadataChangedPrefix, {\n            [SDPStreamMetadataKey]: this.getLocalSDPStreamMetadata(),\n        });\n    }\n\n    private gotCallFeedsForInvite(callFeeds: CallFeed[], requestScreenshareFeed = false): void {\n        if (this.successor) {\n            this.successor.queueGotCallFeedsForAnswer(callFeeds);\n            return;\n        }\n        if (this.callHasEnded()) {\n            this.stopAllMedia();\n            return;\n        }\n\n        for (const feed of callFeeds) {\n            this.pushLocalFeed(feed);\n        }\n\n        if (requestScreenshareFeed) {\n            this.peerConn!.addTransceiver(\"video\", {\n                direction: \"recvonly\",\n            });\n        }\n\n        this.state = CallState.CreateOffer;\n\n        logger.debug(`Call ${this.callId} gotUserMediaForInvite`);\n        // Now we wait for the negotiationneeded event\n    }\n\n    private async sendAnswer(): Promise<void> {\n        const answerContent = {\n            answer: {\n                sdp: this.peerConn!.localDescription!.sdp,\n                // type is now deprecated as of Matrix VoIP v1, but\n                // required to still be sent for backwards compat\n                type: this.peerConn!.localDescription!.type,\n            },\n            [SDPStreamMetadataKey]: this.getLocalSDPStreamMetadata(true),\n        } as MCallAnswer;\n\n        answerContent.capabilities = {\n            \"m.call.transferee\": this.client.supportsCallTransfer,\n            \"m.call.dtmf\": false,\n        };\n\n        // We have just taken the local description from the peerConn which will\n        // contain all the local candidates added so far, so we can discard any candidates\n        // we had queued up because they'll be in the answer.\n        const discardCount = this.discardDuplicateCandidates();\n        logger.info(`Call ${this.callId} Discarding ${discardCount} candidates that will be sent in answer`);\n\n        try {\n            await this.sendVoipEvent(EventType.CallAnswer, answerContent);\n            // If this isn't the first time we've tried to send the answer,\n            // we may have candidates queued up, so send them now.\n            this.inviteOrAnswerSent = true;\n        } catch (error) {\n            // We've failed to answer: back to the ringing state\n            this.state = CallState.Ringing;\n            if (error instanceof MatrixError && error.event) this.client.cancelPendingEvent(error.event);\n\n            let code = CallErrorCode.SendAnswer;\n            let message = \"Failed to send answer\";\n            if ((<Error>error).name == \"UnknownDeviceError\") {\n                code = CallErrorCode.UnknownDevices;\n                message = \"Unknown devices present in the room\";\n            }\n            this.emit(CallEvent.Error, new CallError(code, message, <Error>error));\n            throw error;\n        }\n\n        // error handler re-throws so this won't happen on error, but\n        // we don't want the same error handling on the candidate queue\n        this.sendCandidateQueue();\n    }\n\n    private queueGotCallFeedsForAnswer(callFeeds: CallFeed[]): void {\n        // Ensure only one negotiate/answer event is being processed at a time.\n        if (this.responsePromiseChain) {\n            this.responsePromiseChain = this.responsePromiseChain.then(() => this.gotCallFeedsForAnswer(callFeeds));\n        } else {\n            this.responsePromiseChain = this.gotCallFeedsForAnswer(callFeeds);\n        }\n    }\n\n    // Enables DTX (discontinuous transmission) on the given session to reduce\n    // bandwidth when transmitting silence\n    private mungeSdp(description: RTCSessionDescriptionInit, mods: CodecParamsMod[]): void {\n        // The only way to enable DTX at this time is through SDP munging\n        const sdp = parseSdp(description.sdp!);\n\n        sdp.media.forEach((media) => {\n            const payloadTypeToCodecMap = new Map<number, string>();\n            const codecToPayloadTypeMap = new Map<string, number>();\n            for (const rtp of media.rtp) {\n                payloadTypeToCodecMap.set(rtp.payload, rtp.codec);\n                codecToPayloadTypeMap.set(rtp.codec, rtp.payload);\n            }\n\n            for (const mod of mods) {\n                if (mod.mediaType !== media.type) continue;\n\n                if (!codecToPayloadTypeMap.has(mod.codec)) {\n                    logger.info(`Ignoring SDP modifications for ${mod.codec} as it's not present.`);\n                    continue;\n                }\n\n                const extraconfig: string[] = [];\n                if (mod.enableDtx !== undefined) {\n                    extraconfig.push(`usedtx=${mod.enableDtx ? \"1\" : \"0\"}`);\n                }\n                if (mod.maxAverageBitrate !== undefined) {\n                    extraconfig.push(`maxaveragebitrate=${mod.maxAverageBitrate}`);\n                }\n\n                let found = false;\n                for (const fmtp of media.fmtp) {\n                    if (payloadTypeToCodecMap.get(fmtp.payload) === mod.codec) {\n                        found = true;\n                        fmtp.config += \";\" + extraconfig.join(\";\");\n                    }\n                }\n                if (!found) {\n                    media.fmtp.push({\n                        payload: codecToPayloadTypeMap.get(mod.codec)!,\n                        config: extraconfig.join(\";\"),\n                    });\n                }\n            }\n        });\n        description.sdp = writeSdp(sdp);\n    }\n\n    private async createOffer(): Promise<RTCSessionDescriptionInit> {\n        const offer = await this.peerConn!.createOffer();\n        this.mungeSdp(offer, getCodecParamMods(this.isPtt));\n        return offer;\n    }\n\n    private async createAnswer(): Promise<RTCSessionDescriptionInit> {\n        const answer = await this.peerConn!.createAnswer();\n        this.mungeSdp(answer, getCodecParamMods(this.isPtt));\n        return answer;\n    }\n\n    private async gotCallFeedsForAnswer(callFeeds: CallFeed[]): Promise<void> {\n        if (this.callHasEnded()) return;\n\n        this.waitForLocalAVStream = false;\n\n        for (const feed of callFeeds) {\n            this.pushLocalFeed(feed);\n        }\n\n        this.state = CallState.CreateAnswer;\n\n        let answer: RTCSessionDescriptionInit;\n        try {\n            this.getRidOfRTXCodecs();\n            answer = await this.createAnswer();\n        } catch (err) {\n            logger.debug(`Call ${this.callId} Failed to create answer: `, err);\n            this.terminate(CallParty.Local, CallErrorCode.CreateAnswer, true);\n            return;\n        }\n\n        try {\n            await this.peerConn!.setLocalDescription(answer);\n\n            // make sure we're still going\n            if (this.callHasEnded()) return;\n\n            this.state = CallState.Connecting;\n\n            // Allow a short time for initial candidates to be gathered\n            await new Promise((resolve) => {\n                setTimeout(resolve, 200);\n            });\n\n            // make sure the call hasn't ended before we continue\n            if (this.callHasEnded()) return;\n\n            this.sendAnswer();\n        } catch (err) {\n            logger.debug(`Call ${this.callId} Error setting local description!`, err);\n            this.terminate(CallParty.Local, CallErrorCode.SetLocalDescription, true);\n            return;\n        }\n    }\n\n    /**\n     * Internal\n     */\n    private gotLocalIceCandidate = (event: RTCPeerConnectionIceEvent): void => {\n        if (event.candidate) {\n            if (this.candidatesEnded) {\n                logger.warn(\"Got candidate after candidates have ended - ignoring!\");\n                return;\n            }\n\n            logger.debug(\n                \"Call \" +\n                    this.callId +\n                    \" got local ICE \" +\n                    event.candidate.sdpMid +\n                    \" candidate: \" +\n                    event.candidate.candidate,\n            );\n\n            if (this.callHasEnded()) return;\n\n            // As with the offer, note we need to make a copy of this object, not\n            // pass the original: that broke in Chrome ~m43.\n            if (event.candidate.candidate === \"\") {\n                this.queueCandidate(null);\n            } else {\n                this.queueCandidate(event.candidate);\n            }\n        }\n    };\n\n    private onIceGatheringStateChange = (event: Event): void => {\n        logger.debug(`Call ${this.callId} ice gathering state changed to  ${this.peerConn!.iceGatheringState}`);\n        if (this.peerConn?.iceGatheringState === \"complete\") {\n            this.queueCandidate(null);\n        }\n    };\n\n    public async onRemoteIceCandidatesReceived(ev: MatrixEvent): Promise<void> {\n        if (this.callHasEnded()) {\n            //debuglog(\"Ignoring remote ICE candidate because call has ended\");\n            return;\n        }\n\n        const content = ev.getContent<MCallCandidates>();\n        const candidates = content.candidates;\n        if (!candidates) {\n            logger.info(`Call ${this.callId} Ignoring candidates event with no candidates!`);\n            return;\n        }\n\n        const fromPartyId = content.version === 0 ? null : content.party_id || null;\n\n        if (this.opponentPartyId === undefined) {\n            // we haven't picked an opponent yet so save the candidates\n            if (fromPartyId) {\n                logger.info(`Call ${this.callId} Buffering ${candidates.length} candidates until we pick an opponent`);\n                const bufferedCandidates = this.remoteCandidateBuffer.get(fromPartyId) || [];\n                bufferedCandidates.push(...candidates);\n                this.remoteCandidateBuffer.set(fromPartyId, bufferedCandidates);\n            }\n            return;\n        }\n\n        if (!this.partyIdMatches(content)) {\n            logger.info(\n                `Call ${this.callId} ` +\n                    `Ignoring candidates from party ID ${content.party_id}: ` +\n                    `we have chosen party ID ${this.opponentPartyId}`,\n            );\n\n            return;\n        }\n\n        await this.addIceCandidates(candidates);\n    }\n\n    /**\n     * Used by MatrixClient.\n     */\n    public async onAnswerReceived(event: MatrixEvent): Promise<void> {\n        const content = event.getContent<MCallAnswer>();\n        logger.debug(`Got answer for call ID ${this.callId} from party ID ${content.party_id}`);\n\n        if (this.callHasEnded()) {\n            logger.debug(`Ignoring answer because call ID ${this.callId} has ended`);\n            return;\n        }\n\n        if (this.opponentPartyId !== undefined) {\n            logger.info(\n                `Call ${this.callId} ` +\n                    `Ignoring answer from party ID ${content.party_id}: ` +\n                    `we already have an answer/reject from ${this.opponentPartyId}`,\n            );\n            return;\n        }\n\n        this.chooseOpponent(event);\n        await this.addBufferedIceCandidates();\n\n        this.state = CallState.Connecting;\n\n        const sdpStreamMetadata = content[SDPStreamMetadataKey];\n        if (sdpStreamMetadata) {\n            this.updateRemoteSDPStreamMetadata(sdpStreamMetadata);\n        } else {\n            logger.warn(`Call ${this.callId} Did not get any SDPStreamMetadata! Can not send/receive multiple streams`);\n        }\n\n        try {\n            await this.peerConn!.setRemoteDescription(content.answer);\n        } catch (e) {\n            logger.debug(`Call ${this.callId} Failed to set remote description`, e);\n            this.terminate(CallParty.Local, CallErrorCode.SetRemoteDescription, false);\n            return;\n        }\n\n        // If the answer we selected has a party_id, send a select_answer event\n        // We do this after setting the remote description since otherwise we'd block\n        // call setup on it\n        if (this.opponentPartyId !== null) {\n            try {\n                await this.sendVoipEvent(EventType.CallSelectAnswer, {\n                    selected_party_id: this.opponentPartyId,\n                });\n            } catch (err) {\n                // This isn't fatal, and will just mean that if another party has raced to answer\n                // the call, they won't know they got rejected, so we carry on & don't retry.\n                logger.warn(`Call ${this.callId} Failed to send select_answer event`, err);\n            }\n        }\n    }\n\n    public async onSelectAnswerReceived(event: MatrixEvent): Promise<void> {\n        if (this.direction !== CallDirection.Inbound) {\n            logger.warn(`Call ${this.callId} Got select_answer for an outbound call: ignoring`);\n            return;\n        }\n\n        const selectedPartyId = event.getContent<MCallSelectAnswer>().selected_party_id;\n\n        if (selectedPartyId === undefined || selectedPartyId === null) {\n            logger.warn(\n                `Call ${this.callId} Got nonsensical select_answer with null/undefined selected_party_id: ignoring`,\n            );\n            return;\n        }\n\n        if (selectedPartyId !== this.ourPartyId) {\n            logger.info(\n                `Call ${this.callId} Got select_answer for party ID ${selectedPartyId}: we are party ID ${this.ourPartyId}.`,\n            );\n            // The other party has picked somebody else's answer\n            await this.terminate(CallParty.Remote, CallErrorCode.AnsweredElsewhere, true);\n        }\n    }\n\n    public async onNegotiateReceived(event: MatrixEvent): Promise<void> {\n        const content = event.getContent<MCallInviteNegotiate>();\n        const description = content.description;\n        if (!description || !description.sdp || !description.type) {\n            logger.info(`Call ${this.callId} Ignoring invalid m.call.negotiate event`);\n            return;\n        }\n        // Politeness always follows the direction of the call: in a glare situation,\n        // we pick either the inbound or outbound call, so one side will always be\n        // inbound and one outbound\n        const polite = this.direction === CallDirection.Inbound;\n\n        // Here we follow the perfect negotiation logic from\n        // https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Perfect_negotiation\n        const offerCollision =\n            description.type === \"offer\" && (this.makingOffer || this.peerConn!.signalingState !== \"stable\");\n\n        this.ignoreOffer = !polite && offerCollision;\n        if (this.ignoreOffer) {\n            logger.info(`Call ${this.callId} Ignoring colliding negotiate event because we're impolite`);\n            return;\n        }\n\n        const prevLocalOnHold = this.isLocalOnHold();\n\n        const sdpStreamMetadata = content[SDPStreamMetadataKey];\n        if (sdpStreamMetadata) {\n            this.updateRemoteSDPStreamMetadata(sdpStreamMetadata);\n        } else {\n            logger.warn(`Call ${this.callId} Received negotiation event without SDPStreamMetadata!`);\n        }\n\n        try {\n            await this.peerConn!.setRemoteDescription(description);\n\n            if (description.type === \"offer\") {\n                let answer: RTCSessionDescriptionInit;\n                try {\n                    this.getRidOfRTXCodecs();\n                    answer = await this.createAnswer();\n                } catch (err) {\n                    logger.debug(`Call ${this.callId} Failed to create answer: `, err);\n                    this.terminate(CallParty.Local, CallErrorCode.CreateAnswer, true);\n                    return;\n                }\n\n                await this.peerConn!.setLocalDescription(answer);\n\n                this.sendVoipEvent(EventType.CallNegotiate, {\n                    description: this.peerConn!.localDescription?.toJSON(),\n                    [SDPStreamMetadataKey]: this.getLocalSDPStreamMetadata(true),\n                });\n            }\n        } catch (err) {\n            logger.warn(`Call ${this.callId} Failed to complete negotiation`, err);\n        }\n\n        const newLocalOnHold = this.isLocalOnHold();\n        if (prevLocalOnHold !== newLocalOnHold) {\n            this.emit(CallEvent.LocalHoldUnhold, newLocalOnHold);\n            // also this one for backwards compat\n            this.emit(CallEvent.HoldUnhold, newLocalOnHold);\n        }\n    }\n\n    private updateRemoteSDPStreamMetadata(metadata: SDPStreamMetadata): void {\n        this.remoteSDPStreamMetadata = utils.recursivelyAssign(this.remoteSDPStreamMetadata || {}, metadata, true);\n        for (const feed of this.getRemoteFeeds()) {\n            const streamId = feed.stream.id;\n            const metadata = this.remoteSDPStreamMetadata![streamId];\n\n            feed.setAudioVideoMuted(metadata?.audio_muted, metadata?.video_muted);\n            feed.purpose = this.remoteSDPStreamMetadata![streamId]?.purpose;\n        }\n    }\n\n    public onSDPStreamMetadataChangedReceived(event: MatrixEvent): void {\n        const content = event.getContent<MCallSDPStreamMetadataChanged>();\n        const metadata = content[SDPStreamMetadataKey];\n        this.updateRemoteSDPStreamMetadata(metadata);\n    }\n\n    public async onAssertedIdentityReceived(event: MatrixEvent): Promise<void> {\n        const content = event.getContent<MCAllAssertedIdentity>();\n        if (!content.asserted_identity) return;\n\n        this.remoteAssertedIdentity = {\n            id: content.asserted_identity.id,\n            displayName: content.asserted_identity.display_name,\n        };\n        this.emit(CallEvent.AssertedIdentityChanged);\n    }\n\n    public callHasEnded(): boolean {\n        // This exists as workaround to typescript trying to be clever and erroring\n        // when putting if (this.state === CallState.Ended) return; twice in the same\n        // function, even though that function is async.\n        return this.state === CallState.Ended;\n    }\n\n    private queueGotLocalOffer(): void {\n        // Ensure only one negotiate/answer event is being processed at a time.\n        if (this.responsePromiseChain) {\n            this.responsePromiseChain = this.responsePromiseChain.then(() => this.wrappedGotLocalOffer());\n        } else {\n            this.responsePromiseChain = this.wrappedGotLocalOffer();\n        }\n    }\n\n    private async wrappedGotLocalOffer(): Promise<void> {\n        this.makingOffer = true;\n        try {\n            await this.gotLocalOffer();\n        } catch (e) {\n            this.getLocalOfferFailed(e as Error);\n            return;\n        } finally {\n            this.makingOffer = false;\n        }\n    }\n\n    private async gotLocalOffer(): Promise<void> {\n        logger.debug(`Call ${this.callId} Setting local description`);\n\n        if (this.callHasEnded()) {\n            logger.debug(\"Ignoring newly created offer on call ID \" + this.callId + \" because the call has ended\");\n            return;\n        }\n\n        let offer: RTCSessionDescriptionInit;\n        try {\n            this.getRidOfRTXCodecs();\n            offer = await this.createOffer();\n        } catch (err) {\n            logger.debug(`Call ${this.callId} Failed to create offer: `, err);\n            this.terminate(CallParty.Local, CallErrorCode.CreateOffer, true);\n            return;\n        }\n\n        try {\n            await this.peerConn!.setLocalDescription(offer);\n        } catch (err) {\n            logger.debug(`Call ${this.callId} Error setting local description!`, err);\n            this.terminate(CallParty.Local, CallErrorCode.SetLocalDescription, true);\n            return;\n        }\n\n        if (this.peerConn!.iceGatheringState === \"gathering\") {\n            // Allow a short time for initial candidates to be gathered\n            await new Promise((resolve) => {\n                setTimeout(resolve, 200);\n            });\n        }\n\n        if (this.callHasEnded()) return;\n\n        const eventType = this.state === CallState.CreateOffer ? EventType.CallInvite : EventType.CallNegotiate;\n\n        const content = {\n            lifetime: CALL_TIMEOUT_MS,\n        } as MCallInviteNegotiate;\n\n        if (eventType === EventType.CallInvite && this.invitee) {\n            content.invitee = this.invitee;\n        }\n\n        // clunky because TypeScript can't follow the types through if we use an expression as the key\n        if (this.state === CallState.CreateOffer) {\n            content.offer = this.peerConn!.localDescription?.toJSON();\n        } else {\n            content.description = this.peerConn!.localDescription?.toJSON();\n        }\n\n        content.capabilities = {\n            \"m.call.transferee\": this.client.supportsCallTransfer,\n            \"m.call.dtmf\": false,\n        };\n\n        content[SDPStreamMetadataKey] = this.getLocalSDPStreamMetadata(true);\n\n        // Get rid of any candidates waiting to be sent: they'll be included in the local\n        // description we just got and will send in the offer.\n        const discardCount = this.discardDuplicateCandidates();\n        logger.info(`Call ${this.callId} Discarding ${discardCount} candidates that will be sent in offer`);\n\n        try {\n            await this.sendVoipEvent(eventType, content);\n        } catch (error) {\n            logger.error(`Call ${this.callId} Failed to send invite`, error);\n            if (error instanceof MatrixError && error.event) this.client.cancelPendingEvent(error.event);\n\n            let code = CallErrorCode.SignallingFailed;\n            let message = \"Signalling failed\";\n            if (this.state === CallState.CreateOffer) {\n                code = CallErrorCode.SendInvite;\n                message = \"Failed to send invite\";\n            }\n            if ((<Error>error).name == \"UnknownDeviceError\") {\n                code = CallErrorCode.UnknownDevices;\n                message = \"Unknown devices present in the room\";\n            }\n\n            this.emit(CallEvent.Error, new CallError(code, message, <Error>error));\n            this.terminate(CallParty.Local, code, false);\n\n            // no need to carry on & send the candidate queue, but we also\n            // don't want to rethrow the error\n            return;\n        }\n\n        this.sendCandidateQueue();\n        if (this.state === CallState.CreateOffer) {\n            this.inviteOrAnswerSent = true;\n            this.state = CallState.InviteSent;\n            this.inviteTimeout = setTimeout(() => {\n                this.inviteTimeout = undefined;\n                if (this.state === CallState.InviteSent) {\n                    this.hangup(CallErrorCode.InviteTimeout, false);\n                }\n            }, CALL_TIMEOUT_MS);\n        }\n    }\n\n    private getLocalOfferFailed = (err: Error): void => {\n        logger.error(`Call ${this.callId} Failed to get local offer`, err);\n\n        this.emit(CallEvent.Error, new CallError(CallErrorCode.LocalOfferFailed, \"Failed to get local offer!\", err));\n        this.terminate(CallParty.Local, CallErrorCode.LocalOfferFailed, false);\n    };\n\n    private getUserMediaFailed = (err: Error): void => {\n        if (this.successor) {\n            this.successor.getUserMediaFailed(err);\n            return;\n        }\n\n        logger.warn(`Failed to get user media - ending call ${this.callId}`, err);\n\n        this.emit(\n            CallEvent.Error,\n            new CallError(\n                CallErrorCode.NoUserMedia,\n                \"Couldn't start capturing media! Is your microphone set up and \" + \"does this app have permission?\",\n                err,\n            ),\n        );\n        this.terminate(CallParty.Local, CallErrorCode.NoUserMedia, false);\n    };\n\n    private onIceConnectionStateChanged = (): void => {\n        if (this.callHasEnded()) {\n            return; // because ICE can still complete as we're ending the call\n        }\n        logger.debug(\n            \"Call ID \" + this.callId + \": ICE connection state changed to: \" + this.peerConn?.iceConnectionState,\n        );\n\n        // ideally we'd consider the call to be connected when we get media but\n        // chrome doesn't implement any of the 'onstarted' events yet\n        if ([\"connected\", \"completed\"].includes(this.peerConn?.iceConnectionState ?? \"\")) {\n            clearTimeout(this.iceDisconnectedTimeout);\n            this.state = CallState.Connected;\n\n            if (!this.callLengthInterval && !this.callStartTime) {\n                this.callStartTime = Date.now();\n\n                this.callLengthInterval = setInterval(() => {\n                    this.emit(CallEvent.LengthChanged, Math.round((Date.now() - this.callStartTime!) / 1000));\n                }, CALL_LENGTH_INTERVAL);\n            }\n        } else if (this.peerConn?.iceConnectionState == \"failed\") {\n            // Firefox for Android does not yet have support for restartIce()\n            // (the types say it's always defined though, so we have to cast\n            // to prevent typescript from warning).\n            if (this.peerConn?.restartIce as (() => void) | null) {\n                this.candidatesEnded = false;\n                this.peerConn!.restartIce();\n            } else {\n                logger.info(`Hanging up call ${this.callId} (ICE failed and no ICE restart method)`);\n                this.hangup(CallErrorCode.IceFailed, false);\n            }\n        } else if (this.peerConn?.iceConnectionState == \"disconnected\") {\n            this.iceDisconnectedTimeout = setTimeout(() => {\n                logger.info(`Hanging up call ${this.callId} (ICE disconnected for too long)`);\n                this.hangup(CallErrorCode.IceFailed, false);\n            }, ICE_DISCONNECTED_TIMEOUT);\n            this.state = CallState.Connecting;\n        }\n\n        // In PTT mode, override feed status to muted when we lose connection to\n        // the peer, since we don't want to block the line if they're not saying anything.\n        // Experimenting in Chrome, this happens after 5 or 6 seconds, which is probably\n        // fast enough.\n        if (this.isPtt && [\"failed\", \"disconnected\"].includes(this.peerConn!.iceConnectionState)) {\n            for (const feed of this.getRemoteFeeds()) {\n                feed.setAudioVideoMuted(true, true);\n            }\n        }\n    };\n\n    private onSignallingStateChanged = (): void => {\n        logger.debug(`call ${this.callId}: Signalling state changed to: ${this.peerConn?.signalingState}`);\n    };\n\n    private onTrack = (ev: RTCTrackEvent): void => {\n        if (ev.streams.length === 0) {\n            logger.warn(`Call ${this.callId} Streamless ${ev.track.kind} found: ignoring.`);\n            return;\n        }\n\n        const stream = ev.streams[0];\n        this.pushRemoteFeed(stream);\n\n        if (!this.removeTrackListeners.has(stream)) {\n            const onRemoveTrack = (): void => {\n                if (stream.getTracks().length === 0) {\n                    logger.info(`Call ${this.callId} removing track streamId: ${stream.id}`);\n                    this.deleteFeedByStream(stream);\n                    stream.removeEventListener(\"removetrack\", onRemoveTrack);\n                    this.removeTrackListeners.delete(stream);\n                }\n            };\n            stream.addEventListener(\"removetrack\", onRemoveTrack);\n            this.removeTrackListeners.set(stream, onRemoveTrack);\n        }\n    };\n\n    private onDataChannel = (ev: RTCDataChannelEvent): void => {\n        this.emit(CallEvent.DataChannel, ev.channel);\n    };\n\n    /**\n     * This method removes all video/rtx codecs from screensharing video\n     * transceivers. This is necessary since they can cause problems. Without\n     * this the following steps should produce an error:\n     *   Chromium calls Firefox\n     *   Firefox answers\n     *   Firefox starts screen-sharing\n     *   Chromium starts screen-sharing\n     *   Call crashes for Chromium with:\n     *       [96685:23:0518/162603.933321:ERROR:webrtc_video_engine.cc(3296)] RTX codec (PT=97) mapped to PT=96 which is not in the codec list.\n     *       [96685:23:0518/162603.933377:ERROR:webrtc_video_engine.cc(1171)] GetChangedRecvParameters called without any video codecs.\n     *       [96685:23:0518/162603.933430:ERROR:sdp_offer_answer.cc(4302)] Failed to set local video description recv parameters for m-section with mid='2'. (INVALID_PARAMETER)\n     */\n    private getRidOfRTXCodecs(): void {\n        // RTCRtpReceiver.getCapabilities and RTCRtpSender.getCapabilities don't seem to be supported on FF\n        if (!RTCRtpReceiver.getCapabilities || !RTCRtpSender.getCapabilities) return;\n\n        const recvCodecs = RTCRtpReceiver.getCapabilities(\"video\")!.codecs;\n        const sendCodecs = RTCRtpSender.getCapabilities(\"video\")!.codecs;\n        const codecs = [...sendCodecs, ...recvCodecs];\n\n        for (const codec of codecs) {\n            if (codec.mimeType === \"video/rtx\") {\n                const rtxCodecIndex = codecs.indexOf(codec);\n                codecs.splice(rtxCodecIndex, 1);\n            }\n        }\n\n        const screenshareVideoTransceiver = this.transceivers.get(\n            getTransceiverKey(SDPStreamMetadataPurpose.Screenshare, \"video\"),\n        );\n        if (screenshareVideoTransceiver) screenshareVideoTransceiver.setCodecPreferences(codecs);\n    }\n\n    private onNegotiationNeeded = async (): Promise<void> => {\n        logger.info(`Call ${this.callId} Negotiation is needed!`);\n\n        if (this.state !== CallState.CreateOffer && this.opponentVersion === 0) {\n            logger.info(\n                `Call ${this.callId} Opponent does not support renegotiation: ignoring negotiationneeded event`,\n            );\n            return;\n        }\n\n        this.queueGotLocalOffer();\n    };\n\n    public onHangupReceived = (msg: MCallHangupReject): void => {\n        logger.debug(\"Hangup received for call ID \" + this.callId);\n\n        // party ID must match (our chosen partner hanging up the call) or be undefined (we haven't chosen\n        // a partner yet but we're treating the hangup as a reject as per VoIP v0)\n        if (this.partyIdMatches(msg) || this.state === CallState.Ringing) {\n            // default reason is user_hangup\n            this.terminate(CallParty.Remote, msg.reason || CallErrorCode.UserHangup, true);\n        } else {\n            logger.info(\n                `Call ${this.callId} Ignoring message from party ID ${msg.party_id}: our partner is ${this.opponentPartyId}`,\n            );\n        }\n    };\n\n    public onRejectReceived = (msg: MCallHangupReject): void => {\n        logger.debug(\"Reject received for call ID \" + this.callId);\n\n        // No need to check party_id for reject because if we'd received either\n        // an answer or reject, we wouldn't be in state InviteSent\n\n        const shouldTerminate =\n            // reject events also end the call if it's ringing: it's another of\n            // our devices rejecting the call.\n            [CallState.InviteSent, CallState.Ringing].includes(this.state) ||\n            // also if we're in the init state and it's an inbound call, since\n            // this means we just haven't entered the ringing state yet\n            (this.state === CallState.Fledgling && this.direction === CallDirection.Inbound);\n\n        if (shouldTerminate) {\n            this.terminate(CallParty.Remote, msg.reason || CallErrorCode.UserHangup, true);\n        } else {\n            logger.debug(`Call ${this.callId} is in state: ${this.state}: ignoring reject`);\n        }\n    };\n\n    public onAnsweredElsewhere = (msg: MCallAnswer): void => {\n        logger.debug(\"Call \" + this.callId + \" answered elsewhere\");\n        this.terminate(CallParty.Remote, CallErrorCode.AnsweredElsewhere, true);\n    };\n\n    /**\n     * @internal\n     */\n    private async sendVoipEvent(eventType: string, content: object): Promise<void> {\n        const realContent = Object.assign({}, content, {\n            version: VOIP_PROTO_VERSION,\n            call_id: this.callId,\n            party_id: this.ourPartyId,\n            conf_id: this.groupCallId,\n        });\n\n        if (this.opponentDeviceId) {\n            const toDeviceSeq = this.toDeviceSeq++;\n            const content = {\n                ...realContent,\n                device_id: this.client.deviceId,\n                sender_session_id: this.client.getSessionId(),\n                dest_session_id: this.opponentSessionId,\n                seq: toDeviceSeq,\n                [ToDeviceMessageId]: uuidv4(),\n            };\n\n            this.emit(CallEvent.SendVoipEvent, {\n                type: \"toDevice\",\n                eventType,\n                userId: this.invitee || this.getOpponentMember()?.userId,\n                opponentDeviceId: this.opponentDeviceId,\n                content,\n            });\n\n            const userId = this.invitee || this.getOpponentMember()!.userId;\n            if (this.client.getUseE2eForGroupCall()) {\n                await this.client.encryptAndSendToDevices(\n                    [\n                        {\n                            userId,\n                            deviceInfo: this.opponentDeviceInfo!,\n                        },\n                    ],\n                    {\n                        type: eventType,\n                        content,\n                    },\n                );\n            } else {\n                await this.client.sendToDevice(eventType, {\n                    [userId]: {\n                        [this.opponentDeviceId]: content,\n                    },\n                });\n            }\n        } else {\n            this.emit(CallEvent.SendVoipEvent, {\n                type: \"sendEvent\",\n                eventType,\n                roomId: this.roomId,\n                content: realContent,\n                userId: this.invitee || this.getOpponentMember()?.userId,\n            });\n\n            await this.client.sendEvent(this.roomId!, eventType, realContent);\n        }\n    }\n\n    /**\n     * Queue a candidate to be sent\n     * @param content - The candidate to queue up, or null if candidates have finished being generated\n     *                and end-of-candidates should be signalled\n     */\n    private queueCandidate(content: RTCIceCandidate | null): void {\n        // We partially de-trickle candidates by waiting for `delay` before sending them\n        // amalgamated, in order to avoid sending too many m.call.candidates events and hitting\n        // rate limits in Matrix.\n        // In practice, it'd be better to remove rate limits for m.call.*\n\n        // N.B. this deliberately lets you queue and send blank candidates, which MSC2746\n        // currently proposes as the way to indicate that candidate gathering is complete.\n        // This will hopefully be changed to an explicit rather than implicit notification\n        // shortly.\n        if (content) {\n            this.candidateSendQueue.push(content);\n        } else {\n            this.candidatesEnded = true;\n        }\n\n        // Don't send the ICE candidates yet if the call is in the ringing state: this\n        // means we tried to pick (ie. started generating candidates) and then failed to\n        // send the answer and went back to the ringing state. Queue up the candidates\n        // to send if we successfully send the answer.\n        // Equally don't send if we haven't yet sent the answer because we can send the\n        // first batch of candidates along with the answer\n        if (this.state === CallState.Ringing || !this.inviteOrAnswerSent) return;\n\n        // MSC2746 recommends these values (can be quite long when calling because the\n        // callee will need a while to answer the call)\n        const delay = this.direction === CallDirection.Inbound ? 500 : 2000;\n\n        if (this.candidateSendTries === 0) {\n            setTimeout(() => {\n                this.sendCandidateQueue();\n            }, delay);\n        }\n    }\n\n    // Discard all non-end-of-candidates messages\n    // Return the number of candidate messages that were discarded.\n    // Call this method before sending an invite or answer message\n    private discardDuplicateCandidates(): number {\n        let discardCount = 0;\n        const newQueue: RTCIceCandidate[] = [];\n\n        for (let i = 0; i < this.candidateSendQueue.length; i++) {\n            const candidate = this.candidateSendQueue[i];\n            if (candidate.candidate === \"\") {\n                newQueue.push(candidate);\n            } else {\n                discardCount++;\n            }\n        }\n\n        this.candidateSendQueue = newQueue;\n\n        return discardCount;\n    }\n\n    /*\n     * Transfers this call to another user\n     */\n    public async transfer(targetUserId: string): Promise<void> {\n        // Fetch the target user's global profile info: their room avatar / displayname\n        // could be different in whatever room we share with them.\n        const profileInfo = await this.client.getProfileInfo(targetUserId);\n\n        const replacementId = genCallID();\n\n        const body = {\n            replacement_id: genCallID(),\n            target_user: {\n                id: targetUserId,\n                display_name: profileInfo.displayname,\n                avatar_url: profileInfo.avatar_url,\n            },\n            create_call: replacementId,\n        } as MCallReplacesEvent;\n\n        await this.sendVoipEvent(EventType.CallReplaces, body);\n\n        await this.terminate(CallParty.Local, CallErrorCode.Transfered, true);\n    }\n\n    /*\n     * Transfers this call to the target call, effectively 'joining' the\n     * two calls (so the remote parties on each call are connected together).\n     */\n    public async transferToCall(transferTargetCall: MatrixCall): Promise<void> {\n        const targetUserId = transferTargetCall.getOpponentMember()?.userId;\n        const targetProfileInfo = targetUserId ? await this.client.getProfileInfo(targetUserId) : undefined;\n        const opponentUserId = this.getOpponentMember()?.userId;\n        const transfereeProfileInfo = opponentUserId ? await this.client.getProfileInfo(opponentUserId) : undefined;\n\n        const newCallId = genCallID();\n\n        const bodyToTransferTarget = {\n            // the replacements on each side have their own ID, and it's distinct from the\n            // ID of the new call (but we can use the same function to generate it)\n            replacement_id: genCallID(),\n            target_user: {\n                id: opponentUserId,\n                display_name: transfereeProfileInfo?.displayname,\n                avatar_url: transfereeProfileInfo?.avatar_url,\n            },\n            await_call: newCallId,\n        } as MCallReplacesEvent;\n\n        await transferTargetCall.sendVoipEvent(EventType.CallReplaces, bodyToTransferTarget);\n\n        const bodyToTransferee = {\n            replacement_id: genCallID(),\n            target_user: {\n                id: targetUserId,\n                display_name: targetProfileInfo?.displayname,\n                avatar_url: targetProfileInfo?.avatar_url,\n            },\n            create_call: newCallId,\n        } as MCallReplacesEvent;\n\n        await this.sendVoipEvent(EventType.CallReplaces, bodyToTransferee);\n\n        await this.terminate(CallParty.Local, CallErrorCode.Transfered, true);\n        await transferTargetCall.terminate(CallParty.Local, CallErrorCode.Transfered, true);\n    }\n\n    private async terminate(hangupParty: CallParty, hangupReason: CallErrorCode, shouldEmit: boolean): Promise<void> {\n        if (this.callHasEnded()) return;\n\n        this.hangupParty = hangupParty;\n        this.hangupReason = hangupReason;\n        this.state = CallState.Ended;\n\n        if (this.inviteTimeout) {\n            clearTimeout(this.inviteTimeout);\n            this.inviteTimeout = undefined;\n        }\n        if (this.callLengthInterval) {\n            clearInterval(this.callLengthInterval);\n            this.callLengthInterval = undefined;\n        }\n\n        for (const [stream, listener] of this.removeTrackListeners) {\n            stream.removeEventListener(\"removetrack\", listener);\n        }\n        this.removeTrackListeners.clear();\n\n        this.callStatsAtEnd = await this.collectCallStats();\n\n        // Order is important here: first we stopAllMedia() and only then we can deleteAllFeeds()\n        this.stopAllMedia();\n        this.deleteAllFeeds();\n\n        if (this.peerConn && this.peerConn.signalingState !== \"closed\") {\n            this.peerConn.close();\n        }\n        if (shouldEmit) {\n            this.emit(CallEvent.Hangup, this);\n        }\n\n        this.client.callEventHandler!.calls.delete(this.callId);\n    }\n\n    private stopAllMedia(): void {\n        logger.debug(`Call ${this.callId} stopping all media`);\n\n        for (const feed of this.feeds) {\n            // Slightly awkward as local feed need to go via the correct method on\n            // the mediahandler so they get removed from mediahandler (remote tracks\n            // don't)\n            // NB. We clone local streams when passing them to individual calls in a group\n            // call, so we can (and should) stop the clones once we no longer need them:\n            // the other clones will continue fine.\n            if (feed.isLocal() && feed.purpose === SDPStreamMetadataPurpose.Usermedia) {\n                this.client.getMediaHandler().stopUserMediaStream(feed.stream);\n            } else if (feed.isLocal() && feed.purpose === SDPStreamMetadataPurpose.Screenshare) {\n                this.client.getMediaHandler().stopScreensharingStream(feed.stream);\n            } else if (!feed.isLocal()) {\n                logger.debug(\"Stopping remote stream\", feed.stream.id);\n                for (const track of feed.stream.getTracks()) {\n                    track.stop();\n                }\n            }\n        }\n    }\n\n    private checkForErrorListener(): void {\n        if (this.listeners(EventEmitterEvents.Error).length === 0) {\n            throw new Error(\"You MUST attach an error listener using call.on('error', function() {})\");\n        }\n    }\n\n    private async sendCandidateQueue(): Promise<void> {\n        if (this.candidateSendQueue.length === 0 || this.callHasEnded()) {\n            return;\n        }\n\n        const candidates = this.candidateSendQueue;\n        this.candidateSendQueue = [];\n        ++this.candidateSendTries;\n        const content = { candidates: candidates.map((candidate) => candidate.toJSON()) };\n        if (this.candidatesEnded) {\n            // If there are no more candidates, signal this by adding an empty string candidate\n            content.candidates.push({\n                candidate: \"\",\n            });\n        }\n        logger.debug(`Call ${this.callId} attempting to send ${candidates.length} candidates`);\n        try {\n            await this.sendVoipEvent(EventType.CallCandidates, content);\n            // reset our retry count if we have successfully sent our candidates\n            // otherwise queueCandidate() will refuse to try to flush the queue\n            this.candidateSendTries = 0;\n\n            // Try to send candidates again just in case we received more candidates while sending.\n            this.sendCandidateQueue();\n        } catch (error) {\n            // don't retry this event: we'll send another one later as we might\n            // have more candidates by then.\n            if (error instanceof MatrixError && error.event) this.client.cancelPendingEvent(error.event);\n\n            // put all the candidates we failed to send back in the queue\n            this.candidateSendQueue.push(...candidates);\n\n            if (this.candidateSendTries > 5) {\n                logger.debug(\n                    `Call ${this.callId} failed to send candidates on attempt ${this.candidateSendTries}. Giving up on this call.`,\n                    error,\n                );\n\n                const code = CallErrorCode.SignallingFailed;\n                const message = \"Signalling failed\";\n\n                this.emit(CallEvent.Error, new CallError(code, message, <Error>error));\n                this.hangup(code, false);\n\n                return;\n            }\n\n            const delayMs = 500 * Math.pow(2, this.candidateSendTries);\n            ++this.candidateSendTries;\n            logger.debug(`Call ${this.callId} failed to send candidates. Retrying in ${delayMs}ms`, error);\n            setTimeout(() => {\n                this.sendCandidateQueue();\n            }, delayMs);\n        }\n    }\n\n    /**\n     * Place a call to this room.\n     * @throws if you have not specified a listener for 'error' events.\n     * @throws if have passed audio=false.\n     */\n    public async placeCall(audio: boolean, video: boolean): Promise<void> {\n        if (!audio) {\n            throw new Error(\"You CANNOT start a call without audio\");\n        }\n        this.state = CallState.WaitLocalMedia;\n\n        try {\n            const stream = await this.client.getMediaHandler().getUserMediaStream(audio, video);\n\n            // make sure all the tracks are enabled (same as pushNewLocalFeed -\n            // we probably ought to just have one code path for adding streams)\n            setTracksEnabled(stream.getAudioTracks(), true);\n            setTracksEnabled(stream.getVideoTracks(), true);\n\n            const callFeed = new CallFeed({\n                client: this.client,\n                roomId: this.roomId,\n                userId: this.client.getUserId()!,\n                deviceId: this.client.getDeviceId() ?? undefined,\n                stream,\n                purpose: SDPStreamMetadataPurpose.Usermedia,\n                audioMuted: false,\n                videoMuted: false,\n            });\n            await this.placeCallWithCallFeeds([callFeed]);\n        } catch (e) {\n            this.getUserMediaFailed(<Error>e);\n            return;\n        }\n    }\n\n    /**\n     * Place a call to this room with call feed.\n     * @param callFeeds - to use\n     * @throws if you have not specified a listener for 'error' events.\n     * @throws if have passed audio=false.\n     */\n    public async placeCallWithCallFeeds(callFeeds: CallFeed[], requestScreenshareFeed = false): Promise<void> {\n        this.checkForErrorListener();\n        this.direction = CallDirection.Outbound;\n\n        await this.initOpponentCrypto();\n\n        // XXX Find a better way to do this\n        this.client.callEventHandler!.calls.set(this.callId, this);\n\n        // make sure we have valid turn creds. Unless something's gone wrong, it should\n        // poll and keep the credentials valid so this should be instant.\n        const haveTurnCreds = await this.client.checkTurnServers();\n        if (!haveTurnCreds) {\n            logger.warn(`Call ${this.callId} Failed to get TURN credentials! Proceeding with call anyway...`);\n        }\n\n        // create the peer connection now so it can be gathering candidates while we get user\n        // media (assuming a candidate pool size is configured)\n        this.peerConn = this.createPeerConnection();\n        this.gotCallFeedsForInvite(callFeeds, requestScreenshareFeed);\n    }\n\n    private createPeerConnection(): RTCPeerConnection {\n        const pc = new window.RTCPeerConnection({\n            iceTransportPolicy: this.forceTURN ? \"relay\" : undefined,\n            iceServers: this.turnServers,\n            iceCandidatePoolSize: this.client.iceCandidatePoolSize,\n            bundlePolicy: \"max-bundle\",\n        });\n\n        // 'connectionstatechange' would be better, but firefox doesn't implement that.\n        pc.addEventListener(\"iceconnectionstatechange\", this.onIceConnectionStateChanged);\n        pc.addEventListener(\"signalingstatechange\", this.onSignallingStateChanged);\n        pc.addEventListener(\"icecandidate\", this.gotLocalIceCandidate);\n        pc.addEventListener(\"icegatheringstatechange\", this.onIceGatheringStateChange);\n        pc.addEventListener(\"track\", this.onTrack);\n        pc.addEventListener(\"negotiationneeded\", this.onNegotiationNeeded);\n        pc.addEventListener(\"datachannel\", this.onDataChannel);\n\n        return pc;\n    }\n\n    private partyIdMatches(msg: MCallBase): boolean {\n        // They must either match or both be absent (in which case opponentPartyId will be null)\n        // Also we ignore party IDs on the invite/offer if the version is 0, so we must do the same\n        // here and use null if the version is 0 (woe betide any opponent sending messages in the\n        // same call with different versions)\n        const msgPartyId = msg.version === 0 ? null : msg.party_id || null;\n        return msgPartyId === this.opponentPartyId;\n    }\n\n    // Commits to an opponent for the call\n    // ev: An invite or answer event\n    private chooseOpponent(ev: MatrixEvent): void {\n        // I choo-choo-choose you\n        const msg = ev.getContent<MCallInviteNegotiate | MCallAnswer>();\n\n        logger.debug(`Call ${this.callId} choosing opponent party ID ${msg.party_id}`);\n\n        this.opponentVersion = msg.version;\n        if (this.opponentVersion === 0) {\n            // set to null to indicate that we've chosen an opponent, but because\n            // they're v0 they have no party ID (even if they sent one, we're ignoring it)\n            this.opponentPartyId = null;\n        } else {\n            // set to their party ID, or if they're naughty and didn't send one despite\n            // not being v0, set it to null to indicate we picked an opponent with no\n            // party ID\n            this.opponentPartyId = msg.party_id || null;\n        }\n        this.opponentCaps = msg.capabilities || ({} as CallCapabilities);\n        this.opponentMember = this.client.getRoom(this.roomId)!.getMember(ev.getSender()!) ?? undefined;\n    }\n\n    private async addBufferedIceCandidates(): Promise<void> {\n        const bufferedCandidates = this.remoteCandidateBuffer.get(this.opponentPartyId!);\n        if (bufferedCandidates) {\n            logger.info(\n                `Call ${this.callId} Adding ${bufferedCandidates.length} buffered candidates for opponent ${this.opponentPartyId}`,\n            );\n            await this.addIceCandidates(bufferedCandidates);\n        }\n        this.remoteCandidateBuffer.clear();\n    }\n\n    private async addIceCandidates(candidates: RTCIceCandidate[]): Promise<void> {\n        for (const candidate of candidates) {\n            if (\n                (candidate.sdpMid === null || candidate.sdpMid === undefined) &&\n                (candidate.sdpMLineIndex === null || candidate.sdpMLineIndex === undefined)\n            ) {\n                logger.debug(`Call ${this.callId} got remote ICE end-of-candidates`);\n            } else {\n                logger.debug(\n                    `Call ${this.callId} got remote ICE ${candidate.sdpMid} candidate: ${candidate.candidate}`,\n                );\n            }\n\n            try {\n                await this.peerConn!.addIceCandidate(candidate);\n            } catch (err) {\n                if (!this.ignoreOffer) {\n                    logger.info(`Call ${this.callId} failed to add remote ICE candidate`, err);\n                }\n            }\n        }\n    }\n\n    public get hasPeerConnection(): boolean {\n        return Boolean(this.peerConn);\n    }\n}\n\nexport function setTracksEnabled(tracks: Array<MediaStreamTrack>, enabled: boolean): void {\n    for (const track of tracks) {\n        track.enabled = enabled;\n    }\n}\n\nexport function supportsMatrixCall(): boolean {\n    // typeof prevents Node from erroring on an undefined reference\n    if (typeof window === \"undefined\" || typeof document === \"undefined\") {\n        // NB. We don't log here as apps try to create a call object as a test for\n        // whether calls are supported, so we shouldn't fill the logs up.\n        return false;\n    }\n\n    // Firefox throws on so little as accessing the RTCPeerConnection when operating in a secure mode.\n    // There's some information at https://bugzilla.mozilla.org/show_bug.cgi?id=1542616 though the concern\n    // is that the browser throwing a SecurityError will brick the client creation process.\n    try {\n        const supported = Boolean(\n            window.RTCPeerConnection ||\n                window.RTCSessionDescription ||\n                window.RTCIceCandidate ||\n                navigator.mediaDevices,\n        );\n        if (!supported) {\n            /* istanbul ignore if */ // Adds a lot of noise to test runs, so disable logging there.\n            if (process.env.NODE_ENV !== \"test\") {\n                logger.error(\"WebRTC is not supported in this browser / environment\");\n            }\n            return false;\n        }\n    } catch (e) {\n        logger.error(\"Exception thrown when trying to access WebRTC\", e);\n        return false;\n    }\n\n    return true;\n}\n\n/**\n * DEPRECATED\n * Use client.createCall()\n *\n * Create a new Matrix call for the browser.\n * @param client - The client instance to use.\n * @param roomId - The room the call is in.\n * @param options - DEPRECATED optional options map.\n * @returns the call or null if the browser doesn't support calling.\n */\nexport function createNewMatrixCall(\n    client: MatrixClient,\n    roomId: string,\n    options?: Pick<CallOpts, \"forceTURN\" | \"invitee\" | \"opponentDeviceId\" | \"opponentSessionId\" | \"groupCallId\">,\n): MatrixCall | null {\n    if (!supportsMatrixCall()) return null;\n\n    const optionsForceTURN = options ? options.forceTURN : false;\n\n    const opts: CallOpts = {\n        client: client,\n        roomId: roomId,\n        invitee: options?.invitee,\n        turnServers: client.getTurnServers(),\n        // call level options\n        forceTURN: client.forceTURN || optionsForceTURN,\n        opponentDeviceId: options?.opponentDeviceId,\n        opponentSessionId: options?.opponentSessionId,\n        groupCallId: options?.groupCallId,\n    };\n    const call = new MatrixCall(opts);\n\n    client.reEmitter.reEmit(call, Object.values(CallEvent));\n\n    return call;\n}\n"],"mappings":";;;;;;;;;;;;AAuBA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAeA;AAEA;AACA;AACA;AAEA;AAA0C;AAAA;AAAA;AAAA;AAAA,IAiCrCA,SAAS;AAAA,WAATA,SAAS;EAATA,SAAS;EAATA,SAAS;AAAA,GAATA,SAAS,KAATA,SAAS;AAAA,IAKTC,SAAS,EAEV;AAGJ;AAAA,WALKA,SAAS;EAATA,SAAS;AAAA,GAATA,SAAS,KAATA,SAAS;AAAA,IAaFC,SAAS;AAAA;AAAA,WAATA,SAAS;EAATA,SAAS;EAATA,SAAS;EAATA,SAAS;EAATA,SAAS;EAATA,SAAS;EAATA,SAAS;EAATA,SAAS;EAATA,SAAS;EAATA,SAAS;AAAA,GAATA,SAAS,yBAATA,SAAS;AAAA,IAYTC,QAAQ;AAAA;AAAA,WAARA,QAAQ;EAARA,QAAQ;EAARA,QAAQ;AAAA,GAARA,QAAQ,wBAARA,QAAQ;AAAA,IAKRC,aAAa;AAAA;AAAA,WAAbA,aAAa;EAAbA,aAAa;EAAbA,aAAa;AAAA,GAAbA,aAAa,6BAAbA,aAAa;AAAA,IAKbC,SAAS;AAAA;AAAA,WAATA,SAAS;EAATA,SAAS;EAATA,SAAS;AAAA,GAATA,SAAS,yBAATA,SAAS;AAAA,IAKTC,SAAS;AAAA;AAAA,WAATA,SAAS;EAATA,SAAS;EAATA,SAAS;EAATA,SAAS;EAATA,SAAS;EAATA,SAAS;EAATA,SAAS;EAATA,SAAS;EAATA,SAAS;EAATA,SAAS;EAATA,SAAS;EAATA,SAAS;EAATA,SAAS;AAAA,GAATA,SAAS,yBAATA,SAAS;AAAA,IAwBTC,aAAa;AA2FzB;AACA;AACA;AAFA;AAAA,WA3FYA,aAAa;EAAbA,aAAa;EAAbA,aAAa;EAAbA,aAAa;EAAbA,aAAa;EAAbA,aAAa;EAAbA,aAAa;EAAbA,aAAa;EAAbA,aAAa;EAAbA,aAAa;EAAbA,aAAa;EAAbA,aAAa;EAAbA,aAAa;EAAbA,aAAa;EAAbA,aAAa;EAAbA,aAAa;EAAbA,aAAa;EAAbA,aAAa;EAAbA,aAAa;AAAA,GAAbA,aAAa,6BAAbA,aAAa;AA8FzB,MAAMC,kBAAkB,GAAG,GAAG;;AAE9B;AACA,MAAMC,mBAAmB,GAAG,sBAAsB;;AAElD;AACA,MAAMC,eAAe,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC;AACnC;AACA,MAAMC,oBAAoB,GAAG,IAAI,CAAC,CAAC;AACnC;AACA,MAAMC,wBAAwB,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC;;AAErC,MAAMC,SAAS,SAASC,KAAK,CAAC;EAG1BC,WAAW,CAACC,IAAmB,EAAEC,GAAW,EAAEC,GAAU,EAAE;IAC7D;IACA,KAAK,CAACD,GAAG,GAAG,IAAI,GAAGC,GAAG,CAAC;IAAC;IAExB,IAAI,CAACF,IAAI,GAAGA,IAAI;EACpB;AACJ;AAAC;AAEM,SAASG,SAAS,GAAW;EAChC,OAAOC,IAAI,CAACC,GAAG,EAAE,CAACC,QAAQ,EAAE,GAAG,IAAAC,0BAAY,EAAC,EAAE,CAAC;AACnD;AAEA,SAASC,iBAAiB,CAACC,KAAc,EAAoB;EACzD,MAAMC,IAAI,GAAG,CACT;IACIC,SAAS,EAAE,OAAO;IAClBC,KAAK,EAAE,MAAM;IACbC,SAAS,EAAE,IAAI;IACfC,iBAAiB,EAAEL,KAAK,GAAG,KAAK,GAAGM;EACvC,CAAC,CACgB;EAErB,OAAOL,IAAI;AACf;AAqBA;AACA;AACA;AACA,SAASM,iBAAiB,CAACC,OAAiC,EAAEC,IAAoB,EAAU;EACxF,OAAOD,OAAO,GAAG,GAAG,GAAGC,IAAI;AAC/B;AAEO,MAAMC,UAAU,SAASC,oCAAiB,CAAiC;EAW9E;EACA;;EAOA;EACA;EACA;;EAMA;;EAQA;EACA;;EAOA;EACA;;EAGA;EACA;EACA;;EAGA;;EAMA;EACA;EACA;;EAcA;AACJ;AACA;AACA;EACWrB,WAAW,CAACsB,IAAc,EAAE;IAAA;IAC/B,KAAK,EAAE;IAAC;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA,mDAtES,CAAC;IAAA,6CAIP,KAAK;IAAA,8CAEHnC,SAAS,CAACoC,SAAS;IAAA;IAAA;IAAA;IAAA,0DAOiB,EAAE;IAAA,0DAC1B,CAAC;IAAA,uDACJ,KAAK;IAAA,6CACE,EAAE;IAAA,oDAGZ,IAAIC,GAAG,EAAqC;IAAA,0DAEtC,KAAK;IAAA,4DACH,KAAK;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA,4DAUI,IAAIA,GAAG,EAA2B;IAAA,oDAInD,KAAK;IAAA;IAAA,mDAQN,KAAK;IAAA,mDACL,KAAK;IAAA;IAAA,6DAOK,IAAIA,GAAG,EAA6B;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA,4DAixCpCC,KAAgC,IAAW;MACvE,IAAIA,KAAK,CAACC,SAAS,EAAE;QACjB,IAAI,IAAI,CAACC,eAAe,EAAE;UACtBC,cAAM,CAACC,IAAI,CAAC,uDAAuD,CAAC;UACpE;QACJ;QAEAD,cAAM,CAACE,KAAK,CACR,OAAO,GACH,IAAI,CAACC,MAAM,GACX,iBAAiB,GACjBN,KAAK,CAACC,SAAS,CAACM,MAAM,GACtB,cAAc,GACdP,KAAK,CAACC,SAAS,CAACA,SAAS,CAChC;QAED,IAAI,IAAI,CAACO,YAAY,EAAE,EAAE;;QAEzB;QACA;QACA,IAAIR,KAAK,CAACC,SAAS,CAACA,SAAS,KAAK,EAAE,EAAE;UAClC,IAAI,CAACQ,cAAc,CAAC,IAAI,CAAC;QAC7B,CAAC,MAAM;UACH,IAAI,CAACA,cAAc,CAACT,KAAK,CAACC,SAAS,CAAC;QACxC;MACJ;IACJ,CAAC;IAAA,iEAEoCD,KAAY,IAAW;MAAA;MACxDG,cAAM,CAACE,KAAK,CAAE,QAAO,IAAI,CAACC,MAAO,oCAAmC,IAAI,CAACI,QAAQ,CAAEC,iBAAkB,EAAC,CAAC;MACvG,IAAI,uBAAI,CAACD,QAAQ,mDAAb,eAAeC,iBAAiB,MAAK,UAAU,EAAE;QACjD,IAAI,CAACF,cAAc,CAAC,IAAI,CAAC;MAC7B;IACJ,CAAC;IAAA,2DAyV8B/B,GAAU,IAAW;MAChDyB,cAAM,CAACS,KAAK,CAAE,QAAO,IAAI,CAACN,MAAO,4BAA2B,EAAE5B,GAAG,CAAC;MAElE,IAAI,CAACmC,IAAI,CAAC/C,SAAS,CAACQ,KAAK,EAAE,IAAID,SAAS,CAACN,aAAa,CAAC+C,gBAAgB,EAAE,4BAA4B,EAAEpC,GAAG,CAAC,CAAC;MAC5G,IAAI,CAACqC,SAAS,CAAClD,SAAS,CAACmD,KAAK,EAAEjD,aAAa,CAAC+C,gBAAgB,EAAE,KAAK,CAAC;IAC1E,CAAC;IAAA,0DAE6BpC,GAAU,IAAW;MAC/C,IAAI,IAAI,CAACuC,SAAS,EAAE;QAChB,IAAI,CAACA,SAAS,CAACC,kBAAkB,CAACxC,GAAG,CAAC;QACtC;MACJ;MAEAyB,cAAM,CAACC,IAAI,CAAE,0CAAyC,IAAI,CAACE,MAAO,EAAC,EAAE5B,GAAG,CAAC;MAEzE,IAAI,CAACmC,IAAI,CACL/C,SAAS,CAACQ,KAAK,EACf,IAAID,SAAS,CACTN,aAAa,CAACoD,WAAW,EACzB,gEAAgE,GAAG,gCAAgC,EACnGzC,GAAG,CACN,CACJ;MACD,IAAI,CAACqC,SAAS,CAAClD,SAAS,CAACmD,KAAK,EAAEjD,aAAa,CAACoD,WAAW,EAAE,KAAK,CAAC;IACrE,CAAC;IAAA,mEAEqC,MAAY;MAAA;MAC9C,IAAI,IAAI,CAACX,YAAY,EAAE,EAAE;QACrB,OAAO,CAAC;MACZ;;MACAL,cAAM,CAACE,KAAK,CACR,UAAU,GAAG,IAAI,CAACC,MAAM,GAAG,qCAAqC,uBAAG,IAAI,CAACI,QAAQ,oDAAb,gBAAeU,kBAAkB,EACvG;;MAED;MACA;MACA,IAAI,CAAC,WAAW,EAAE,WAAW,CAAC,CAACC,QAAQ,6CAAC,IAAI,CAACX,QAAQ,oDAAb,gBAAeU,kBAAkB,yEAAI,EAAE,CAAC,EAAE;QAC9EE,YAAY,CAAC,IAAI,CAACC,sBAAsB,CAAC;QACzC,IAAI,CAACC,KAAK,GAAG9D,SAAS,CAAC+D,SAAS;QAEhC,IAAI,CAAC,IAAI,CAACC,kBAAkB,IAAI,CAAC,IAAI,CAACC,aAAa,EAAE;UACjD,IAAI,CAACA,aAAa,GAAG/C,IAAI,CAACC,GAAG,EAAE;UAE/B,IAAI,CAAC6C,kBAAkB,GAAGE,WAAW,CAAC,MAAM;YACxC,IAAI,CAACf,IAAI,CAAC/C,SAAS,CAAC+D,aAAa,EAAEC,IAAI,CAACC,KAAK,CAAC,CAACnD,IAAI,CAACC,GAAG,EAAE,GAAG,IAAI,CAAC8C,aAAc,IAAI,IAAI,CAAC,CAAC;UAC7F,CAAC,EAAExD,oBAAoB,CAAC;QAC5B;MACJ,CAAC,MAAM,IAAI,wBAAI,CAACuC,QAAQ,oDAAb,gBAAeU,kBAAkB,KAAI,QAAQ,EAAE;QAAA;QACtD;QACA;QACA;QACA,uBAAI,IAAI,CAACV,QAAQ,4CAAb,gBAAesB,UAAU,EAAyB;UAClD,IAAI,CAAC9B,eAAe,GAAG,KAAK;UAC5B,IAAI,CAACQ,QAAQ,CAAEsB,UAAU,EAAE;QAC/B,CAAC,MAAM;UACH7B,cAAM,CAAC8B,IAAI,CAAE,mBAAkB,IAAI,CAAC3B,MAAO,yCAAwC,CAAC;UACpF,IAAI,CAAC4B,MAAM,CAACnE,aAAa,CAACoE,SAAS,EAAE,KAAK,CAAC;QAC/C;MACJ,CAAC,MAAM,IAAI,wBAAI,CAACzB,QAAQ,oDAAb,gBAAeU,kBAAkB,KAAI,cAAc,EAAE;QAC5D,IAAI,CAACG,sBAAsB,GAAGa,UAAU,CAAC,MAAM;UAC3CjC,cAAM,CAAC8B,IAAI,CAAE,mBAAkB,IAAI,CAAC3B,MAAO,kCAAiC,CAAC;UAC7E,IAAI,CAAC4B,MAAM,CAACnE,aAAa,CAACoE,SAAS,EAAE,KAAK,CAAC;QAC/C,CAAC,EAAE/D,wBAAwB,CAAC;QAC5B,IAAI,CAACoD,KAAK,GAAG9D,SAAS,CAAC2E,UAAU;MACrC;;MAEA;MACA;MACA;MACA;MACA,IAAI,IAAI,CAACpD,KAAK,IAAI,CAAC,QAAQ,EAAE,cAAc,CAAC,CAACoC,QAAQ,CAAC,IAAI,CAACX,QAAQ,CAAEU,kBAAkB,CAAC,EAAE;QACtF,KAAK,MAAMkB,IAAI,IAAI,IAAI,CAACC,cAAc,EAAE,EAAE;UACtCD,IAAI,CAACE,kBAAkB,CAAC,IAAI,EAAE,IAAI,CAAC;QACvC;MACJ;IACJ,CAAC;IAAA,gEAEkC,MAAY;MAAA;MAC3CrC,cAAM,CAACE,KAAK,CAAE,QAAO,IAAI,CAACC,MAAO,kCAA+B,mBAAE,IAAI,CAACI,QAAQ,oDAAb,gBAAe+B,cAAe,EAAC,CAAC;IACtG,CAAC;IAAA,+CAEkBC,EAAiB,IAAW;MAC3C,IAAIA,EAAE,CAACC,OAAO,CAACC,MAAM,KAAK,CAAC,EAAE;QACzBzC,cAAM,CAACC,IAAI,CAAE,QAAO,IAAI,CAACE,MAAO,eAAcoC,EAAE,CAACG,KAAK,CAACnD,IAAK,mBAAkB,CAAC;QAC/E;MACJ;MAEA,MAAMoD,MAAM,GAAGJ,EAAE,CAACC,OAAO,CAAC,CAAC,CAAC;MAC5B,IAAI,CAACI,cAAc,CAACD,MAAM,CAAC;MAE3B,IAAI,CAAC,IAAI,CAACE,oBAAoB,CAACC,GAAG,CAACH,MAAM,CAAC,EAAE;QACxC,MAAMI,aAAa,GAAG,MAAY;UAC9B,IAAIJ,MAAM,CAACK,SAAS,EAAE,CAACP,MAAM,KAAK,CAAC,EAAE;YACjCzC,cAAM,CAAC8B,IAAI,CAAE,QAAO,IAAI,CAAC3B,MAAO,6BAA4BwC,MAAM,CAACM,EAAG,EAAC,CAAC;YACxE,IAAI,CAACC,kBAAkB,CAACP,MAAM,CAAC;YAC/BA,MAAM,CAACQ,mBAAmB,CAAC,aAAa,EAAEJ,aAAa,CAAC;YACxD,IAAI,CAACF,oBAAoB,CAACO,MAAM,CAACT,MAAM,CAAC;UAC5C;QACJ,CAAC;QACDA,MAAM,CAACU,gBAAgB,CAAC,aAAa,EAAEN,aAAa,CAAC;QACrD,IAAI,CAACF,oBAAoB,CAACS,GAAG,CAACX,MAAM,EAAEI,aAAa,CAAC;MACxD;IACJ,CAAC;IAAA,qDAEwBR,EAAuB,IAAW;MACvD,IAAI,CAAC7B,IAAI,CAAC/C,SAAS,CAAC4F,WAAW,EAAEhB,EAAE,CAACiB,OAAO,CAAC;IAChD,CAAC;IAAA,2DAoC6B,YAA2B;MACrDxD,cAAM,CAAC8B,IAAI,CAAE,QAAO,IAAI,CAAC3B,MAAO,yBAAwB,CAAC;MAEzD,IAAI,IAAI,CAACkB,KAAK,KAAK9D,SAAS,CAACkG,WAAW,IAAI,IAAI,CAACC,eAAe,KAAK,CAAC,EAAE;QACpE1D,cAAM,CAAC8B,IAAI,CACN,QAAO,IAAI,CAAC3B,MAAO,4EAA2E,CAClG;QACD;MACJ;MAEA,IAAI,CAACwD,kBAAkB,EAAE;IAC7B,CAAC;IAAA,wDAE0BrF,GAAsB,IAAW;MACxD0B,cAAM,CAACE,KAAK,CAAC,8BAA8B,GAAG,IAAI,CAACC,MAAM,CAAC;;MAE1D;MACA;MACA,IAAI,IAAI,CAACyD,cAAc,CAACtF,GAAG,CAAC,IAAI,IAAI,CAAC+C,KAAK,KAAK9D,SAAS,CAACsG,OAAO,EAAE;QAC9D;QACA,IAAI,CAACjD,SAAS,CAAClD,SAAS,CAACoG,MAAM,EAAExF,GAAG,CAACyF,MAAM,IAAInG,aAAa,CAACoG,UAAU,EAAE,IAAI,CAAC;MAClF,CAAC,MAAM;QACHhE,cAAM,CAAC8B,IAAI,CACN,QAAO,IAAI,CAAC3B,MAAO,mCAAkC7B,GAAG,CAAC2F,QAAS,oBAAmB,IAAI,CAACC,eAAgB,EAAC,CAC/G;MACL;IACJ,CAAC;IAAA,wDAE0B5F,GAAsB,IAAW;MACxD0B,cAAM,CAACE,KAAK,CAAC,8BAA8B,GAAG,IAAI,CAACC,MAAM,CAAC;;MAE1D;MACA;;MAEA,MAAMgE,eAAe;MACjB;MACA;MACA,CAAC5G,SAAS,CAAC6G,UAAU,EAAE7G,SAAS,CAACsG,OAAO,CAAC,CAAC3C,QAAQ,CAAC,IAAI,CAACG,KAAK,CAAC;MAC9D;MACA;MACC,IAAI,CAACA,KAAK,KAAK9D,SAAS,CAACoC,SAAS,IAAI,IAAI,CAAC0E,SAAS,KAAK5G,aAAa,CAAC6G,OAAQ;MAEpF,IAAIH,eAAe,EAAE;QACjB,IAAI,CAACvD,SAAS,CAAClD,SAAS,CAACoG,MAAM,EAAExF,GAAG,CAACyF,MAAM,IAAInG,aAAa,CAACoG,UAAU,EAAE,IAAI,CAAC;MAClF,CAAC,MAAM;QACHhE,cAAM,CAACE,KAAK,CAAE,QAAO,IAAI,CAACC,MAAO,iBAAgB,IAAI,CAACkB,KAAM,mBAAkB,CAAC;MACnF;IACJ,CAAC;IAAA,2DAE6B/C,GAAgB,IAAW;MACrD0B,cAAM,CAACE,KAAK,CAAC,OAAO,GAAG,IAAI,CAACC,MAAM,GAAG,qBAAqB,CAAC;MAC3D,IAAI,CAACS,SAAS,CAAClD,SAAS,CAACoG,MAAM,EAAElG,aAAa,CAAC2G,iBAAiB,EAAE,IAAI,CAAC;IAC3E,CAAC;IAzzDG,IAAI,CAACC,MAAM,GAAG9E,IAAI,CAAC8E,MAAM;IACzB,IAAI,CAACC,OAAO,GAAG/E,IAAI,CAAC+E,OAAO;IAC3B,IAAI,CAACC,MAAM,GAAGhF,IAAI,CAACgF,MAAM;IAEzB,IAAI,CAAC,IAAI,CAACA,MAAM,CAACC,QAAQ,EAAE,MAAM,IAAIxG,KAAK,CAAC,6CAA6C,CAAC;IAEzF,IAAI,CAACyG,SAAS,sBAAGlF,IAAI,CAACkF,SAAS,6DAAI,KAAK;IACxC,IAAI,CAACC,UAAU,GAAG,IAAI,CAACH,MAAM,CAACC,QAAQ;IACtC,IAAI,CAACG,gBAAgB,GAAGpF,IAAI,CAACoF,gBAAgB;IAC7C,IAAI,CAACC,iBAAiB,GAAGrF,IAAI,CAACqF,iBAAiB;IAC/C,IAAI,CAACC,WAAW,GAAGtF,IAAI,CAACsF,WAAW;IACnC;IACA,IAAI,CAACC,WAAW,GAAGvF,IAAI,CAACuF,WAAW,IAAI,EAAE;IACzC,IAAI,IAAI,CAACA,WAAW,CAACxC,MAAM,KAAK,CAAC,IAAI,IAAI,CAACiC,MAAM,CAACQ,0BAA0B,EAAE,EAAE;MAC3E,IAAI,CAACD,WAAW,CAACE,IAAI,CAAC;QAClBC,IAAI,EAAE,CAACtH,mBAAmB;MAC9B,CAAC,CAAC;IACN;IACA,KAAK,MAAMuH,MAAM,IAAI,IAAI,CAACJ,WAAW,EAAE;MACnCK,KAAK,CAACC,kBAAkB,CAACF,MAAM,EAAE,CAAC,MAAM,CAAC,CAAC;IAC9C;IACA,IAAI,CAAClF,MAAM,GAAG3B,SAAS,EAAE;EAC7B;;EAEA;AACJ;AACA;AACA;EACI,MAAagH,cAAc,GAAkB;IACzC,MAAM,IAAI,CAACC,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC;EACrC;;EAEA;AACJ;AACA;AACA;EACI,MAAaC,cAAc,GAAkB;IACzC,MAAM,IAAI,CAACD,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC;EACpC;;EAEA;AACJ;AACA;AACA;AACA;EACWE,iBAAiB,CAACC,KAAa,EAAEC,OAAuC,EAAkB;IAC7F,MAAMC,WAAW,GAAG,IAAI,CAACvF,QAAQ,CAAEoF,iBAAiB,CAACC,KAAK,EAAEC,OAAO,CAAC;IACpE,IAAI,CAACnF,IAAI,CAAC/C,SAAS,CAAC4F,WAAW,EAAEuC,WAAW,CAAC;IAC7C,OAAOA,WAAW;EACtB;EAEOC,iBAAiB,GAA2B;IAC/C,OAAO,IAAI,CAACC,cAAc;EAC9B;EAEOC,mBAAmB,GAAuB;IAC7C,OAAO,IAAI,CAACnB,gBAAgB;EAChC;EAEOoB,oBAAoB,GAAuB;IAC9C,OAAO,IAAI,CAACnB,iBAAiB;EACjC;EAEOoB,wBAAwB,GAAY;IACvC,OAAOC,OAAO,CAAC,IAAI,CAACC,YAAY,IAAI,IAAI,CAACA,YAAY,CAAC,mBAAmB,CAAC,CAAC;EAC/E;EAEOC,oBAAoB,GAAY;IACnC,OAAOF,OAAO,CAAC,IAAI,CAACC,YAAY,IAAI,IAAI,CAACA,YAAY,CAAC,aAAa,CAAC,CAAC;EACzE;EAEOE,yBAAyB,GAAiC;IAC7D,OAAO,IAAI,CAACC,sBAAsB;EACtC;EAEA,IAAWnF,KAAK,GAAc;IAC1B,OAAO,IAAI,CAACoF,MAAM;EACtB;EAEA,IAAYpF,KAAK,CAACA,KAAgB,EAAE;IAChC,MAAMqF,QAAQ,GAAG,IAAI,CAACD,MAAM;IAC5B,IAAI,CAACA,MAAM,GAAGpF,KAAK;IACnB,IAAI,CAACX,IAAI,CAAC/C,SAAS,CAACgJ,KAAK,EAAEtF,KAAK,EAAEqF,QAAQ,CAAC;EAC/C;EAEA,IAAWE,IAAI,GAAa;IACxB,OAAO,IAAI,CAACC,2BAA2B,IAAI,IAAI,CAACC,4BAA4B,GAAGtJ,QAAQ,CAACuJ,KAAK,GAAGvJ,QAAQ,CAACwJ,KAAK;EAClH;EAEA,IAAWH,2BAA2B,GAAY;IAAA;IAC9C,OAAO,CAAC,2BAAC,IAAI,CAACI,oBAAoB,kDAAzB,sBAA2BC,cAAc,EAAE,CAACzE,MAAM;EAC/D;EAEA,IAAWqE,4BAA4B,GAAY;IAC/C,OAAO,IAAI,CAAC1E,cAAc,EAAE,CAAC+E,IAAI,CAAEhF,IAAI,IAAK;MAAA;MACxC,OAAOA,IAAI,CAAC7C,OAAO,KAAK8H,wCAAwB,CAACC,SAAS,qBAAIlF,IAAI,CAACQ,MAAM,iDAAX,aAAauE,cAAc,EAAE,CAACzE,MAAM;IACtG,CAAC,CAAC;EACN;EAEA,IAAW6E,2BAA2B,GAAY;IAAA;IAC9C,OAAO,CAAC,4BAAC,IAAI,CAACL,oBAAoB,mDAAzB,uBAA2BM,cAAc,EAAE,CAAC9E,MAAM;EAC/D;EAEA,IAAW+E,4BAA4B,GAAY;IAC/C,OAAO,IAAI,CAACpF,cAAc,EAAE,CAAC+E,IAAI,CAAEhF,IAAI,IAAK;MAAA;MACxC,OAAOA,IAAI,CAAC7C,OAAO,KAAK8H,wCAAwB,CAACC,SAAS,IAAI,CAAC,mBAAClF,IAAI,CAACQ,MAAM,0CAAX,cAAa4E,cAAc,EAAE,CAAC9E,MAAM;IACxG,CAAC,CAAC;EACN;EAEA,IAAWgF,kBAAkB,GAAyB;IAClD,OAAO,IAAI,CAACC,aAAa,EAAE,CAACC,IAAI,CAAExF,IAAI,IAAKA,IAAI,CAAC7C,OAAO,KAAK8H,wCAAwB,CAACC,SAAS,CAAC;EACnG;EAEA,IAAWO,sBAAsB,GAAyB;IACtD,OAAO,IAAI,CAACF,aAAa,EAAE,CAACC,IAAI,CAAExF,IAAI,IAAKA,IAAI,CAAC7C,OAAO,KAAK8H,wCAAwB,CAACS,WAAW,CAAC;EACrG;EAEA,IAAWZ,oBAAoB,GAA4B;IAAA;IACvD,gCAAO,IAAI,CAACQ,kBAAkB,0DAAvB,sBAAyB9E,MAAM;EAC1C;EAEA,IAAWmF,wBAAwB,GAA4B;IAAA;IAC3D,gCAAO,IAAI,CAACF,sBAAsB,0DAA3B,sBAA6BjF,MAAM;EAC9C;EAEA,IAAWoF,mBAAmB,GAAyB;IACnD,OAAO,IAAI,CAAC3F,cAAc,EAAE,CAACuF,IAAI,CAAExF,IAAI,IAAKA,IAAI,CAAC7C,OAAO,KAAK8H,wCAAwB,CAACC,SAAS,CAAC;EACpG;EAEA,IAAWW,uBAAuB,GAAyB;IACvD,OAAO,IAAI,CAAC5F,cAAc,EAAE,CAACuF,IAAI,CAAExF,IAAI,IAAKA,IAAI,CAAC7C,OAAO,KAAK8H,wCAAwB,CAACS,WAAW,CAAC;EACtG;EAEA,IAAWI,qBAAqB,GAA4B;IAAA;IACxD,gCAAO,IAAI,CAACF,mBAAmB,0DAAxB,sBAA0BpF,MAAM;EAC3C;EAEA,IAAWuF,yBAAyB,GAA4B;IAAA;IAC5D,gCAAO,IAAI,CAACF,uBAAuB,0DAA5B,sBAA8BrF,MAAM;EAC/C;EAEQwF,iBAAiB,CAACC,QAAgB,EAAwB;IAC9D,OAAO,IAAI,CAACC,QAAQ,EAAE,CAACV,IAAI,CAAExF,IAAI,IAAKA,IAAI,CAACQ,MAAM,CAACM,EAAE,KAAKmF,QAAQ,CAAC;EACtE;;EAEA;AACJ;AACA;AACA;EACWC,QAAQ,GAAoB;IAC/B,OAAO,IAAI,CAACC,KAAK;EACrB;;EAEA;AACJ;AACA;AACA;EACWZ,aAAa,GAAoB;IACpC,OAAO,IAAI,CAACY,KAAK,CAACC,MAAM,CAAEpG,IAAI,IAAKA,IAAI,CAACqG,OAAO,EAAE,CAAC;EACtD;;EAEA;AACJ;AACA;AACA;EACWpG,cAAc,GAAoB;IACrC,OAAO,IAAI,CAACkG,KAAK,CAACC,MAAM,CAAEpG,IAAI,IAAK,CAACA,IAAI,CAACqG,OAAO,EAAE,CAAC;EACvD;EAEA,MAAcC,kBAAkB,GAAkB;IAAA;IAC9C,IAAI,CAAC,IAAI,CAAC3D,gBAAgB,EAAE;IAC5B,IAAI,CAAC,IAAI,CAACJ,MAAM,CAACgE,qBAAqB,EAAE,EAAE;IAC1C;IACA;IACA,IAAI,CAAC,IAAI,CAAChE,MAAM,CAACiE,eAAe,EAAE,EAAE;MAChC;MACA,IAAI,CAACC,kBAAkB,GAAG,IAAIC,sBAAU,CAAC,IAAI,CAAC/D,gBAAgB,CAAC;MAC/D;IACJ;IACA;IACA,IAAI,CAAC,IAAI,CAACJ,MAAM,CAACoE,MAAM,EAAE,MAAM,IAAI3K,KAAK,CAAC,4BAA4B,CAAC;IAEtE,MAAM4K,MAAM,GAAG,IAAI,CAACtE,OAAO,8BAAI,IAAI,CAACsB,iBAAiB,EAAE,0DAAxB,sBAA0BgD,MAAM;IAE/D,IAAI,CAACA,MAAM,EAAE,MAAM,IAAI5K,KAAK,CAAC,+CAA+C,CAAC;IAE7E,MAAM6K,aAAa,GAAG,MAAM,IAAI,CAACtE,MAAM,CAACoE,MAAM,CAACG,UAAU,CAACC,YAAY,CAAC,CAACH,MAAM,CAAC,EAAE,KAAK,CAAC;IACvF,IAAI,CAACH,kBAAkB,GAAGI,aAAa,CAACD,MAAM,CAAC,CAAC,IAAI,CAACjE,gBAAgB,CAAC;IACtE,IAAI,IAAI,CAAC8D,kBAAkB,KAAKxJ,SAAS,EAAE;MACvC,MAAM,IAAI+J,sCAA2B,CAACJ,MAAM,CAAC;IACjD;EACJ;;EAEA;AACJ;AACA;AACA;EACYK,yBAAyB,CAACC,eAAe,GAAG,KAAK,EAAqB;IAC1E,MAAMC,QAA2B,GAAG,CAAC,CAAC;IACtC,KAAK,MAAMC,SAAS,IAAI,IAAI,CAAC7B,aAAa,EAAE,EAAE;MAC1C,IAAI2B,eAAe,EAAE;QACjBE,SAAS,CAACC,mBAAmB,GAAGD,SAAS,CAAC5G,MAAM,CAACM,EAAE;MACvD;MAEAqG,QAAQ,CAACC,SAAS,CAACC,mBAAmB,CAAC,GAAG;QACtClK,OAAO,EAAEiK,SAAS,CAACjK,OAAO;QAC1BmK,WAAW,EAAEF,SAAS,CAACG,YAAY,EAAE;QACrCC,WAAW,EAAEJ,SAAS,CAACK,YAAY;MACvC,CAAC;IACL;IACA,OAAON,QAAQ;EACnB;;EAEA;AACJ;AACA;AACA;AACA;EACWO,eAAe,GAAY;IAC9B,OAAO,CAAC,IAAI,CAACvB,KAAK,CAACnB,IAAI,CAAEhF,IAAI,IAAK,CAACA,IAAI,CAACqG,OAAO,EAAE,CAAC;EACtD;EAEQ5F,cAAc,CAACD,MAAmB,EAAQ;IAC9C;IACA,IAAI,CAAC,IAAI,CAACmH,iCAAiC,EAAE,EAAE;MAC3C,IAAI,CAACC,6BAA6B,CAACpH,MAAM,CAAC;MAC1C;IACJ;IAEA,MAAMoG,MAAM,GAAG,IAAI,CAAChD,iBAAiB,EAAE,CAAEgD,MAAM;IAC/C,MAAMzJ,OAAO,GAAG,IAAI,CAAC0K,uBAAuB,CAAErH,MAAM,CAACM,EAAE,CAAC,CAAC3D,OAAO;IAChE,MAAM2K,UAAU,GAAG,IAAI,CAACD,uBAAuB,CAAErH,MAAM,CAACM,EAAE,CAAC,CAACwG,WAAW;IACvE,MAAMS,UAAU,GAAG,IAAI,CAACF,uBAAuB,CAAErH,MAAM,CAACM,EAAE,CAAC,CAAC0G,WAAW;IAEvE,IAAI,CAACrK,OAAO,EAAE;MACVU,cAAM,CAACC,IAAI,CACN,QAAO,IAAI,CAACE,MAAO,4BAA2BwC,MAAM,CAACM,EAAG,8CAA6C,CACzG;MACD;IACJ;IAEA,IAAI,IAAI,CAACkF,iBAAiB,CAACxF,MAAM,CAACM,EAAE,CAAC,EAAE;MACnCjD,cAAM,CAACC,IAAI,CAAE,2BAA0B0C,MAAM,CAACM,EAAG,wCAAuC,CAAC;MACzF;IACJ;IAEA,IAAI,CAACqF,KAAK,CAACnD,IAAI,CACX,IAAIgF,kBAAQ,CAAC;MACTzF,MAAM,EAAE,IAAI,CAACA,MAAM;MACnB0F,IAAI,EAAE,IAAI;MACV5F,MAAM,EAAE,IAAI,CAACA,MAAM;MACnBuE,MAAM;MACNpE,QAAQ,EAAE,IAAI,CAACsB,mBAAmB,EAAE;MACpCtD,MAAM;MACNrD,OAAO;MACP2K,UAAU;MACVC;IACJ,CAAC,CAAC,CACL;IAED,IAAI,CAACxJ,IAAI,CAAC/C,SAAS,CAAC0M,YAAY,EAAE,IAAI,CAAC/B,KAAK,CAAC;IAE7CtI,cAAM,CAAC8B,IAAI,CACN,QAAO,IAAI,CAAC3B,MAAO,8BAA6BwC,MAAM,CAACM,EAAG,KAAI,GAC1D,WAAUN,MAAM,CAAC2H,MAAO,cAAahL,OAAQ,GAAE,CACvD;EACL;;EAEA;AACJ;AACA;EACYyK,6BAA6B,CAACpH,MAAmB,EAAQ;IAAA;IAC7D,MAAMoG,MAAM,GAAG,IAAI,CAAChD,iBAAiB,EAAE,CAAEgD,MAAM;IAC/C;IACA,MAAMzJ,OAAO,GAAG8H,wCAAwB,CAACC,SAAS;IAClD,MAAMkD,eAAe,uBAAG,IAAI,CAACjC,KAAK,CAACX,IAAI,CAAExF,IAAI,IAAK,CAACA,IAAI,CAACqG,OAAO,EAAE,CAAC,qDAA1C,iBAA4C7F,MAAM;;IAE1E;IACA;IACA;IACA;IACA,IAAI4H,eAAe,IAAI5H,MAAM,CAACM,EAAE,KAAKsH,eAAe,CAACtH,EAAE,EAAE;MACrDjD,cAAM,CAACC,IAAI,CACN,QAAO,IAAI,CAACE,MAAO,2BAA0BwC,MAAM,CAACM,EAAG,+BAA8BsH,eAAe,CAACtH,EAAG,EAAC,CAC7G;MACD;IACJ;IAEA,IAAI,IAAI,CAACkF,iBAAiB,CAACxF,MAAM,CAACM,EAAE,CAAC,EAAE;MACnCjD,cAAM,CAACC,IAAI,CAAE,2BAA0B0C,MAAM,CAACM,EAAG,wCAAuC,CAAC;MACzF;IACJ;IAEA,IAAI,CAACqF,KAAK,CAACnD,IAAI,CACX,IAAIgF,kBAAQ,CAAC;MACTzF,MAAM,EAAE,IAAI,CAACA,MAAM;MACnB0F,IAAI,EAAE,IAAI;MACV5F,MAAM,EAAE,IAAI,CAACA,MAAM;MACnByF,UAAU,EAAE,KAAK;MACjBC,UAAU,EAAE,KAAK;MACjBnB,MAAM;MACNpE,QAAQ,EAAE,IAAI,CAACsB,mBAAmB,EAAE;MACpCtD,MAAM;MACNrD;IACJ,CAAC,CAAC,CACL;IAED,IAAI,CAACoB,IAAI,CAAC/C,SAAS,CAAC0M,YAAY,EAAE,IAAI,CAAC/B,KAAK,CAAC;IAE7CtI,cAAM,CAAC8B,IAAI,CAAE,QAAO,IAAI,CAAC3B,MAAO,8BAA6BwC,MAAM,CAACM,EAAG,cAAaN,MAAM,CAAC2H,MAAO,IAAG,CAAC;EAC1G;EAEQE,gBAAgB,CAAC7H,MAAmB,EAAErD,OAAiC,EAAEmL,mBAAmB,GAAG,IAAI,EAAQ;IAC/G,MAAM1B,MAAM,GAAG,IAAI,CAACrE,MAAM,CAACgG,SAAS,EAAG;;IAEvC;IACA;IACA;IACAC,gBAAgB,CAAChI,MAAM,CAAC4E,cAAc,EAAE,EAAE,IAAI,CAAC;IAC/CoD,gBAAgB,CAAChI,MAAM,CAACuE,cAAc,EAAE,EAAE,IAAI,CAAC;IAE/C,IAAI,IAAI,CAACiB,iBAAiB,CAACxF,MAAM,CAACM,EAAE,CAAC,EAAE;MACnCjD,cAAM,CAACC,IAAI,CAAE,2BAA0B0C,MAAM,CAACM,EAAG,wCAAuC,CAAC;MACzF;IACJ;IAEA,IAAI,CAAC2H,aAAa,CACd,IAAIT,kBAAQ,CAAC;MACTzF,MAAM,EAAE,IAAI,CAACA,MAAM;MACnBF,MAAM,EAAE,IAAI,CAACA,MAAM;MACnByF,UAAU,EAAE,KAAK;MACjBC,UAAU,EAAE,KAAK;MACjBnB,MAAM;MACNpE,QAAQ,EAAE,IAAI,CAACsB,mBAAmB,EAAE;MACpCtD,MAAM;MACNrD;IACJ,CAAC,CAAC,EACFmL,mBAAmB,CACtB;EACL;;EAEA;AACJ;AACA;AACA;AACA;EACWG,aAAa,CAACC,QAAkB,EAAEJ,mBAAmB,GAAG,IAAI,EAAQ;IACvE,IAAI,IAAI,CAACnC,KAAK,CAACnB,IAAI,CAAEhF,IAAI,IAAK0I,QAAQ,CAAClI,MAAM,CAACM,EAAE,KAAKd,IAAI,CAACQ,MAAM,CAACM,EAAE,CAAC,EAAE;MAClEjD,cAAM,CAAC8B,IAAI,CAAE,mCAAkC+I,QAAQ,CAAClI,MAAM,CAACM,EAAG,YAAW,IAAI,CAAC9C,MAAO,EAAC,CAAC;MAC3F;IACJ;IAEA,IAAI,CAACmI,KAAK,CAACnD,IAAI,CAAC0F,QAAQ,CAAC;IAEzB,IAAIJ,mBAAmB,EAAE;MACrB,KAAK,MAAM/H,KAAK,IAAImI,QAAQ,CAAClI,MAAM,CAACK,SAAS,EAAE,EAAE;QAC7ChD,cAAM,CAAC8B,IAAI,CACN,QAAO,IAAI,CAAC3B,MAAO,GAAE,GACjB,gBAAe,GACf,OAAMuC,KAAK,CAACO,EAAG,KAAI,GACnB,SAAQP,KAAK,CAACnD,IAAK,KAAI,GACvB,aAAYsL,QAAQ,CAAClI,MAAM,CAACM,EAAG,KAAI,GACnC,kBAAiB4H,QAAQ,CAACvL,OAAQ,KAAI,GACtC,WAAUoD,KAAK,CAACoI,OAAQ,EAAC,GACzB,sBAAqB,CAC7B;QAED,MAAMC,IAAI,GAAG1L,iBAAiB,CAACwL,QAAQ,CAACvL,OAAO,EAAEoD,KAAK,CAACnD,IAAI,CAAC;QAC5D,IAAI,IAAI,CAACyL,YAAY,CAAClI,GAAG,CAACiI,IAAI,CAAC,EAAE;UAC7B;UACA;UACA;UACA;UACA;UACA,MAAME,WAAW,GAAG,IAAI,CAACD,YAAY,CAACE,GAAG,CAACH,IAAI,CAAE;;UAEhD;UACA;UACA,IAAIE,WAAW,CAACE,MAAM,CAACC,UAAU,EAAEH,WAAW,CAACE,MAAM,CAACC,UAAU,CAACP,QAAQ,CAAClI,MAAM,CAAC;UAEjFsI,WAAW,CAACE,MAAM,CAACE,YAAY,CAAC3I,KAAK,CAAC;UACtC;UACA;UACAuI,WAAW,CAAC5G,SAAS,GAAG4G,WAAW,CAAC5G,SAAS,KAAK,UAAU,GAAG,UAAU,GAAG,UAAU;QAC1F,CAAC,MAAM;UACH;UACA;UACA;UACA;UACA,MAAMiH,SAAS,GAAG,IAAI,CAAC/K,QAAQ,CAAEgL,QAAQ,CAAC7I,KAAK,EAAEmI,QAAQ,CAAClI,MAAM,CAAC;;UAEjE;UACA,MAAM6I,cAAc,GAAG,IAAI,CAACjL,QAAQ,CAAEkL,eAAe,EAAE,CAAC9D,IAAI,CAAE+D,CAAC,IAAKA,CAAC,CAACP,MAAM,KAAKG,SAAS,CAAC;UAC3F,IAAIE,cAAc,EAAE;YAChB,IAAI,CAACR,YAAY,CAAC1H,GAAG,CAACyH,IAAI,EAAES,cAAc,CAAC;UAC/C,CAAC,MAAM;YACHxL,cAAM,CAACC,IAAI,CAAC,wDAAwD,CAAC;UACzE;QACJ;MACJ;IACJ;IAEAD,cAAM,CAAC8B,IAAI,CACN,QAAO,IAAI,CAAC3B,MAAO,GAAE,GACjB,sBAAqB,GACrB,QAAO0K,QAAQ,CAAClI,MAAM,CAACM,EAAG,KAAI,GAC9B,WAAU4H,QAAQ,CAAClI,MAAM,CAAC2H,MAAO,KAAI,GACrC,YAAWO,QAAQ,CAACvL,OAAQ,IAAG,CACvC;IAED,IAAI,CAACoB,IAAI,CAAC/C,SAAS,CAAC0M,YAAY,EAAE,IAAI,CAAC/B,KAAK,CAAC;EACjD;;EAEA;AACJ;AACA;AACA;AACA;EACWqD,eAAe,CAACd,QAAkB,EAAQ;IAC7C,MAAMe,mBAAmB,GAAGvM,iBAAiB,CAACwL,QAAQ,CAACvL,OAAO,EAAE,OAAO,CAAC;IACxE,MAAMuM,mBAAmB,GAAGxM,iBAAiB,CAACwL,QAAQ,CAACvL,OAAO,EAAE,OAAO,CAAC;IAExE,KAAK,MAAMwM,cAAc,IAAI,CAACF,mBAAmB,EAAEC,mBAAmB,CAAC,EAAE;MACrE;MACA;MACA;MACA,IAAI,IAAI,CAACb,YAAY,CAAClI,GAAG,CAACgJ,cAAc,CAAC,EAAE;QACvC,MAAMb,WAAW,GAAG,IAAI,CAACD,YAAY,CAACE,GAAG,CAACY,cAAc,CAAE;QAC1D,IAAIb,WAAW,CAACE,MAAM,EAAE,IAAI,CAAC5K,QAAQ,CAAEwL,WAAW,CAACd,WAAW,CAACE,MAAM,CAAC;MAC1E;IACJ;IAEA,IAAIN,QAAQ,CAACvL,OAAO,KAAK8H,wCAAwB,CAACS,WAAW,EAAE;MAC3D,IAAI,CAACnD,MAAM,CAACsH,eAAe,EAAE,CAACC,uBAAuB,CAACpB,QAAQ,CAAClI,MAAM,CAAC;IAC1E;IAEA,IAAI,CAACuJ,UAAU,CAACrB,QAAQ,CAAC;EAC7B;EAEQsB,cAAc,GAAS;IAC3B,KAAK,MAAMhK,IAAI,IAAI,IAAI,CAACmG,KAAK,EAAE;MAC3B,IAAI,CAACnG,IAAI,CAACqG,OAAO,EAAE,IAAI,CAAC,IAAI,CAACxD,WAAW,EAAE;QACtC7C,IAAI,CAACiK,OAAO,EAAE;MAClB;IACJ;IAEA,IAAI,CAAC9D,KAAK,GAAG,EAAE;IACf,IAAI,CAAC5H,IAAI,CAAC/C,SAAS,CAAC0M,YAAY,EAAE,IAAI,CAAC/B,KAAK,CAAC;EACjD;EAEQpF,kBAAkB,CAACP,MAAmB,EAAQ;IAClD,MAAMR,IAAI,GAAG,IAAI,CAACgG,iBAAiB,CAACxF,MAAM,CAACM,EAAE,CAAC;IAC9C,IAAI,CAACd,IAAI,EAAE;MACPnC,cAAM,CAACC,IAAI,CAAE,QAAO,IAAI,CAACE,MAAO,wCAAuCwC,MAAM,CAACM,EAAG,YAAW,CAAC;MAC7F;IACJ;IACA,IAAI,CAACiJ,UAAU,CAAC/J,IAAI,CAAC;EACzB;EAEQ+J,UAAU,CAAC/J,IAAc,EAAQ;IACrCA,IAAI,CAACiK,OAAO,EAAE;IACd,IAAI,CAAC9D,KAAK,CAAC+D,MAAM,CAAC,IAAI,CAAC/D,KAAK,CAACgE,OAAO,CAACnK,IAAI,CAAC,EAAE,CAAC,CAAC;IAC9C,IAAI,CAACzB,IAAI,CAAC/C,SAAS,CAAC0M,YAAY,EAAE,IAAI,CAAC/B,KAAK,CAAC;EACjD;;EAEA;EACA,MAAaiE,mBAAmB,GAA+B;IAC3D,IAAI,IAAI,CAAClM,YAAY,EAAE,EAAE;MACrB,OAAO,IAAI,CAACmM,cAAc;IAC9B;IAEA,OAAO,IAAI,CAACC,gBAAgB,EAAE;EAClC;EAEA,MAAcA,gBAAgB,GAA+B;IACzD;IACA;IACA,IAAI,CAAC,IAAI,CAAClM,QAAQ,EAAE;IAEpB,MAAMmM,WAAW,GAAG,MAAM,IAAI,CAACnM,QAAQ,CAACoM,QAAQ,EAAE;IAClD,MAAMC,KAAY,GAAG,EAAE;IACvBF,WAAW,CAACG,OAAO,CAAEC,IAAI,IAAK;MAC1BF,KAAK,CAACzH,IAAI,CAAC2H,IAAI,CAAC;IACpB,CAAC,CAAC;IAEF,OAAOF,KAAK;EAChB;;EAEA;AACJ;AACA;AACA;EACI,MAAaG,cAAc,CAAClN,KAAkB,EAAiB;IAAA;IAC3D,MAAMmN,MAAM,GAAGnN,KAAK,CAACoN,UAAU,EAAwB;IACvD,IAAI,CAAC5I,SAAS,GAAG5G,aAAa,CAAC6G,OAAO;;IAEtC;IACA;IACA,MAAM4I,aAAa,GAAG,MAAM,IAAI,CAACxI,MAAM,CAACyI,gBAAgB,EAAE;IAC1D,IAAI,CAACD,aAAa,EAAE;MAChBlN,cAAM,CAACC,IAAI,CAAE,QAAO,IAAI,CAACE,MAAO,iEAAgE,CAAC;IACrG;IAEA,MAAMiN,iBAAiB,GAAGJ,MAAM,CAACK,oCAAoB,CAAC;IACtD,IAAID,iBAAiB,EAAE;MACnB,IAAI,CAACE,6BAA6B,CAACF,iBAAiB,CAAC;IACzD,CAAC,MAAM;MACHpN,cAAM,CAACE,KAAK,CACP,QAAO,IAAI,CAACC,MAAO,2EAA0E,CACjG;IACL;IAEA,IAAI,CAACI,QAAQ,GAAG,IAAI,CAACgN,oBAAoB,EAAE;IAC3C;IACA;IACA;IACA,IAAI,CAACC,cAAc,CAAC3N,KAAK,CAAC;IAC1B,MAAM,IAAI,CAAC4I,kBAAkB,EAAE;IAC/B,IAAI;MACA,MAAM,IAAI,CAAClI,QAAQ,CAACkN,oBAAoB,CAACT,MAAM,CAACU,KAAK,CAAC;MACtD,MAAM,IAAI,CAACC,wBAAwB,EAAE;IACzC,CAAC,CAAC,OAAOC,CAAC,EAAE;MACR5N,cAAM,CAACE,KAAK,CAAE,QAAO,IAAI,CAACC,MAAO,mCAAkC,EAAEyN,CAAC,CAAC;MACvE,IAAI,CAAChN,SAAS,CAAClD,SAAS,CAACmD,KAAK,EAAEjD,aAAa,CAACiQ,oBAAoB,EAAE,KAAK,CAAC;MAC1E;IACJ;IAEA,MAAMC,YAAY,wBAAG,IAAI,CAACxF,KAAK,CAACX,IAAI,CAAExF,IAAI,IAAK,CAACA,IAAI,CAACqG,OAAO,EAAE,CAAC,sDAA1C,kBAA4C7F,MAAM;;IAEvE;IACA;IACA;IACA,IAAI,CAACmL,YAAY,IAAIA,YAAY,CAAC9K,SAAS,EAAE,CAACP,MAAM,KAAK,CAAC,EAAE;MACxDzC,cAAM,CAACS,KAAK,CAAE,QAAO,IAAI,CAACN,MAAO,kEAAiE,CAAC;MACnG,IAAI,CAACS,SAAS,CAAClD,SAAS,CAACmD,KAAK,EAAEjD,aAAa,CAACiQ,oBAAoB,EAAE,KAAK,CAAC;MAC1E;IACJ;IAEA,IAAI,CAACxM,KAAK,GAAG9D,SAAS,CAACsG,OAAO;IAE9B,IAAIhE,KAAK,CAACkO,WAAW,EAAE,EAAE;MACrB;MACA,MAAMC,YAAY,GAAG/L,UAAU,CAAC,MAAM;QAClC,IAAI,IAAI,CAACZ,KAAK,IAAI9D,SAAS,CAACsG,OAAO,EAAE;UACjC7D,cAAM,CAACE,KAAK,CAAE,QAAO,IAAI,CAACC,MAAO,kCAAiC,CAAC;UACnE,IAAI,CAAC8N,WAAW,GAAGvQ,SAAS,CAACoG,MAAM,CAAC,CAAC;UACrC,IAAI,CAACzC,KAAK,GAAG9D,SAAS,CAAC2Q,KAAK;UAC5B,IAAI,CAACC,YAAY,EAAE;UACnB,IAAI,IAAI,CAAC5N,QAAQ,CAAE+B,cAAc,IAAI,QAAQ,EAAE;YAC3C,IAAI,CAAC/B,QAAQ,CAAE6N,KAAK,EAAE;UAC1B;UACA,IAAI,CAAC1N,IAAI,CAAC/C,SAAS,CAAC0Q,MAAM,EAAE,IAAI,CAAC;QACrC;MACJ,CAAC,EAAErB,MAAM,CAACsB,QAAQ,GAAGzO,KAAK,CAACkO,WAAW,EAAE,CAAC;MAEzC,MAAMQ,OAAO,GAAIlN,KAAgB,IAAW;QACxC,IAAIA,KAAK,KAAK9D,SAAS,CAACsG,OAAO,EAAE;UAC7B1C,YAAY,CAAC6M,YAAY,CAAC;UAC1B,IAAI,CAACQ,GAAG,CAAC7Q,SAAS,CAACgJ,KAAK,EAAE4H,OAAO,CAAC;QACtC;MACJ,CAAC;MACD,IAAI,CAACE,EAAE,CAAC9Q,SAAS,CAACgJ,KAAK,EAAE4H,OAAO,CAAC;IACrC;EACJ;;EAEA;AACJ;AACA;AACA;EACWG,cAAc,CAAC7O,KAAkB,EAAQ;IAC5C;IACA;IACA;IACA,IAAI,CAACwB,KAAK,GAAG9D,SAAS,CAAC2Q,KAAK;EAChC;EAEQS,yBAAyB,CAC7BC,WAAgC,EAChCC,mBAA4B,EAC5BjI,IAAuB,EAChB;IACP,IAAIgI,WAAW,IAAI,CAACC,mBAAmB,EAAE;MACrC;MACA7O,cAAM,CAACC,IAAI,CACN,QAAO,IAAI,CAACE,MAAO,0BAAyByG,IAAK,kDAAiD,CACtG;MACD,OAAO,KAAK;IAChB,CAAC,MAAM,IACH,CAACtB,KAAK,CAACwJ,iBAAiB,CAACF,WAAW,CAAC,IACrCA,WAAW,KAAKC,mBAAmB,IACnC,CAAC,IAAI,CAAC/E,iCAAiC,EAAE,EAC3C;MACE9J,cAAM,CAACC,IAAI,CACN,QAAO,IAAI,CAACE,MAAO,0BAAyByG,IAAK,IAAGgI,WAAY,8DAA6DhI,IAAK,IAAGiI,mBAAoB,GAAE,CAC/J;MACD,OAAOA,mBAAmB;IAC9B;IACA,OAAOD,WAAW,aAAXA,WAAW,cAAXA,WAAW,GAAIC,mBAAmB;EAC7C;;EAEA;AACJ;AACA;EACI,MAAaE,MAAM,CAACC,KAAe,EAAEC,KAAe,EAAiB;IACjE,IAAI,IAAI,CAACC,kBAAkB,EAAE;IAC7B;IACA,IAAIF,KAAK,KAAK,KAAK,IAAIC,KAAK,KAAK,KAAK,EAAE,MAAM,IAAI9Q,KAAK,CAAC,wCAAwC,CAAC;IAEjG,IAAI,CAAC,IAAI,CAAC8I,oBAAoB,IAAI,CAAC,IAAI,CAACkI,oBAAoB,EAAE;MAC1D,MAAMC,SAAS,GAAG,IAAI,CAAC/N,KAAK;MAC5B,MAAMgO,eAAe,GAAG,IAAI,CAACV,yBAAyB,CAACK,KAAK,EAAE,IAAI,CAACxH,4BAA4B,EAAE,OAAO,CAAC;MACzG,MAAM8H,eAAe,GAAG,IAAI,CAACX,yBAAyB,CAACM,KAAK,EAAE,IAAI,CAACnI,4BAA4B,EAAE,OAAO,CAAC;MAEzG,IAAI,CAACzF,KAAK,GAAG9D,SAAS,CAACgS,cAAc;MACrC,IAAI,CAACJ,oBAAoB,GAAG,IAAI;MAEhC,IAAI;QAAA;QACA,MAAMxM,MAAM,GAAG,MAAM,IAAI,CAAC+B,MAAM,CAACsH,eAAe,EAAE,CAACwD,kBAAkB,CAACH,eAAe,EAAEC,eAAe,CAAC;QACvG,IAAI,CAACH,oBAAoB,GAAG,KAAK;QACjC,MAAMM,aAAa,GAAG,IAAItF,kBAAQ,CAAC;UAC/BzF,MAAM,EAAE,IAAI,CAACA,MAAM;UACnBF,MAAM,EAAE,IAAI,CAACA,MAAM;UACnBuE,MAAM,EAAE,IAAI,CAACrE,MAAM,CAACgG,SAAS,EAAG;UAChC/F,QAAQ,2BAAE,IAAI,CAACD,MAAM,CAACgL,WAAW,EAAE,yEAAItQ,SAAS;UAChDuD,MAAM;UACNrD,OAAO,EAAE8H,wCAAwB,CAACC,SAAS;UAC3C4C,UAAU,EAAE,KAAK;UACjBC,UAAU,EAAE;QAChB,CAAC,CAAC;QAEF,MAAM5B,KAAK,GAAG,CAACmH,aAAa,CAAC;QAE7B,IAAI,IAAI,CAAC7H,sBAAsB,EAAE;UAC7BU,KAAK,CAACnD,IAAI,CAAC,IAAI,CAACyC,sBAAsB,CAAC;QAC3C;QAEA,IAAI,CAAC+H,mBAAmB,CAACrH,KAAK,CAAC;MACnC,CAAC,CAAC,OAAOsF,CAAC,EAAE;QACR,IAAI0B,eAAe,EAAE;UACjB;UACAtP,cAAM,CAACC,IAAI,CAAE,QAAO,IAAI,CAACE,MAAO,mEAAkE,CAAC;UACnG,IAAI,CAACkB,KAAK,GAAG+N,SAAS;UACtB,IAAI,CAACD,oBAAoB,GAAG,KAAK;UACjC,MAAM,IAAI,CAACJ,MAAM,CAACM,eAAe,EAAE,KAAK,CAAC;QAC7C,CAAC,MAAM;UACH,IAAI,CAACtO,kBAAkB,CAAQ6M,CAAC,CAAC;UACjC;QACJ;MACJ;IACJ,CAAC,MAAM,IAAI,IAAI,CAACuB,oBAAoB,EAAE;MAClC,IAAI,CAAC9N,KAAK,GAAG9D,SAAS,CAACgS,cAAc;IACzC;EACJ;EAEOI,mBAAmB,CAACC,SAAqB,EAAQ;IACpD,IAAI,IAAI,CAACV,kBAAkB,EAAE;IAE7B,IAAI,CAACW,0BAA0B,CAACD,SAAS,CAAC;EAC9C;;EAEA;AACJ;AACA;AACA;AACA;EACWE,UAAU,CAACC,OAAmB,EAAQ;IACzC/P,cAAM,CAACE,KAAK,CAAE,QAAO,IAAI,CAACC,MAAO,gBAAe4P,OAAO,CAAC5P,MAAO,EAAC,CAAC;IACjE,IAAI,IAAI,CAACkB,KAAK,KAAK9D,SAAS,CAACgS,cAAc,EAAE;MACzCvP,cAAM,CAACE,KAAK,CAAE,QAAO,IAAI,CAACC,MAAO,qBAAoB4P,OAAO,CAAC5P,MAAO,0BAAyB,CAAC;MAC9F4P,OAAO,CAACZ,oBAAoB,GAAG,IAAI;IACvC,CAAC,MAAM,IAAI,CAAC5R,SAAS,CAACkG,WAAW,EAAElG,SAAS,CAAC6G,UAAU,CAAC,CAAClD,QAAQ,CAAC,IAAI,CAACG,KAAK,CAAC,EAAE;MAC3E,IAAI0O,OAAO,CAAC1L,SAAS,KAAK5G,aAAa,CAACuS,QAAQ,EAAE;QAC9CD,OAAO,CAACF,0BAA0B,CAAC,EAAE,CAAC;MAC1C,CAAC,MAAM;QACH7P,cAAM,CAACE,KAAK,CAAE,QAAO,IAAI,CAACC,MAAO,qCAAoC4P,OAAO,CAAC5P,MAAO,EAAC,CAAC;QACtF4P,OAAO,CAACF,0BAA0B,CAAC,IAAI,CAACnI,aAAa,EAAE,CAACuI,GAAG,CAAE9N,IAAI,IAAKA,IAAI,CAAC+N,KAAK,EAAE,CAAC,CAAC;MACxF;IACJ;IACA,IAAI,CAACpP,SAAS,GAAGiP,OAAO;IACxB,IAAI,CAACrP,IAAI,CAAC/C,SAAS,CAACwS,QAAQ,EAAEJ,OAAO,CAAC;IACtC,IAAI,CAAChO,MAAM,CAACnE,aAAa,CAACuS,QAAQ,EAAE,IAAI,CAAC;EAC7C;;EAEA;AACJ;AACA;AACA;AACA;EACWpO,MAAM,CAACgC,MAAqB,EAAEqM,aAAsB,EAAQ;IAC/D,IAAI,IAAI,CAAC/P,YAAY,EAAE,EAAE;IAEzBL,cAAM,CAACE,KAAK,CAAE,eAAc,IAAI,CAACC,MAAO,gBAAe4D,MAAO,EAAC,CAAC;IAChE,IAAI,CAACnD,SAAS,CAAClD,SAAS,CAACmD,KAAK,EAAEkD,MAAM,EAAE,CAACqM,aAAa,CAAC;IACvD;IACA,IAAI,CAAC7S,SAAS,CAACoC,SAAS,EAAEpC,SAAS,CAACgS,cAAc,CAAC,CAACrO,QAAQ,CAAC,IAAI,CAACG,KAAK,CAAC,EAAE;IAC1E,MAAMgP,OAAiB,GAAG,CAAC,CAAC;IAC5B;IACA,IAAK,IAAI,CAAC3M,eAAe,IAAI,IAAI,CAACA,eAAe,KAAK,CAAC,IAAKK,MAAM,KAAKnG,aAAa,CAACoG,UAAU,EAAE;MAC7FqM,OAAO,CAAC,QAAQ,CAAC,GAAGtM,MAAM;IAC9B;IACA,IAAI,CAACuM,aAAa,CAACC,gBAAS,CAACC,UAAU,EAAEH,OAAO,CAAC;EACrD;;EAEA;AACJ;AACA;AACA;AACA;EACWI,MAAM,GAAS;IAClB,IAAI,IAAI,CAACpP,KAAK,KAAK9D,SAAS,CAACsG,OAAO,EAAE;MAClC,MAAM1F,KAAK,CAAC,4CAA4C,CAAC;IAC7D;IAEA,IAAI,IAAI,CAACuF,eAAe,KAAK,CAAC,EAAE;MAC5B1D,cAAM,CAAC8B,IAAI,CACN,QAAO,IAAI,CAAC3B,MAAO,qCAAoC,IAAI,CAACuD,eAAgB,qCAAoC,CACpH;MACD,IAAI,CAAC3B,MAAM,CAACnE,aAAa,CAACoG,UAAU,EAAE,IAAI,CAAC;MAC3C;IACJ;IAEAhE,cAAM,CAACE,KAAK,CAAC,kBAAkB,GAAG,IAAI,CAACC,MAAM,CAAC;IAC9C,IAAI,CAACS,SAAS,CAAClD,SAAS,CAACmD,KAAK,EAAEjD,aAAa,CAACoG,UAAU,EAAE,IAAI,CAAC;IAC/D,IAAI,CAACsM,aAAa,CAACC,gBAAS,CAACG,UAAU,EAAE,CAAC,CAAC,CAAC;EAChD;;EAEA;AACJ;AACA;AACA;AACA;EACI,MAAcC,WAAW,CAAC3B,KAAc,EAAEC,KAAc,EAAiB;IACrE;IACA,IAAI,CAACD,KAAK,IAAI,CAACC,KAAK,EAAE;IACtB,IAAI,CAAC,IAAI,CAACnF,iCAAiC,EAAE,EAAE;IAE/C,IAAI;MACA9J,cAAM,CAACE,KAAK,CAAE,kBAAiB,IAAI,CAACC,MAAO,YAAW6O,KAAM,WAAUC,KAAM,EAAC,CAAC;MAC9E,MAAM2B,QAAQ,GAAG5B,KAAK,IAAI,IAAI,CAAC1H,2BAA2B;MAC1D,MAAMuJ,QAAQ,GAAG5B,KAAK,IAAI,IAAI,CAACpI,2BAA2B;;MAE1D;MACA;MACA,MAAMlE,MAAM,GAAG,MAAM,IAAI,CAAC+B,MAAM,CAACsH,eAAe,EAAE,CAACwD,kBAAkB,CAACoB,QAAQ,EAAEC,QAAQ,EAAE,KAAK,CAAC;MAChG,MAAM,IAAI,CAACC,0BAA0B,CAACnO,MAAM,EAAEqM,KAAK,EAAEC,KAAK,CAAC;IAC/D,CAAC,CAAC,OAAOxO,KAAK,EAAE;MACZT,cAAM,CAACS,KAAK,CAAE,QAAO,IAAI,CAACN,MAAO,6BAA4B,EAAEM,KAAK,CAAC;MACrE,IAAI,CAACC,IAAI,CACL/C,SAAS,CAACQ,KAAK,EACf,IAAID,SAAS,CAACN,aAAa,CAACoD,WAAW,EAAE,+BAA+B,EAASP,KAAK,CAAC,CAC1F;IACL;EACJ;;EAEA;AACJ;AACA;AACA;EACWqJ,iCAAiC,GAAY;IAChD,OAAO1D,OAAO,CAAC,IAAI,CAAC4D,uBAAuB,CAAC;EAChD;;EAEA;AACJ;AACA;AACA;EACW+G,eAAe,GAAY;IAC9B,OAAO3K,OAAO,CAAC,IAAI,CAAC0B,wBAAwB,CAAC;EACjD;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACI,MAAakJ,uBAAuB,CAAClG,OAAgB,EAAEpL,IAAyB,EAAoB;IAChG;IACA,IAAIoL,OAAO,IAAI,IAAI,CAACiG,eAAe,EAAE,EAAE;MACnC/Q,cAAM,CAACC,IAAI,CAAE,QAAO,IAAI,CAACE,MAAO,oEAAmE,CAAC;MACpG,OAAO,IAAI;IACf,CAAC,MAAM,IAAI,CAAC2K,OAAO,IAAI,CAAC,IAAI,CAACiG,eAAe,EAAE,EAAE;MAC5C/Q,cAAM,CAACC,IAAI,CAAE,QAAO,IAAI,CAACE,MAAO,uEAAsE,CAAC;MACvG,OAAO,KAAK;IAChB;;IAEA;IACA,IAAI,CAAC,IAAI,CAAC2J,iCAAiC,EAAE,EAAE;MAC3C,OAAO,IAAI,CAACmH,6CAA6C,CAACnG,OAAO,EAAEpL,IAAI,CAAC;IAC5E;IAEAM,cAAM,CAACE,KAAK,CAAE,QAAO,IAAI,CAACC,MAAO,+BAA8B2K,OAAQ,EAAC,CAAC;IACzE,IAAIA,OAAO,EAAE;MACT,IAAI;QACA,MAAMnI,MAAM,GAAG,MAAM,IAAI,CAAC+B,MAAM,CAACsH,eAAe,EAAE,CAACkF,sBAAsB,CAACxR,IAAI,CAAC;QAC/E,IAAI,CAACiD,MAAM,EAAE,OAAO,KAAK;QACzB,IAAI,CAAC6H,gBAAgB,CAAC7H,MAAM,EAAEyE,wCAAwB,CAACS,WAAW,CAAC;QACnE,OAAO,IAAI;MACf,CAAC,CAAC,OAAOtJ,GAAG,EAAE;QACVyB,cAAM,CAACS,KAAK,CAAE,QAAO,IAAI,CAACN,MAAO,uCAAsC,EAAE5B,GAAG,CAAC;QAC7E,OAAO,KAAK;MAChB;IACJ,CAAC,MAAM;MACH,MAAM4S,gBAAgB,GAAG,IAAI,CAACnG,YAAY,CAACE,GAAG,CAC1C7L,iBAAiB,CAAC+H,wCAAwB,CAACS,WAAW,EAAE,OAAO,CAAC,CACnE;MACD,MAAMuJ,gBAAgB,GAAG,IAAI,CAACpG,YAAY,CAACE,GAAG,CAC1C7L,iBAAiB,CAAC+H,wCAAwB,CAACS,WAAW,EAAE,OAAO,CAAC,CACnE;MAED,KAAK,MAAMoD,WAAW,IAAI,CAACkG,gBAAgB,EAAEC,gBAAgB,CAAC,EAAE;QAC5D;QACA;QACA,IAAInG,WAAW,IAAIA,WAAW,CAACE,MAAM,EAAE,IAAI,CAAC5K,QAAQ,CAAEwL,WAAW,CAACd,WAAW,CAACE,MAAM,CAAC;MACzF;MAEA,IAAI,CAACzG,MAAM,CAACsH,eAAe,EAAE,CAACC,uBAAuB,CAAC,IAAI,CAACnE,wBAAwB,CAAE;MACrF,IAAI,CAAC5E,kBAAkB,CAAC,IAAI,CAAC4E,wBAAwB,CAAE;MACvD,OAAO,KAAK;IAChB;EACJ;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,MAAcmJ,6CAA6C,CACvDnG,OAAgB,EAChBpL,IAAyB,EACT;IAChBM,cAAM,CAACE,KAAK,CAAE,QAAO,IAAI,CAACC,MAAO,+BAA8B2K,OAAQ,uBAAsB,CAAC;IAC9F,IAAIA,OAAO,EAAE;MACT,IAAI;QAAA;QACA,MAAMnI,MAAM,GAAG,MAAM,IAAI,CAAC+B,MAAM,CAACsH,eAAe,EAAE,CAACkF,sBAAsB,CAACxR,IAAI,CAAC;QAC/E,IAAI,CAACiD,MAAM,EAAE,OAAO,KAAK;QAEzB,MAAMD,KAAK,GAAGC,MAAM,CAACK,SAAS,EAAE,CAAC2E,IAAI,CAAEjF,KAAK,IAAKA,KAAK,CAACnD,IAAI,KAAK,OAAO,CAAC;QAExE,MAAM4L,MAAM,4BAAG,IAAI,CAACH,YAAY,CAACE,GAAG,CAChC7L,iBAAiB,CAAC+H,wCAAwB,CAACC,SAAS,EAAE,OAAO,CAAC,CACjE,0DAFc,sBAEZ8D,MAAM;QAETA,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEE,YAAY,CAAC3I,KAAK,aAALA,KAAK,cAALA,KAAK,GAAI,IAAI,CAAC;QAEnC,IAAI,CAAC8H,gBAAgB,CAAC7H,MAAM,EAAEyE,wCAAwB,CAACS,WAAW,EAAE,KAAK,CAAC;QAE1E,OAAO,IAAI;MACf,CAAC,CAAC,OAAOtJ,GAAG,EAAE;QACVyB,cAAM,CAACS,KAAK,CAAE,QAAO,IAAI,CAACN,MAAO,uCAAsC,EAAE5B,GAAG,CAAC;QAC7E,OAAO,KAAK;MAChB;IACJ,CAAC,MAAM;MAAA;MACH,MAAMmE,KAAK,6BAAG,IAAI,CAACuE,oBAAoB,2DAAzB,uBAA2BjE,SAAS,EAAE,CAAC2E,IAAI,CAAEjF,KAAK,IAAKA,KAAK,CAACnD,IAAI,KAAK,OAAO,CAAC;MAC5F,MAAM4L,MAAM,6BAAG,IAAI,CAACH,YAAY,CAACE,GAAG,CAChC7L,iBAAiB,CAAC+H,wCAAwB,CAACC,SAAS,EAAE,OAAO,CAAC,CACjE,2DAFc,uBAEZ8D,MAAM;MACTA,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEE,YAAY,CAAC3I,KAAK,aAALA,KAAK,cAALA,KAAK,GAAI,IAAI,CAAC;MAEnC,IAAI,CAACgC,MAAM,CAACsH,eAAe,EAAE,CAACC,uBAAuB,CAAC,IAAI,CAACnE,wBAAwB,CAAE;MACrF,IAAI,CAAC5E,kBAAkB,CAAC,IAAI,CAAC4E,wBAAwB,CAAE;MAEvD,OAAO,KAAK;IAChB;EACJ;;EAEA;AACJ;AACA;AACA;EACI,MAAagJ,0BAA0B,CACnCnO,MAAmB,EACnB0O,UAAU,GAAG,KAAK,EAClBC,UAAU,GAAG,KAAK,EACL;IACb,MAAMzG,QAAQ,GAAG,IAAI,CAACpD,kBAAmB;IACzC,MAAM8J,YAAY,GAAGF,UAAU,IAAK,CAACxG,QAAQ,CAACnB,YAAY,EAAE,IAAI,CAAC,IAAI,CAAC8H,YAAa;IACnF,MAAMC,YAAY,GAAGH,UAAU,IAAK,CAACzG,QAAQ,CAACjB,YAAY,EAAE,IAAI,CAAC,IAAI,CAAC4H,YAAa;IACnFxR,cAAM,CAAC0R,GAAG,CACL,QAAO,IAAI,CAACvR,MAAO,sCAAqCwC,MAAM,CAACM,EAAG,iBAAgBsO,YAAa,iBAAgBE,YAAa,EAAC,CACjI;IACD9G,gBAAgB,CAAChI,MAAM,CAAC4E,cAAc,EAAE,EAAEgK,YAAY,CAAC;IACvD5G,gBAAgB,CAAChI,MAAM,CAACuE,cAAc,EAAE,EAAEuK,YAAY,CAAC;;IAEvD;IACA,KAAK,MAAM/O,KAAK,IAAI,IAAI,CAACuE,oBAAoB,CAAEjE,SAAS,EAAE,EAAE;MACxD,IAAI,CAACiE,oBAAoB,CAAE8E,WAAW,CAACrJ,KAAK,CAAC;MAC7CA,KAAK,CAACiP,IAAI,EAAE;IAChB;IACA,KAAK,MAAMjP,KAAK,IAAIC,MAAM,CAACK,SAAS,EAAE,EAAE;MACpC,IAAI,CAACiE,oBAAoB,CAAEsE,QAAQ,CAAC7I,KAAK,CAAC;IAC9C;IAEA,KAAK,MAAMA,KAAK,IAAIC,MAAM,CAACK,SAAS,EAAE,EAAE;MAAA;MACpC,MAAM+H,IAAI,GAAG1L,iBAAiB,CAAC+H,wCAAwB,CAACC,SAAS,EAAE3E,KAAK,CAACnD,IAAI,CAAC;MAE9E,MAAMqS,SAAS,6BAAG,IAAI,CAAC5G,YAAY,CAACE,GAAG,CAACH,IAAI,CAAC,2DAA3B,uBAA6BI,MAAM;MACrD,IAAI0G,KAAK,GAAG,KAAK;MACjB,IAAID,SAAS,EAAE;QACX,IAAI;UACA5R,cAAM,CAAC8B,IAAI,CACN,QAAO,IAAI,CAAC3B,MAAO,GAAE,GACjB,mBAAkB,GAClB,OAAMuC,KAAK,CAACO,EAAG,KAAI,GACnB,SAAQP,KAAK,CAACnD,IAAK,KAAI,GACvB,aAAYoD,MAAM,CAACM,EAAG,KAAI,GAC1B,kBAAiB4H,QAAQ,CAACvL,OAAQ,GAAE,GACpC,sBAAqB,CAC7B;UACD,MAAMsS,SAAS,CAACvG,YAAY,CAAC3I,KAAK,CAAC;UACnCmP,KAAK,GAAG,IAAI;QAChB,CAAC,CAAC,OAAOpR,KAAK,EAAE;UACZT,cAAM,CAACC,IAAI,CAAE,qDAAoD,EAAEQ,KAAK,CAAC;QAC7E;MACJ;MAEA,IAAI,CAACoR,KAAK,EAAE;QACR7R,cAAM,CAAC8B,IAAI,CACN,QAAO,IAAI,CAAC3B,MAAO,GAAE,GACjB,gBAAe,GACf,OAAMuC,KAAK,CAACO,EAAG,KAAI,GACnB,SAAQP,KAAK,CAACnD,IAAK,KAAI,GACvB,aAAYoD,MAAM,CAACM,EAAG,KAAI,GAC1B,kBAAiB4H,QAAQ,CAACvL,OAAQ,GAAE,GACpC,sBAAqB,CAC7B;QAED,MAAMgM,SAAS,GAAG,IAAI,CAAC/K,QAAQ,CAAEgL,QAAQ,CAAC7I,KAAK,EAAE,IAAI,CAACuE,oBAAoB,CAAE;QAC5E,MAAMuE,cAAc,GAAG,IAAI,CAACjL,QAAQ,CAAEkL,eAAe,EAAE,CAAC9D,IAAI,CAAE+D,CAAC,IAAKA,CAAC,CAACP,MAAM,KAAKG,SAAS,CAAC;QAC3F,IAAIE,cAAc,EAAE;UAChB,IAAI,CAACR,YAAY,CAAC1H,GAAG,CAACyH,IAAI,EAAES,cAAc,CAAC;QAC/C,CAAC,MAAM;UACHxL,cAAM,CAACC,IAAI,CAAC,2DAA2D,CAAC;QAC5E;MACJ;IACJ;EACJ;;EAEA;AACJ;AACA;AACA;AACA;EACI,MAAa6R,kBAAkB,CAACC,KAAc,EAAoB;IAAA;IAC9D/R,cAAM,CAAC0R,GAAG,CAAE,QAAO,IAAI,CAACvR,MAAO,uBAAsB4R,KAAM,EAAC,CAAC;IAC7D,IAAI,EAAE,MAAM,IAAI,CAACrN,MAAM,CAACsH,eAAe,EAAE,CAACgG,cAAc,EAAE,CAAC,EAAE;MACzD,OAAO,IAAI,CAACC,iBAAiB,EAAE;IACnC;IAEA,IAAI,CAAC,IAAI,CAACpL,2BAA2B,IAAI,CAACkL,KAAK,EAAE;MAC7C,MAAM,IAAI,CAACpB,WAAW,CAAC,KAAK,EAAE,IAAI,CAAC;MACnC,OAAO,IAAI,CAACsB,iBAAiB,EAAE;IACnC;IACA,8BAAI,CAACxK,kBAAkB,2DAAvB,uBAAyBpF,kBAAkB,CAAC,IAAI,EAAE0P,KAAK,CAAC;IACxD,IAAI,CAACG,gBAAgB,EAAE;IACvB,MAAM,IAAI,CAACC,kBAAkB,EAAE;IAC/B,OAAO,IAAI,CAACF,iBAAiB,EAAE;EACnC;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACWA,iBAAiB,GAAY;IAAA;IAChC,2DAAO,IAAI,CAACxK,kBAAkB,2DAAvB,uBAAyBmC,YAAY,EAAE,2EAAI,KAAK;EAC3D;;EAEA;AACJ;AACA;AACA;AACA;EACI,MAAawI,kBAAkB,CAACL,KAAc,EAAoB;IAAA;IAC9D/R,cAAM,CAAC0R,GAAG,CAAE,QAAO,IAAI,CAACvR,MAAO,uBAAsB4R,KAAM,EAAC,CAAC;IAC7D,IAAI,EAAE,MAAM,IAAI,CAACrN,MAAM,CAACsH,eAAe,EAAE,CAACqG,cAAc,EAAE,CAAC,EAAE;MACzD,OAAO,IAAI,CAACC,iBAAiB,EAAE;IACnC;IAEA,IAAI,CAAC,IAAI,CAAChL,2BAA2B,IAAI,CAACyK,KAAK,EAAE;MAC7C,MAAM,IAAI,CAACpB,WAAW,CAAC,IAAI,EAAE,KAAK,CAAC;MACnC,OAAO,IAAI,CAAC2B,iBAAiB,EAAE;IACnC;IACA,8BAAI,CAAC7K,kBAAkB,2DAAvB,uBAAyBpF,kBAAkB,CAAC0P,KAAK,EAAE,IAAI,CAAC;IACxD,IAAI,CAACG,gBAAgB,EAAE;IACvB,MAAM,IAAI,CAACC,kBAAkB,EAAE;IAC/B,OAAO,IAAI,CAACG,iBAAiB,EAAE;EACnC;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACWA,iBAAiB,GAAY;IAAA;IAChC,2DAAO,IAAI,CAAC7K,kBAAkB,2DAAvB,uBAAyBiC,YAAY,EAAE,2EAAI,KAAK;EAC3D;;EAEA;AACJ;AACA;AACA;EACW6I,cAAc,GAAY;IAC7B,OAAO,IAAI,CAACf,YAAY;EAC5B;EAEOgB,eAAe,CAACC,MAAe,EAAQ;IAC1C,IAAI,IAAI,CAACF,cAAc,EAAE,KAAKE,MAAM,EAAE;IACtC,IAAI,CAACjB,YAAY,GAAGiB,MAAM;IAE1B,KAAK,MAAMxH,WAAW,IAAI,IAAI,CAAC1K,QAAQ,CAAEkL,eAAe,EAAE,EAAE;MACxD;MACA;MACA;MACAR,WAAW,CAAC5G,SAAS,GAAGoO,MAAM,GAAG,UAAU,GAAG,UAAU;IAC5D;IACA,IAAI,CAACP,gBAAgB,EAAE;IACvB,IAAI,CAACC,kBAAkB,EAAE;IAEzB,IAAI,CAACzR,IAAI,CAAC/C,SAAS,CAAC+U,gBAAgB,EAAE,IAAI,CAAClB,YAAY,CAAC;EAC5D;;EAEA;AACJ;AACA;AACA;AACA;EACWmB,aAAa,GAAY;IAC5B,IAAI,IAAI,CAACtR,KAAK,KAAK9D,SAAS,CAAC+D,SAAS,EAAE,OAAO,KAAK;IAEpD,IAAIsR,UAAU,GAAG,IAAI;;IAErB;IACA;IACA,KAAK,MAAM3H,WAAW,IAAI,IAAI,CAAC1K,QAAQ,CAAEkL,eAAe,EAAE,EAAE;MACxD,MAAMoH,WAAW,GAAG,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC3R,QAAQ,CAAC+J,WAAW,CAAC6H,gBAAgB,CAAE;MAEpF,IAAI,CAACD,WAAW,EAAED,UAAU,GAAG,KAAK;IACxC;IAEA,OAAOA,UAAU;EACrB;;EAEA;AACJ;AACA;AACA;EACWG,aAAa,CAACC,KAAa,EAAQ;IACtC,KAAK,MAAM7H,MAAM,IAAI,IAAI,CAAC5K,QAAQ,CAAE0S,UAAU,EAAE,EAAE;MAAA;MAC9C,IAAI,kBAAA9H,MAAM,CAACzI,KAAK,kDAAZ,cAAcnD,IAAI,MAAK,OAAO,IAAI4L,MAAM,CAAC+H,IAAI,EAAE;QAC/C/H,MAAM,CAAC+H,IAAI,CAACC,UAAU,CAACH,KAAK,CAAC;QAC7B;MACJ;IACJ;IAEA,MAAM,IAAI7U,KAAK,CAAC,wCAAwC,CAAC;EAC7D;EAEQ+T,gBAAgB,GAAS;IAC7B,MAAMkB,gBAAgB,GAAG,IAAI,CAACd,iBAAiB,EAAE,IAAI,IAAI,CAACd,YAAY;IACtE,MAAM6B,gBAAgB,GAAG,IAAI,CAACpB,iBAAiB,EAAE,IAAI,IAAI,CAACT,YAAY;IAEtExR,cAAM,CAAC0R,GAAG,CACL,QAAO,IAAI,CAACvR,MAAO,4BAChB,IAAI,CAAC8G,oBAAoB,CAAEhE,EAC9B,qBAAoBmQ,gBAAiB,qBAAoBC,gBAAiB,EAAC,CAC/E;IACD1I,gBAAgB,CAAC,IAAI,CAAC1D,oBAAoB,CAAEM,cAAc,EAAE,EAAE,CAAC6L,gBAAgB,CAAC;IAChFzI,gBAAgB,CAAC,IAAI,CAAC1D,oBAAoB,CAAEC,cAAc,EAAE,EAAE,CAACmM,gBAAgB,CAAC;EACpF;EAEA,MAAalB,kBAAkB,GAAkB;IAC7C,MAAM,IAAI,CAAC7B,aAAa,CAACC,gBAAS,CAAC+C,kCAAkC,EAAE;MACnE,CAACjG,oCAAoB,GAAG,IAAI,CAACjE,yBAAyB;IAC1D,CAAC,CAAC;EACN;EAEQmK,qBAAqB,CAAC3D,SAAqB,EAAE4D,sBAAsB,GAAG,KAAK,EAAQ;IACvF,IAAI,IAAI,CAAC1S,SAAS,EAAE;MAChB,IAAI,CAACA,SAAS,CAAC+O,0BAA0B,CAACD,SAAS,CAAC;MACpD;IACJ;IACA,IAAI,IAAI,CAACvP,YAAY,EAAE,EAAE;MACrB,IAAI,CAAC8N,YAAY,EAAE;MACnB;IACJ;IAEA,KAAK,MAAMhM,IAAI,IAAIyN,SAAS,EAAE;MAC1B,IAAI,CAAChF,aAAa,CAACzI,IAAI,CAAC;IAC5B;IAEA,IAAIqR,sBAAsB,EAAE;MACxB,IAAI,CAACjT,QAAQ,CAAEkT,cAAc,CAAC,OAAO,EAAE;QACnCpP,SAAS,EAAE;MACf,CAAC,CAAC;IACN;IAEA,IAAI,CAAChD,KAAK,GAAG9D,SAAS,CAACkG,WAAW;IAElCzD,cAAM,CAACE,KAAK,CAAE,QAAO,IAAI,CAACC,MAAO,wBAAuB,CAAC;IACzD;EACJ;;EAEA,MAAcuT,UAAU,GAAkB;IACtC,MAAMC,aAAa,GAAG;MAClB5E,MAAM,EAAE;QACJ6E,GAAG,EAAE,IAAI,CAACrT,QAAQ,CAAEsT,gBAAgB,CAAED,GAAG;QACzC;QACA;QACAhN,IAAI,EAAE,IAAI,CAACrG,QAAQ,CAAEsT,gBAAgB,CAAEjN;MAC3C,CAAC;MACD,CAACyG,oCAAoB,GAAG,IAAI,CAACjE,yBAAyB,CAAC,IAAI;IAC/D,CAAgB;IAEhBuK,aAAa,CAACG,YAAY,GAAG;MACzB,mBAAmB,EAAE,IAAI,CAACpP,MAAM,CAACqP,oBAAoB;MACrD,aAAa,EAAE;IACnB,CAAC;;IAED;IACA;IACA;IACA,MAAMC,YAAY,GAAG,IAAI,CAACC,0BAA0B,EAAE;IACtDjU,cAAM,CAAC8B,IAAI,CAAE,QAAO,IAAI,CAAC3B,MAAO,eAAc6T,YAAa,yCAAwC,CAAC;IAEpG,IAAI;MACA,MAAM,IAAI,CAAC1D,aAAa,CAACC,gBAAS,CAAC2D,UAAU,EAAEP,aAAa,CAAC;MAC7D;MACA;MACA,IAAI,CAACzE,kBAAkB,GAAG,IAAI;IAClC,CAAC,CAAC,OAAOzO,KAAK,EAAE;MACZ;MACA,IAAI,CAACY,KAAK,GAAG9D,SAAS,CAACsG,OAAO;MAC9B,IAAIpD,KAAK,YAAY0T,oBAAW,IAAI1T,KAAK,CAACZ,KAAK,EAAE,IAAI,CAAC6E,MAAM,CAAC0P,kBAAkB,CAAC3T,KAAK,CAACZ,KAAK,CAAC;MAE5F,IAAIxB,IAAI,GAAGT,aAAa,CAACyW,UAAU;MACnC,IAAIC,OAAO,GAAG,uBAAuB;MACrC,IAAY7T,KAAK,CAAE8T,IAAI,IAAI,oBAAoB,EAAE;QAC7ClW,IAAI,GAAGT,aAAa,CAAC4W,cAAc;QACnCF,OAAO,GAAG,qCAAqC;MACnD;MACA,IAAI,CAAC5T,IAAI,CAAC/C,SAAS,CAACQ,KAAK,EAAE,IAAID,SAAS,CAACG,IAAI,EAAEiW,OAAO,EAAS7T,KAAK,CAAC,CAAC;MACtE,MAAMA,KAAK;IACf;;IAEA;IACA;IACA,IAAI,CAACgU,kBAAkB,EAAE;EAC7B;EAEQ5E,0BAA0B,CAACD,SAAqB,EAAQ;IAC5D;IACA,IAAI,IAAI,CAAC8E,oBAAoB,EAAE;MAC3B,IAAI,CAACA,oBAAoB,GAAG,IAAI,CAACA,oBAAoB,CAACC,IAAI,CAAC,MAAM,IAAI,CAACC,qBAAqB,CAAChF,SAAS,CAAC,CAAC;IAC3G,CAAC,MAAM;MACH,IAAI,CAAC8E,oBAAoB,GAAG,IAAI,CAACE,qBAAqB,CAAChF,SAAS,CAAC;IACrE;EACJ;;EAEA;EACA;EACQiF,QAAQ,CAACC,WAAsC,EAAE/V,IAAsB,EAAQ;IACnF;IACA,MAAM6U,GAAG,GAAG,IAAAmB,mBAAQ,EAACD,WAAW,CAAClB,GAAG,CAAE;IAEtCA,GAAG,CAACoB,KAAK,CAACnI,OAAO,CAAEmI,KAAK,IAAK;MACzB,MAAMC,qBAAqB,GAAG,IAAIrV,GAAG,EAAkB;MACvD,MAAMsV,qBAAqB,GAAG,IAAItV,GAAG,EAAkB;MACvD,KAAK,MAAMuV,GAAG,IAAIH,KAAK,CAACG,GAAG,EAAE;QACzBF,qBAAqB,CAAC3R,GAAG,CAAC6R,GAAG,CAACC,OAAO,EAAED,GAAG,CAAClW,KAAK,CAAC;QACjDiW,qBAAqB,CAAC5R,GAAG,CAAC6R,GAAG,CAAClW,KAAK,EAAEkW,GAAG,CAACC,OAAO,CAAC;MACrD;MAEA,KAAK,MAAMC,GAAG,IAAItW,IAAI,EAAE;QACpB,IAAIsW,GAAG,CAACrW,SAAS,KAAKgW,KAAK,CAACpO,IAAI,EAAE;QAElC,IAAI,CAACsO,qBAAqB,CAACpS,GAAG,CAACuS,GAAG,CAACpW,KAAK,CAAC,EAAE;UACvCe,cAAM,CAAC8B,IAAI,CAAE,kCAAiCuT,GAAG,CAACpW,KAAM,uBAAsB,CAAC;UAC/E;QACJ;QAEA,MAAMqW,WAAqB,GAAG,EAAE;QAChC,IAAID,GAAG,CAACnW,SAAS,KAAKE,SAAS,EAAE;UAC7BkW,WAAW,CAACnQ,IAAI,CAAE,UAASkQ,GAAG,CAACnW,SAAS,GAAG,GAAG,GAAG,GAAI,EAAC,CAAC;QAC3D;QACA,IAAImW,GAAG,CAAClW,iBAAiB,KAAKC,SAAS,EAAE;UACrCkW,WAAW,CAACnQ,IAAI,CAAE,qBAAoBkQ,GAAG,CAAClW,iBAAkB,EAAC,CAAC;QAClE;QAEA,IAAIoW,KAAK,GAAG,KAAK;QACjB,KAAK,MAAMC,IAAI,IAAIR,KAAK,CAACQ,IAAI,EAAE;UAC3B,IAAIP,qBAAqB,CAAC/J,GAAG,CAACsK,IAAI,CAACJ,OAAO,CAAC,KAAKC,GAAG,CAACpW,KAAK,EAAE;YACvDsW,KAAK,GAAG,IAAI;YACZC,IAAI,CAACC,MAAM,IAAI,GAAG,GAAGH,WAAW,CAACI,IAAI,CAAC,GAAG,CAAC;UAC9C;QACJ;QACA,IAAI,CAACH,KAAK,EAAE;UACRP,KAAK,CAACQ,IAAI,CAACrQ,IAAI,CAAC;YACZiQ,OAAO,EAAEF,qBAAqB,CAAChK,GAAG,CAACmK,GAAG,CAACpW,KAAK,CAAE;YAC9CwW,MAAM,EAAEH,WAAW,CAACI,IAAI,CAAC,GAAG;UAChC,CAAC,CAAC;QACN;MACJ;IACJ,CAAC,CAAC;IACFZ,WAAW,CAAClB,GAAG,GAAG,IAAA+B,mBAAQ,EAAC/B,GAAG,CAAC;EACnC;EAEA,MAAcgC,WAAW,GAAuC;IAC5D,MAAMlI,KAAK,GAAG,MAAM,IAAI,CAACnN,QAAQ,CAAEqV,WAAW,EAAE;IAChD,IAAI,CAACf,QAAQ,CAACnH,KAAK,EAAE7O,iBAAiB,CAAC,IAAI,CAACC,KAAK,CAAC,CAAC;IACnD,OAAO4O,KAAK;EAChB;EAEA,MAAcmI,YAAY,GAAuC;IAC7D,MAAM9G,MAAM,GAAG,MAAM,IAAI,CAACxO,QAAQ,CAAEsV,YAAY,EAAE;IAClD,IAAI,CAAChB,QAAQ,CAAC9F,MAAM,EAAElQ,iBAAiB,CAAC,IAAI,CAACC,KAAK,CAAC,CAAC;IACpD,OAAOiQ,MAAM;EACjB;EAEA,MAAc6F,qBAAqB,CAAChF,SAAqB,EAAiB;IACtE,IAAI,IAAI,CAACvP,YAAY,EAAE,EAAE;IAEzB,IAAI,CAAC8O,oBAAoB,GAAG,KAAK;IAEjC,KAAK,MAAMhN,IAAI,IAAIyN,SAAS,EAAE;MAC1B,IAAI,CAAChF,aAAa,CAACzI,IAAI,CAAC;IAC5B;IAEA,IAAI,CAACd,KAAK,GAAG9D,SAAS,CAACuY,YAAY;IAEnC,IAAI/G,MAAiC;IACrC,IAAI;MACA,IAAI,CAACgH,iBAAiB,EAAE;MACxBhH,MAAM,GAAG,MAAM,IAAI,CAAC8G,YAAY,EAAE;IACtC,CAAC,CAAC,OAAOtX,GAAG,EAAE;MACVyB,cAAM,CAACE,KAAK,CAAE,QAAO,IAAI,CAACC,MAAO,4BAA2B,EAAE5B,GAAG,CAAC;MAClE,IAAI,CAACqC,SAAS,CAAClD,SAAS,CAACmD,KAAK,EAAEjD,aAAa,CAACkY,YAAY,EAAE,IAAI,CAAC;MACjE;IACJ;IAEA,IAAI;MACA,MAAM,IAAI,CAACvV,QAAQ,CAAEyV,mBAAmB,CAACjH,MAAM,CAAC;;MAEhD;MACA,IAAI,IAAI,CAAC1O,YAAY,EAAE,EAAE;MAEzB,IAAI,CAACgB,KAAK,GAAG9D,SAAS,CAAC2E,UAAU;;MAEjC;MACA,MAAM,IAAI+T,OAAO,CAAEC,OAAO,IAAK;QAC3BjU,UAAU,CAACiU,OAAO,EAAE,GAAG,CAAC;MAC5B,CAAC,CAAC;;MAEF;MACA,IAAI,IAAI,CAAC7V,YAAY,EAAE,EAAE;MAEzB,IAAI,CAACqT,UAAU,EAAE;IACrB,CAAC,CAAC,OAAOnV,GAAG,EAAE;MACVyB,cAAM,CAACE,KAAK,CAAE,QAAO,IAAI,CAACC,MAAO,mCAAkC,EAAE5B,GAAG,CAAC;MACzE,IAAI,CAACqC,SAAS,CAAClD,SAAS,CAACmD,KAAK,EAAEjD,aAAa,CAACuY,mBAAmB,EAAE,IAAI,CAAC;MACxE;IACJ;EACJ;;EAEA;AACJ;AACA;;EAoCI,MAAaC,6BAA6B,CAAC7T,EAAe,EAAiB;IACvE,IAAI,IAAI,CAAClC,YAAY,EAAE,EAAE;MACrB;MACA;IACJ;IAEA,MAAMgQ,OAAO,GAAG9N,EAAE,CAAC0K,UAAU,EAAmB;IAChD,MAAMoJ,UAAU,GAAGhG,OAAO,CAACgG,UAAU;IACrC,IAAI,CAACA,UAAU,EAAE;MACbrW,cAAM,CAAC8B,IAAI,CAAE,QAAO,IAAI,CAAC3B,MAAO,gDAA+C,CAAC;MAChF;IACJ;IAEA,MAAMmW,WAAW,GAAGjG,OAAO,CAACkG,OAAO,KAAK,CAAC,GAAG,IAAI,GAAGlG,OAAO,CAACpM,QAAQ,IAAI,IAAI;IAE3E,IAAI,IAAI,CAACC,eAAe,KAAK9E,SAAS,EAAE;MACpC;MACA,IAAIkX,WAAW,EAAE;QACbtW,cAAM,CAAC8B,IAAI,CAAE,QAAO,IAAI,CAAC3B,MAAO,cAAakW,UAAU,CAAC5T,MAAO,uCAAsC,CAAC;QACtG,MAAM+T,kBAAkB,GAAG,IAAI,CAACC,qBAAqB,CAACvL,GAAG,CAACoL,WAAW,CAAC,IAAI,EAAE;QAC5EE,kBAAkB,CAACrR,IAAI,CAAC,GAAGkR,UAAU,CAAC;QACtC,IAAI,CAACI,qBAAqB,CAACnT,GAAG,CAACgT,WAAW,EAAEE,kBAAkB,CAAC;MACnE;MACA;IACJ;IAEA,IAAI,CAAC,IAAI,CAAC5S,cAAc,CAACyM,OAAO,CAAC,EAAE;MAC/BrQ,cAAM,CAAC8B,IAAI,CACN,QAAO,IAAI,CAAC3B,MAAO,GAAE,GACjB,qCAAoCkQ,OAAO,CAACpM,QAAS,IAAG,GACxD,2BAA0B,IAAI,CAACC,eAAgB,EAAC,CACxD;MAED;IACJ;IAEA,MAAM,IAAI,CAACwS,gBAAgB,CAACL,UAAU,CAAC;EAC3C;;EAEA;AACJ;AACA;EACI,MAAaM,gBAAgB,CAAC9W,KAAkB,EAAiB;IAC7D,MAAMwQ,OAAO,GAAGxQ,KAAK,CAACoN,UAAU,EAAe;IAC/CjN,cAAM,CAACE,KAAK,CAAE,0BAAyB,IAAI,CAACC,MAAO,kBAAiBkQ,OAAO,CAACpM,QAAS,EAAC,CAAC;IAEvF,IAAI,IAAI,CAAC5D,YAAY,EAAE,EAAE;MACrBL,cAAM,CAACE,KAAK,CAAE,mCAAkC,IAAI,CAACC,MAAO,YAAW,CAAC;MACxE;IACJ;IAEA,IAAI,IAAI,CAAC+D,eAAe,KAAK9E,SAAS,EAAE;MACpCY,cAAM,CAAC8B,IAAI,CACN,QAAO,IAAI,CAAC3B,MAAO,GAAE,GACjB,iCAAgCkQ,OAAO,CAACpM,QAAS,IAAG,GACpD,yCAAwC,IAAI,CAACC,eAAgB,EAAC,CACtE;MACD;IACJ;IAEA,IAAI,CAACsJ,cAAc,CAAC3N,KAAK,CAAC;IAC1B,MAAM,IAAI,CAAC8N,wBAAwB,EAAE;IAErC,IAAI,CAACtM,KAAK,GAAG9D,SAAS,CAAC2E,UAAU;IAEjC,MAAMkL,iBAAiB,GAAGiD,OAAO,CAAChD,oCAAoB,CAAC;IACvD,IAAID,iBAAiB,EAAE;MACnB,IAAI,CAACE,6BAA6B,CAACF,iBAAiB,CAAC;IACzD,CAAC,MAAM;MACHpN,cAAM,CAACC,IAAI,CAAE,QAAO,IAAI,CAACE,MAAO,2EAA0E,CAAC;IAC/G;IAEA,IAAI;MACA,MAAM,IAAI,CAACI,QAAQ,CAAEkN,oBAAoB,CAAC4C,OAAO,CAACtB,MAAM,CAAC;IAC7D,CAAC,CAAC,OAAOnB,CAAC,EAAE;MACR5N,cAAM,CAACE,KAAK,CAAE,QAAO,IAAI,CAACC,MAAO,mCAAkC,EAAEyN,CAAC,CAAC;MACvE,IAAI,CAAChN,SAAS,CAAClD,SAAS,CAACmD,KAAK,EAAEjD,aAAa,CAACiQ,oBAAoB,EAAE,KAAK,CAAC;MAC1E;IACJ;;IAEA;IACA;IACA;IACA,IAAI,IAAI,CAAC3J,eAAe,KAAK,IAAI,EAAE;MAC/B,IAAI;QACA,MAAM,IAAI,CAACoM,aAAa,CAACC,gBAAS,CAACqG,gBAAgB,EAAE;UACjDC,iBAAiB,EAAE,IAAI,CAAC3S;QAC5B,CAAC,CAAC;MACN,CAAC,CAAC,OAAO3F,GAAG,EAAE;QACV;QACA;QACAyB,cAAM,CAACC,IAAI,CAAE,QAAO,IAAI,CAACE,MAAO,qCAAoC,EAAE5B,GAAG,CAAC;MAC9E;IACJ;EACJ;EAEA,MAAauY,sBAAsB,CAACjX,KAAkB,EAAiB;IACnE,IAAI,IAAI,CAACwE,SAAS,KAAK5G,aAAa,CAAC6G,OAAO,EAAE;MAC1CtE,cAAM,CAACC,IAAI,CAAE,QAAO,IAAI,CAACE,MAAO,mDAAkD,CAAC;MACnF;IACJ;IAEA,MAAM4W,eAAe,GAAGlX,KAAK,CAACoN,UAAU,EAAqB,CAAC4J,iBAAiB;IAE/E,IAAIE,eAAe,KAAK3X,SAAS,IAAI2X,eAAe,KAAK,IAAI,EAAE;MAC3D/W,cAAM,CAACC,IAAI,CACN,QAAO,IAAI,CAACE,MAAO,gFAA+E,CACtG;MACD;IACJ;IAEA,IAAI4W,eAAe,KAAK,IAAI,CAAClS,UAAU,EAAE;MACrC7E,cAAM,CAAC8B,IAAI,CACN,QAAO,IAAI,CAAC3B,MAAO,mCAAkC4W,eAAgB,qBAAoB,IAAI,CAAClS,UAAW,GAAE,CAC/G;MACD;MACA,MAAM,IAAI,CAACjE,SAAS,CAAClD,SAAS,CAACoG,MAAM,EAAElG,aAAa,CAAC2G,iBAAiB,EAAE,IAAI,CAAC;IACjF;EACJ;EAEA,MAAayS,mBAAmB,CAACnX,KAAkB,EAAiB;IAChE,MAAMwQ,OAAO,GAAGxQ,KAAK,CAACoN,UAAU,EAAwB;IACxD,MAAM6H,WAAW,GAAGzE,OAAO,CAACyE,WAAW;IACvC,IAAI,CAACA,WAAW,IAAI,CAACA,WAAW,CAAClB,GAAG,IAAI,CAACkB,WAAW,CAAClO,IAAI,EAAE;MACvD5G,cAAM,CAAC8B,IAAI,CAAE,QAAO,IAAI,CAAC3B,MAAO,0CAAyC,CAAC;MAC1E;IACJ;IACA;IACA;IACA;IACA,MAAM8W,MAAM,GAAG,IAAI,CAAC5S,SAAS,KAAK5G,aAAa,CAAC6G,OAAO;;IAEvD;IACA;IACA,MAAM4S,cAAc,GAChBpC,WAAW,CAAClO,IAAI,KAAK,OAAO,KAAK,IAAI,CAACuQ,WAAW,IAAI,IAAI,CAAC5W,QAAQ,CAAE+B,cAAc,KAAK,QAAQ,CAAC;IAEpG,IAAI,CAAC8U,WAAW,GAAG,CAACH,MAAM,IAAIC,cAAc;IAC5C,IAAI,IAAI,CAACE,WAAW,EAAE;MAClBpX,cAAM,CAAC8B,IAAI,CAAE,QAAO,IAAI,CAAC3B,MAAO,4DAA2D,CAAC;MAC5F;IACJ;IAEA,MAAMkX,eAAe,GAAG,IAAI,CAAC1E,aAAa,EAAE;IAE5C,MAAMvF,iBAAiB,GAAGiD,OAAO,CAAChD,oCAAoB,CAAC;IACvD,IAAID,iBAAiB,EAAE;MACnB,IAAI,CAACE,6BAA6B,CAACF,iBAAiB,CAAC;IACzD,CAAC,MAAM;MACHpN,cAAM,CAACC,IAAI,CAAE,QAAO,IAAI,CAACE,MAAO,wDAAuD,CAAC;IAC5F;IAEA,IAAI;MACA,MAAM,IAAI,CAACI,QAAQ,CAAEkN,oBAAoB,CAACqH,WAAW,CAAC;MAEtD,IAAIA,WAAW,CAAClO,IAAI,KAAK,OAAO,EAAE;QAAA;QAC9B,IAAImI,MAAiC;QACrC,IAAI;UACA,IAAI,CAACgH,iBAAiB,EAAE;UACxBhH,MAAM,GAAG,MAAM,IAAI,CAAC8G,YAAY,EAAE;QACtC,CAAC,CAAC,OAAOtX,GAAG,EAAE;UACVyB,cAAM,CAACE,KAAK,CAAE,QAAO,IAAI,CAACC,MAAO,4BAA2B,EAAE5B,GAAG,CAAC;UAClE,IAAI,CAACqC,SAAS,CAAClD,SAAS,CAACmD,KAAK,EAAEjD,aAAa,CAACkY,YAAY,EAAE,IAAI,CAAC;UACjE;QACJ;QAEA,MAAM,IAAI,CAACvV,QAAQ,CAAEyV,mBAAmB,CAACjH,MAAM,CAAC;QAEhD,IAAI,CAACuB,aAAa,CAACC,gBAAS,CAAC+G,aAAa,EAAE;UACxCxC,WAAW,uBAAE,IAAI,CAACvU,QAAQ,CAAEsT,gBAAgB,sDAA/B,kBAAiC0D,MAAM,EAAE;UACtD,CAAClK,oCAAoB,GAAG,IAAI,CAACjE,yBAAyB,CAAC,IAAI;QAC/D,CAAC,CAAC;MACN;IACJ,CAAC,CAAC,OAAO7K,GAAG,EAAE;MACVyB,cAAM,CAACC,IAAI,CAAE,QAAO,IAAI,CAACE,MAAO,iCAAgC,EAAE5B,GAAG,CAAC;IAC1E;IAEA,MAAMiZ,cAAc,GAAG,IAAI,CAAC7E,aAAa,EAAE;IAC3C,IAAI0E,eAAe,KAAKG,cAAc,EAAE;MACpC,IAAI,CAAC9W,IAAI,CAAC/C,SAAS,CAAC8Z,eAAe,EAAED,cAAc,CAAC;MACpD;MACA,IAAI,CAAC9W,IAAI,CAAC/C,SAAS,CAAC+Z,UAAU,EAAEF,cAAc,CAAC;IACnD;EACJ;EAEQlK,6BAA6B,CAAChE,QAA2B,EAAQ;IACrE,IAAI,CAACU,uBAAuB,GAAG1E,KAAK,CAACqS,iBAAiB,CAAC,IAAI,CAAC3N,uBAAuB,IAAI,CAAC,CAAC,EAAEV,QAAQ,EAAE,IAAI,CAAC;IAC1G,KAAK,MAAMnH,IAAI,IAAI,IAAI,CAACC,cAAc,EAAE,EAAE;MAAA;MACtC,MAAMgG,QAAQ,GAAGjG,IAAI,CAACQ,MAAM,CAACM,EAAE;MAC/B,MAAMqG,QAAQ,GAAG,IAAI,CAACU,uBAAuB,CAAE5B,QAAQ,CAAC;MAExDjG,IAAI,CAACE,kBAAkB,CAACiH,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEG,WAAW,EAAEH,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEK,WAAW,CAAC;MACrExH,IAAI,CAAC7C,OAAO,gBAAG,IAAI,CAAC0K,uBAAuB,CAAE5B,QAAQ,CAAC,8CAAvC,UAAyC9I,OAAO;IACnE;EACJ;EAEOsY,kCAAkC,CAAC/X,KAAkB,EAAQ;IAChE,MAAMwQ,OAAO,GAAGxQ,KAAK,CAACoN,UAAU,EAAiC;IACjE,MAAM3D,QAAQ,GAAG+G,OAAO,CAAChD,oCAAoB,CAAC;IAC9C,IAAI,CAACC,6BAA6B,CAAChE,QAAQ,CAAC;EAChD;EAEA,MAAauO,0BAA0B,CAAChY,KAAkB,EAAiB;IACvE,MAAMwQ,OAAO,GAAGxQ,KAAK,CAACoN,UAAU,EAAyB;IACzD,IAAI,CAACoD,OAAO,CAACyH,iBAAiB,EAAE;IAEhC,IAAI,CAACtR,sBAAsB,GAAG;MAC1BvD,EAAE,EAAEoN,OAAO,CAACyH,iBAAiB,CAAC7U,EAAE;MAChC8U,WAAW,EAAE1H,OAAO,CAACyH,iBAAiB,CAACE;IAC3C,CAAC;IACD,IAAI,CAACtX,IAAI,CAAC/C,SAAS,CAACsa,uBAAuB,CAAC;EAChD;EAEO5X,YAAY,GAAY;IAC3B;IACA;IACA;IACA,OAAO,IAAI,CAACgB,KAAK,KAAK9D,SAAS,CAAC2Q,KAAK;EACzC;EAEQvK,kBAAkB,GAAS;IAC/B;IACA,IAAI,IAAI,CAAC+Q,oBAAoB,EAAE;MAC3B,IAAI,CAACA,oBAAoB,GAAG,IAAI,CAACA,oBAAoB,CAACC,IAAI,CAAC,MAAM,IAAI,CAACuD,oBAAoB,EAAE,CAAC;IACjG,CAAC,MAAM;MACH,IAAI,CAACxD,oBAAoB,GAAG,IAAI,CAACwD,oBAAoB,EAAE;IAC3D;EACJ;EAEA,MAAcA,oBAAoB,GAAkB;IAChD,IAAI,CAACf,WAAW,GAAG,IAAI;IACvB,IAAI;MACA,MAAM,IAAI,CAACgB,aAAa,EAAE;IAC9B,CAAC,CAAC,OAAOvK,CAAC,EAAE;MACR,IAAI,CAACwK,mBAAmB,CAACxK,CAAC,CAAU;MACpC;IACJ,CAAC,SAAS;MACN,IAAI,CAACuJ,WAAW,GAAG,KAAK;IAC5B;EACJ;EAEA,MAAcgB,aAAa,GAAkB;IACzCnY,cAAM,CAACE,KAAK,CAAE,QAAO,IAAI,CAACC,MAAO,4BAA2B,CAAC;IAE7D,IAAI,IAAI,CAACE,YAAY,EAAE,EAAE;MACrBL,cAAM,CAACE,KAAK,CAAC,0CAA0C,GAAG,IAAI,CAACC,MAAM,GAAG,6BAA6B,CAAC;MACtG;IACJ;IAEA,IAAIuN,KAAgC;IACpC,IAAI;MACA,IAAI,CAACqI,iBAAiB,EAAE;MACxBrI,KAAK,GAAG,MAAM,IAAI,CAACkI,WAAW,EAAE;IACpC,CAAC,CAAC,OAAOrX,GAAG,EAAE;MACVyB,cAAM,CAACE,KAAK,CAAE,QAAO,IAAI,CAACC,MAAO,2BAA0B,EAAE5B,GAAG,CAAC;MACjE,IAAI,CAACqC,SAAS,CAAClD,SAAS,CAACmD,KAAK,EAAEjD,aAAa,CAAC6F,WAAW,EAAE,IAAI,CAAC;MAChE;IACJ;IAEA,IAAI;MACA,MAAM,IAAI,CAAClD,QAAQ,CAAEyV,mBAAmB,CAACtI,KAAK,CAAC;IACnD,CAAC,CAAC,OAAOnP,GAAG,EAAE;MACVyB,cAAM,CAACE,KAAK,CAAE,QAAO,IAAI,CAACC,MAAO,mCAAkC,EAAE5B,GAAG,CAAC;MACzE,IAAI,CAACqC,SAAS,CAAClD,SAAS,CAACmD,KAAK,EAAEjD,aAAa,CAACuY,mBAAmB,EAAE,IAAI,CAAC;MACxE;IACJ;IAEA,IAAI,IAAI,CAAC5V,QAAQ,CAAEC,iBAAiB,KAAK,WAAW,EAAE;MAClD;MACA,MAAM,IAAIyV,OAAO,CAAEC,OAAO,IAAK;QAC3BjU,UAAU,CAACiU,OAAO,EAAE,GAAG,CAAC;MAC5B,CAAC,CAAC;IACN;IAEA,IAAI,IAAI,CAAC7V,YAAY,EAAE,EAAE;IAEzB,MAAMgY,SAAS,GAAG,IAAI,CAAChX,KAAK,KAAK9D,SAAS,CAACkG,WAAW,GAAG8M,gBAAS,CAAC+H,UAAU,GAAG/H,gBAAS,CAAC+G,aAAa;IAEvG,MAAMjH,OAAO,GAAG;MACZ/B,QAAQ,EAAEvQ;IACd,CAAyB;IAEzB,IAAIsa,SAAS,KAAK9H,gBAAS,CAAC+H,UAAU,IAAI,IAAI,CAAC7T,OAAO,EAAE;MACpD4L,OAAO,CAAC5L,OAAO,GAAG,IAAI,CAACA,OAAO;IAClC;;IAEA;IACA,IAAI,IAAI,CAACpD,KAAK,KAAK9D,SAAS,CAACkG,WAAW,EAAE;MAAA;MACtC4M,OAAO,CAAC3C,KAAK,yBAAG,IAAI,CAACnN,QAAQ,CAAEsT,gBAAgB,uDAA/B,mBAAiC0D,MAAM,EAAE;IAC7D,CAAC,MAAM;MAAA;MACHlH,OAAO,CAACyE,WAAW,yBAAG,IAAI,CAACvU,QAAQ,CAAEsT,gBAAgB,uDAA/B,mBAAiC0D,MAAM,EAAE;IACnE;IAEAlH,OAAO,CAACyD,YAAY,GAAG;MACnB,mBAAmB,EAAE,IAAI,CAACpP,MAAM,CAACqP,oBAAoB;MACrD,aAAa,EAAE;IACnB,CAAC;IAED1D,OAAO,CAAChD,oCAAoB,CAAC,GAAG,IAAI,CAACjE,yBAAyB,CAAC,IAAI,CAAC;;IAEpE;IACA;IACA,MAAM4K,YAAY,GAAG,IAAI,CAACC,0BAA0B,EAAE;IACtDjU,cAAM,CAAC8B,IAAI,CAAE,QAAO,IAAI,CAAC3B,MAAO,eAAc6T,YAAa,wCAAuC,CAAC;IAEnG,IAAI;MACA,MAAM,IAAI,CAAC1D,aAAa,CAAC+H,SAAS,EAAEhI,OAAO,CAAC;IAChD,CAAC,CAAC,OAAO5P,KAAK,EAAE;MACZT,cAAM,CAACS,KAAK,CAAE,QAAO,IAAI,CAACN,MAAO,wBAAuB,EAAEM,KAAK,CAAC;MAChE,IAAIA,KAAK,YAAY0T,oBAAW,IAAI1T,KAAK,CAACZ,KAAK,EAAE,IAAI,CAAC6E,MAAM,CAAC0P,kBAAkB,CAAC3T,KAAK,CAACZ,KAAK,CAAC;MAE5F,IAAIxB,IAAI,GAAGT,aAAa,CAAC2a,gBAAgB;MACzC,IAAIjE,OAAO,GAAG,mBAAmB;MACjC,IAAI,IAAI,CAACjT,KAAK,KAAK9D,SAAS,CAACkG,WAAW,EAAE;QACtCpF,IAAI,GAAGT,aAAa,CAAC4a,UAAU;QAC/BlE,OAAO,GAAG,uBAAuB;MACrC;MACA,IAAY7T,KAAK,CAAE8T,IAAI,IAAI,oBAAoB,EAAE;QAC7ClW,IAAI,GAAGT,aAAa,CAAC4W,cAAc;QACnCF,OAAO,GAAG,qCAAqC;MACnD;MAEA,IAAI,CAAC5T,IAAI,CAAC/C,SAAS,CAACQ,KAAK,EAAE,IAAID,SAAS,CAACG,IAAI,EAAEiW,OAAO,EAAS7T,KAAK,CAAC,CAAC;MACtE,IAAI,CAACG,SAAS,CAAClD,SAAS,CAACmD,KAAK,EAAExC,IAAI,EAAE,KAAK,CAAC;;MAE5C;MACA;MACA;IACJ;IAEA,IAAI,CAACoW,kBAAkB,EAAE;IACzB,IAAI,IAAI,CAACpT,KAAK,KAAK9D,SAAS,CAACkG,WAAW,EAAE;MACtC,IAAI,CAACyL,kBAAkB,GAAG,IAAI;MAC9B,IAAI,CAAC7N,KAAK,GAAG9D,SAAS,CAAC6G,UAAU;MACjC,IAAI,CAACqU,aAAa,GAAGxW,UAAU,CAAC,MAAM;QAClC,IAAI,CAACwW,aAAa,GAAGrZ,SAAS;QAC9B,IAAI,IAAI,CAACiC,KAAK,KAAK9D,SAAS,CAAC6G,UAAU,EAAE;UACrC,IAAI,CAACrC,MAAM,CAACnE,aAAa,CAAC8a,aAAa,EAAE,KAAK,CAAC;QACnD;MACJ,CAAC,EAAE3a,eAAe,CAAC;IACvB;EACJ;EA8GA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACYgY,iBAAiB,GAAS;IAC9B;IACA,IAAI,CAAC4C,cAAc,CAACC,eAAe,IAAI,CAACC,YAAY,CAACD,eAAe,EAAE;IAEtE,MAAME,UAAU,GAAGH,cAAc,CAACC,eAAe,CAAC,OAAO,CAAC,CAAEG,MAAM;IAClE,MAAMC,UAAU,GAAGH,YAAY,CAACD,eAAe,CAAC,OAAO,CAAC,CAAEG,MAAM;IAChE,MAAMA,MAAM,GAAG,CAAC,GAAGC,UAAU,EAAE,GAAGF,UAAU,CAAC;IAE7C,KAAK,MAAM7Z,KAAK,IAAI8Z,MAAM,EAAE;MACxB,IAAI9Z,KAAK,CAACga,QAAQ,KAAK,WAAW,EAAE;QAChC,MAAMC,aAAa,GAAGH,MAAM,CAACzM,OAAO,CAACrN,KAAK,CAAC;QAC3C8Z,MAAM,CAAC1M,MAAM,CAAC6M,aAAa,EAAE,CAAC,CAAC;MACnC;IACJ;IAEA,MAAMC,2BAA2B,GAAG,IAAI,CAACnO,YAAY,CAACE,GAAG,CACrD7L,iBAAiB,CAAC+H,wCAAwB,CAACS,WAAW,EAAE,OAAO,CAAC,CACnE;IACD,IAAIsR,2BAA2B,EAAEA,2BAA2B,CAACC,mBAAmB,CAACL,MAAM,CAAC;EAC5F;EAwDA;AACJ;AACA;EACI,MAAczI,aAAa,CAAC+H,SAAiB,EAAEhI,OAAe,EAAiB;IAC3E,MAAMgJ,WAAW,GAAGC,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAElJ,OAAO,EAAE;MAC3CkG,OAAO,EAAE1Y,kBAAkB;MAC3B2b,OAAO,EAAE,IAAI,CAACrZ,MAAM;MACpB8D,QAAQ,EAAE,IAAI,CAACY,UAAU;MACzB4U,OAAO,EAAE,IAAI,CAACzU;IAClB,CAAC,CAAC;IAEF,IAAI,IAAI,CAACF,gBAAgB,EAAE;MAAA;MACvB,MAAM4U,WAAW,GAAG,IAAI,CAACA,WAAW,EAAE;MACtC,MAAMrJ,OAAO,mCACNgJ,WAAW;QACdM,SAAS,EAAE,IAAI,CAACjV,MAAM,CAACC,QAAQ;QAC/BiV,iBAAiB,EAAE,IAAI,CAAClV,MAAM,CAACmV,YAAY,EAAE;QAC7CC,eAAe,EAAE,IAAI,CAAC/U,iBAAiB;QACvCgV,GAAG,EAAEL,WAAW;QAChB,CAACM,wBAAiB,GAAG,IAAAC,QAAM;MAAE,EAChC;MAED,IAAI,CAACvZ,IAAI,CAAC/C,SAAS,CAACuc,aAAa,EAAE;QAC/BtT,IAAI,EAAE,UAAU;QAChByR,SAAS;QACTtP,MAAM,EAAE,IAAI,CAACtE,OAAO,+BAAI,IAAI,CAACsB,iBAAiB,EAAE,2DAAxB,uBAA0BgD,MAAM;QACxDjE,gBAAgB,EAAE,IAAI,CAACA,gBAAgB;QACvCuL;MACJ,CAAC,CAAC;MAEF,MAAMtH,MAAM,GAAG,IAAI,CAACtE,OAAO,IAAI,IAAI,CAACsB,iBAAiB,EAAE,CAAEgD,MAAM;MAC/D,IAAI,IAAI,CAACrE,MAAM,CAACgE,qBAAqB,EAAE,EAAE;QACrC,MAAM,IAAI,CAAChE,MAAM,CAACyV,uBAAuB,CACrC,CACI;UACIpR,MAAM;UACNqR,UAAU,EAAE,IAAI,CAACxR;QACrB,CAAC,CACJ,EACD;UACIhC,IAAI,EAAEyR,SAAS;UACfhI;QACJ,CAAC,CACJ;MACL,CAAC,MAAM;QACH,MAAM,IAAI,CAAC3L,MAAM,CAAC2V,YAAY,CAAChC,SAAS,EAAE;UACtC,CAACtP,MAAM,GAAG;YACN,CAAC,IAAI,CAACjE,gBAAgB,GAAGuL;UAC7B;QACJ,CAAC,CAAC;MACN;IACJ,CAAC,MAAM;MAAA;MACH,IAAI,CAAC3P,IAAI,CAAC/C,SAAS,CAACuc,aAAa,EAAE;QAC/BtT,IAAI,EAAE,WAAW;QACjByR,SAAS;QACT7T,MAAM,EAAE,IAAI,CAACA,MAAM;QACnB6L,OAAO,EAAEgJ,WAAW;QACpBtQ,MAAM,EAAE,IAAI,CAACtE,OAAO,+BAAI,IAAI,CAACsB,iBAAiB,EAAE,2DAAxB,uBAA0BgD,MAAM;MAC5D,CAAC,CAAC;MAEF,MAAM,IAAI,CAACrE,MAAM,CAAC4V,SAAS,CAAC,IAAI,CAAC9V,MAAM,EAAG6T,SAAS,EAAEgB,WAAW,CAAC;IACrE;EACJ;;EAEA;AACJ;AACA;AACA;AACA;EACY/Y,cAAc,CAAC+P,OAA+B,EAAQ;IAC1D;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA,IAAIA,OAAO,EAAE;MACT,IAAI,CAACkK,kBAAkB,CAACpV,IAAI,CAACkL,OAAO,CAAC;IACzC,CAAC,MAAM;MACH,IAAI,CAACtQ,eAAe,GAAG,IAAI;IAC/B;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,IAAI,CAACsB,KAAK,KAAK9D,SAAS,CAACsG,OAAO,IAAI,CAAC,IAAI,CAACqL,kBAAkB,EAAE;;IAElE;IACA;IACA,MAAMsL,KAAK,GAAG,IAAI,CAACnW,SAAS,KAAK5G,aAAa,CAAC6G,OAAO,GAAG,GAAG,GAAG,IAAI;IAEnE,IAAI,IAAI,CAACmW,kBAAkB,KAAK,CAAC,EAAE;MAC/BxY,UAAU,CAAC,MAAM;QACb,IAAI,CAACwS,kBAAkB,EAAE;MAC7B,CAAC,EAAE+F,KAAK,CAAC;IACb;EACJ;;EAEA;EACA;EACA;EACQvG,0BAA0B,GAAW;IACzC,IAAID,YAAY,GAAG,CAAC;IACpB,MAAM0G,QAA2B,GAAG,EAAE;IAEtC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACJ,kBAAkB,CAAC9X,MAAM,EAAEkY,CAAC,EAAE,EAAE;MACrD,MAAM7a,SAAS,GAAG,IAAI,CAACya,kBAAkB,CAACI,CAAC,CAAC;MAC5C,IAAI7a,SAAS,CAACA,SAAS,KAAK,EAAE,EAAE;QAC5B4a,QAAQ,CAACvV,IAAI,CAACrF,SAAS,CAAC;MAC5B,CAAC,MAAM;QACHkU,YAAY,EAAE;MAClB;IACJ;IAEA,IAAI,CAACuG,kBAAkB,GAAGG,QAAQ;IAElC,OAAO1G,YAAY;EACvB;;EAEA;AACJ;AACA;EACI,MAAa4G,QAAQ,CAACC,YAAoB,EAAiB;IACvD;IACA;IACA,MAAMC,WAAW,GAAG,MAAM,IAAI,CAACpW,MAAM,CAACqW,cAAc,CAACF,YAAY,CAAC;IAElE,MAAMG,aAAa,GAAGxc,SAAS,EAAE;IAEjC,MAAMyc,IAAI,GAAG;MACTC,cAAc,EAAE1c,SAAS,EAAE;MAC3B2c,WAAW,EAAE;QACTlY,EAAE,EAAE4X,YAAY;QAChB7C,YAAY,EAAE8C,WAAW,CAACM,WAAW;QACrCC,UAAU,EAAEP,WAAW,CAACO;MAC5B,CAAC;MACDC,WAAW,EAAEN;IACjB,CAAuB;IAEvB,MAAM,IAAI,CAAC1K,aAAa,CAACC,gBAAS,CAACgL,YAAY,EAAEN,IAAI,CAAC;IAEtD,MAAM,IAAI,CAACra,SAAS,CAAClD,SAAS,CAACmD,KAAK,EAAEjD,aAAa,CAAC4d,UAAU,EAAE,IAAI,CAAC;EACzE;;EAEA;AACJ;AACA;AACA;EACI,MAAaC,cAAc,CAACC,kBAA8B,EAAiB;IAAA;IACvE,MAAMb,YAAY,4BAAGa,kBAAkB,CAAC3V,iBAAiB,EAAE,0DAAtC,sBAAwCgD,MAAM;IACnE,MAAM4S,iBAAiB,GAAGd,YAAY,GAAG,MAAM,IAAI,CAACnW,MAAM,CAACqW,cAAc,CAACF,YAAY,CAAC,GAAGzb,SAAS;IACnG,MAAMwc,cAAc,6BAAG,IAAI,CAAC7V,iBAAiB,EAAE,2DAAxB,uBAA0BgD,MAAM;IACvD,MAAM8S,qBAAqB,GAAGD,cAAc,GAAG,MAAM,IAAI,CAAClX,MAAM,CAACqW,cAAc,CAACa,cAAc,CAAC,GAAGxc,SAAS;IAE3G,MAAM0c,SAAS,GAAGtd,SAAS,EAAE;IAE7B,MAAMud,oBAAoB,GAAG;MACzB;MACA;MACAb,cAAc,EAAE1c,SAAS,EAAE;MAC3B2c,WAAW,EAAE;QACTlY,EAAE,EAAE2Y,cAAc;QAClB5D,YAAY,EAAE6D,qBAAqB,aAArBA,qBAAqB,uBAArBA,qBAAqB,CAAET,WAAW;QAChDC,UAAU,EAAEQ,qBAAqB,aAArBA,qBAAqB,uBAArBA,qBAAqB,CAAER;MACvC,CAAC;MACDW,UAAU,EAAEF;IAChB,CAAuB;IAEvB,MAAMJ,kBAAkB,CAACpL,aAAa,CAACC,gBAAS,CAACgL,YAAY,EAAEQ,oBAAoB,CAAC;IAEpF,MAAME,gBAAgB,GAAG;MACrBf,cAAc,EAAE1c,SAAS,EAAE;MAC3B2c,WAAW,EAAE;QACTlY,EAAE,EAAE4X,YAAY;QAChB7C,YAAY,EAAE2D,iBAAiB,aAAjBA,iBAAiB,uBAAjBA,iBAAiB,CAAEP,WAAW;QAC5CC,UAAU,EAAEM,iBAAiB,aAAjBA,iBAAiB,uBAAjBA,iBAAiB,CAAEN;MACnC,CAAC;MACDC,WAAW,EAAEQ;IACjB,CAAuB;IAEvB,MAAM,IAAI,CAACxL,aAAa,CAACC,gBAAS,CAACgL,YAAY,EAAEU,gBAAgB,CAAC;IAElE,MAAM,IAAI,CAACrb,SAAS,CAAClD,SAAS,CAACmD,KAAK,EAAEjD,aAAa,CAAC4d,UAAU,EAAE,IAAI,CAAC;IACrE,MAAME,kBAAkB,CAAC9a,SAAS,CAAClD,SAAS,CAACmD,KAAK,EAAEjD,aAAa,CAAC4d,UAAU,EAAE,IAAI,CAAC;EACvF;EAEA,MAAc5a,SAAS,CAACqN,WAAsB,EAAEiO,YAA2B,EAAEC,UAAmB,EAAiB;IAC7G,IAAI,IAAI,CAAC9b,YAAY,EAAE,EAAE;IAEzB,IAAI,CAAC4N,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACiO,YAAY,GAAGA,YAAY;IAChC,IAAI,CAAC7a,KAAK,GAAG9D,SAAS,CAAC2Q,KAAK;IAE5B,IAAI,IAAI,CAACuK,aAAa,EAAE;MACpBtX,YAAY,CAAC,IAAI,CAACsX,aAAa,CAAC;MAChC,IAAI,CAACA,aAAa,GAAGrZ,SAAS;IAClC;IACA,IAAI,IAAI,CAACmC,kBAAkB,EAAE;MACzB6a,aAAa,CAAC,IAAI,CAAC7a,kBAAkB,CAAC;MACtC,IAAI,CAACA,kBAAkB,GAAGnC,SAAS;IACvC;IAEA,KAAK,MAAM,CAACuD,MAAM,EAAE0Z,QAAQ,CAAC,IAAI,IAAI,CAACxZ,oBAAoB,EAAE;MACxDF,MAAM,CAACQ,mBAAmB,CAAC,aAAa,EAAEkZ,QAAQ,CAAC;IACvD;IACA,IAAI,CAACxZ,oBAAoB,CAACyZ,KAAK,EAAE;IAEjC,IAAI,CAAC9P,cAAc,GAAG,MAAM,IAAI,CAACC,gBAAgB,EAAE;;IAEnD;IACA,IAAI,CAAC0B,YAAY,EAAE;IACnB,IAAI,CAAChC,cAAc,EAAE;IAErB,IAAI,IAAI,CAAC5L,QAAQ,IAAI,IAAI,CAACA,QAAQ,CAAC+B,cAAc,KAAK,QAAQ,EAAE;MAC5D,IAAI,CAAC/B,QAAQ,CAAC6N,KAAK,EAAE;IACzB;IACA,IAAI+N,UAAU,EAAE;MACZ,IAAI,CAACzb,IAAI,CAAC/C,SAAS,CAAC0Q,MAAM,EAAE,IAAI,CAAC;IACrC;IAEA,IAAI,CAAC3J,MAAM,CAAC6X,gBAAgB,CAAEC,KAAK,CAACpZ,MAAM,CAAC,IAAI,CAACjD,MAAM,CAAC;EAC3D;EAEQgO,YAAY,GAAS;IACzBnO,cAAM,CAACE,KAAK,CAAE,QAAO,IAAI,CAACC,MAAO,qBAAoB,CAAC;IAEtD,KAAK,MAAMgC,IAAI,IAAI,IAAI,CAACmG,KAAK,EAAE;MAC3B;MACA;MACA;MACA;MACA;MACA;MACA,IAAInG,IAAI,CAACqG,OAAO,EAAE,IAAIrG,IAAI,CAAC7C,OAAO,KAAK8H,wCAAwB,CAACC,SAAS,EAAE;QACvE,IAAI,CAAC3C,MAAM,CAACsH,eAAe,EAAE,CAACyQ,mBAAmB,CAACta,IAAI,CAACQ,MAAM,CAAC;MAClE,CAAC,MAAM,IAAIR,IAAI,CAACqG,OAAO,EAAE,IAAIrG,IAAI,CAAC7C,OAAO,KAAK8H,wCAAwB,CAACS,WAAW,EAAE;QAChF,IAAI,CAACnD,MAAM,CAACsH,eAAe,EAAE,CAACC,uBAAuB,CAAC9J,IAAI,CAACQ,MAAM,CAAC;MACtE,CAAC,MAAM,IAAI,CAACR,IAAI,CAACqG,OAAO,EAAE,EAAE;QACxBxI,cAAM,CAACE,KAAK,CAAC,wBAAwB,EAAEiC,IAAI,CAACQ,MAAM,CAACM,EAAE,CAAC;QACtD,KAAK,MAAMP,KAAK,IAAIP,IAAI,CAACQ,MAAM,CAACK,SAAS,EAAE,EAAE;UACzCN,KAAK,CAACiP,IAAI,EAAE;QAChB;MACJ;IACJ;EACJ;EAEQ+K,qBAAqB,GAAS;IAClC,IAAI,IAAI,CAACC,SAAS,CAACC,qCAAkB,CAACze,KAAK,CAAC,CAACsE,MAAM,KAAK,CAAC,EAAE;MACvD,MAAM,IAAItE,KAAK,CAAC,yEAAyE,CAAC;IAC9F;EACJ;EAEA,MAAcsW,kBAAkB,GAAkB;IAC9C,IAAI,IAAI,CAAC8F,kBAAkB,CAAC9X,MAAM,KAAK,CAAC,IAAI,IAAI,CAACpC,YAAY,EAAE,EAAE;MAC7D;IACJ;IAEA,MAAMgW,UAAU,GAAG,IAAI,CAACkE,kBAAkB;IAC1C,IAAI,CAACA,kBAAkB,GAAG,EAAE;IAC5B,EAAE,IAAI,CAACE,kBAAkB;IACzB,MAAMpK,OAAO,GAAG;MAAEgG,UAAU,EAAEA,UAAU,CAACpG,GAAG,CAAEnQ,SAAS,IAAKA,SAAS,CAACyX,MAAM,EAAE;IAAE,CAAC;IACjF,IAAI,IAAI,CAACxX,eAAe,EAAE;MACtB;MACAsQ,OAAO,CAACgG,UAAU,CAAClR,IAAI,CAAC;QACpBrF,SAAS,EAAE;MACf,CAAC,CAAC;IACN;IACAE,cAAM,CAACE,KAAK,CAAE,QAAO,IAAI,CAACC,MAAO,uBAAsBkW,UAAU,CAAC5T,MAAO,aAAY,CAAC;IACtF,IAAI;MACA,MAAM,IAAI,CAAC6N,aAAa,CAACC,gBAAS,CAACsM,cAAc,EAAExM,OAAO,CAAC;MAC3D;MACA;MACA,IAAI,CAACoK,kBAAkB,GAAG,CAAC;;MAE3B;MACA,IAAI,CAAChG,kBAAkB,EAAE;IAC7B,CAAC,CAAC,OAAOhU,KAAK,EAAE;MACZ;MACA;MACA,IAAIA,KAAK,YAAY0T,oBAAW,IAAI1T,KAAK,CAACZ,KAAK,EAAE,IAAI,CAAC6E,MAAM,CAAC0P,kBAAkB,CAAC3T,KAAK,CAACZ,KAAK,CAAC;;MAE5F;MACA,IAAI,CAAC0a,kBAAkB,CAACpV,IAAI,CAAC,GAAGkR,UAAU,CAAC;MAE3C,IAAI,IAAI,CAACoE,kBAAkB,GAAG,CAAC,EAAE;QAC7Bza,cAAM,CAACE,KAAK,CACP,QAAO,IAAI,CAACC,MAAO,yCAAwC,IAAI,CAACsa,kBAAmB,2BAA0B,EAC9Gha,KAAK,CACR;QAED,MAAMpC,IAAI,GAAGT,aAAa,CAAC2a,gBAAgB;QAC3C,MAAMjE,OAAO,GAAG,mBAAmB;QAEnC,IAAI,CAAC5T,IAAI,CAAC/C,SAAS,CAACQ,KAAK,EAAE,IAAID,SAAS,CAACG,IAAI,EAAEiW,OAAO,EAAS7T,KAAK,CAAC,CAAC;QACtE,IAAI,CAACsB,MAAM,CAAC1D,IAAI,EAAE,KAAK,CAAC;QAExB;MACJ;MAEA,MAAMye,OAAO,GAAG,GAAG,GAAGnb,IAAI,CAACob,GAAG,CAAC,CAAC,EAAE,IAAI,CAACtC,kBAAkB,CAAC;MAC1D,EAAE,IAAI,CAACA,kBAAkB;MACzBza,cAAM,CAACE,KAAK,CAAE,QAAO,IAAI,CAACC,MAAO,2CAA0C2c,OAAQ,IAAG,EAAErc,KAAK,CAAC;MAC9FwB,UAAU,CAAC,MAAM;QACb,IAAI,CAACwS,kBAAkB,EAAE;MAC7B,CAAC,EAAEqI,OAAO,CAAC;IACf;EACJ;;EAEA;AACJ;AACA;AACA;AACA;EACI,MAAarX,SAAS,CAACuJ,KAAc,EAAEC,KAAc,EAAiB;IAClE,IAAI,CAACD,KAAK,EAAE;MACR,MAAM,IAAI7Q,KAAK,CAAC,uCAAuC,CAAC;IAC5D;IACA,IAAI,CAACkD,KAAK,GAAG9D,SAAS,CAACgS,cAAc;IAErC,IAAI;MAAA;MACA,MAAM5M,MAAM,GAAG,MAAM,IAAI,CAAC+B,MAAM,CAACsH,eAAe,EAAE,CAACwD,kBAAkB,CAACR,KAAK,EAAEC,KAAK,CAAC;;MAEnF;MACA;MACAtE,gBAAgB,CAAChI,MAAM,CAAC4E,cAAc,EAAE,EAAE,IAAI,CAAC;MAC/CoD,gBAAgB,CAAChI,MAAM,CAACuE,cAAc,EAAE,EAAE,IAAI,CAAC;MAE/C,MAAM2D,QAAQ,GAAG,IAAIV,kBAAQ,CAAC;QAC1BzF,MAAM,EAAE,IAAI,CAACA,MAAM;QACnBF,MAAM,EAAE,IAAI,CAACA,MAAM;QACnBuE,MAAM,EAAE,IAAI,CAACrE,MAAM,CAACgG,SAAS,EAAG;QAChC/F,QAAQ,4BAAE,IAAI,CAACD,MAAM,CAACgL,WAAW,EAAE,2EAAItQ,SAAS;QAChDuD,MAAM;QACNrD,OAAO,EAAE8H,wCAAwB,CAACC,SAAS;QAC3C4C,UAAU,EAAE,KAAK;QACjBC,UAAU,EAAE;MAChB,CAAC,CAAC;MACF,MAAM,IAAI,CAAC8S,sBAAsB,CAAC,CAACnS,QAAQ,CAAC,CAAC;IACjD,CAAC,CAAC,OAAO+C,CAAC,EAAE;MACR,IAAI,CAAC7M,kBAAkB,CAAQ6M,CAAC,CAAC;MACjC;IACJ;EACJ;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACI,MAAaoP,sBAAsB,CAACpN,SAAqB,EAAE4D,sBAAsB,GAAG,KAAK,EAAiB;IACtG,IAAI,CAACkJ,qBAAqB,EAAE;IAC5B,IAAI,CAACrY,SAAS,GAAG5G,aAAa,CAACuS,QAAQ;IAEvC,MAAM,IAAI,CAACvH,kBAAkB,EAAE;;IAE/B;IACA,IAAI,CAAC/D,MAAM,CAAC6X,gBAAgB,CAAEC,KAAK,CAAClZ,GAAG,CAAC,IAAI,CAACnD,MAAM,EAAE,IAAI,CAAC;;IAE1D;IACA;IACA,MAAM+M,aAAa,GAAG,MAAM,IAAI,CAACxI,MAAM,CAACyI,gBAAgB,EAAE;IAC1D,IAAI,CAACD,aAAa,EAAE;MAChBlN,cAAM,CAACC,IAAI,CAAE,QAAO,IAAI,CAACE,MAAO,iEAAgE,CAAC;IACrG;;IAEA;IACA;IACA,IAAI,CAACI,QAAQ,GAAG,IAAI,CAACgN,oBAAoB,EAAE;IAC3C,IAAI,CAACgG,qBAAqB,CAAC3D,SAAS,EAAE4D,sBAAsB,CAAC;EACjE;EAEQjG,oBAAoB,GAAsB;IAC9C,MAAM0P,EAAE,GAAG,IAAIC,MAAM,CAACC,iBAAiB,CAAC;MACpCC,kBAAkB,EAAE,IAAI,CAACxY,SAAS,GAAG,OAAO,GAAGxF,SAAS;MACxDie,UAAU,EAAE,IAAI,CAACpY,WAAW;MAC5BqY,oBAAoB,EAAE,IAAI,CAAC5Y,MAAM,CAAC4Y,oBAAoB;MACtDC,YAAY,EAAE;IAClB,CAAC,CAAC;;IAEF;IACAN,EAAE,CAAC5Z,gBAAgB,CAAC,0BAA0B,EAAE,IAAI,CAACma,2BAA2B,CAAC;IACjFP,EAAE,CAAC5Z,gBAAgB,CAAC,sBAAsB,EAAE,IAAI,CAACoa,wBAAwB,CAAC;IAC1ER,EAAE,CAAC5Z,gBAAgB,CAAC,cAAc,EAAE,IAAI,CAACqa,oBAAoB,CAAC;IAC9DT,EAAE,CAAC5Z,gBAAgB,CAAC,yBAAyB,EAAE,IAAI,CAACsa,yBAAyB,CAAC;IAC9EV,EAAE,CAAC5Z,gBAAgB,CAAC,OAAO,EAAE,IAAI,CAACua,OAAO,CAAC;IAC1CX,EAAE,CAAC5Z,gBAAgB,CAAC,mBAAmB,EAAE,IAAI,CAACwa,mBAAmB,CAAC;IAClEZ,EAAE,CAAC5Z,gBAAgB,CAAC,aAAa,EAAE,IAAI,CAACya,aAAa,CAAC;IAEtD,OAAOb,EAAE;EACb;EAEQrZ,cAAc,CAACtF,GAAc,EAAW;IAC5C;IACA;IACA;IACA;IACA,MAAMyf,UAAU,GAAGzf,GAAG,CAACiY,OAAO,KAAK,CAAC,GAAG,IAAI,GAAGjY,GAAG,CAAC2F,QAAQ,IAAI,IAAI;IAClE,OAAO8Z,UAAU,KAAK,IAAI,CAAC7Z,eAAe;EAC9C;;EAEA;EACA;EACQsJ,cAAc,CAACjL,EAAe,EAAQ;IAAA;IAC1C;IACA,MAAMjE,GAAG,GAAGiE,EAAE,CAAC0K,UAAU,EAAsC;IAE/DjN,cAAM,CAACE,KAAK,CAAE,QAAO,IAAI,CAACC,MAAO,+BAA8B7B,GAAG,CAAC2F,QAAS,EAAC,CAAC;IAE9E,IAAI,CAACP,eAAe,GAAGpF,GAAG,CAACiY,OAAO;IAClC,IAAI,IAAI,CAAC7S,eAAe,KAAK,CAAC,EAAE;MAC5B;MACA;MACA,IAAI,CAACQ,eAAe,GAAG,IAAI;IAC/B,CAAC,MAAM;MACH;MACA;MACA;MACA,IAAI,CAACA,eAAe,GAAG5F,GAAG,CAAC2F,QAAQ,IAAI,IAAI;IAC/C;IACA,IAAI,CAACoC,YAAY,GAAG/H,GAAG,CAACwV,YAAY,IAAK,CAAC,CAAsB;IAChE,IAAI,CAAC9N,cAAc,iBAAG,IAAI,CAACtB,MAAM,CAACsZ,OAAO,CAAC,IAAI,CAACxZ,MAAM,CAAC,CAAEyZ,SAAS,CAAC1b,EAAE,CAAC2b,SAAS,EAAE,CAAE,mDAAI9e,SAAS;EACnG;EAEA,MAAcuO,wBAAwB,GAAkB;IACpD,MAAM6I,kBAAkB,GAAG,IAAI,CAACC,qBAAqB,CAACvL,GAAG,CAAC,IAAI,CAAChH,eAAe,CAAE;IAChF,IAAIsS,kBAAkB,EAAE;MACpBxW,cAAM,CAAC8B,IAAI,CACN,QAAO,IAAI,CAAC3B,MAAO,WAAUqW,kBAAkB,CAAC/T,MAAO,qCAAoC,IAAI,CAACyB,eAAgB,EAAC,CACrH;MACD,MAAM,IAAI,CAACwS,gBAAgB,CAACF,kBAAkB,CAAC;IACnD;IACA,IAAI,CAACC,qBAAqB,CAAC6F,KAAK,EAAE;EACtC;EAEA,MAAc5F,gBAAgB,CAACL,UAA6B,EAAiB;IACzE,KAAK,MAAMvW,SAAS,IAAIuW,UAAU,EAAE;MAChC,IACI,CAACvW,SAAS,CAACM,MAAM,KAAK,IAAI,IAAIN,SAAS,CAACM,MAAM,KAAKhB,SAAS,MAC3DU,SAAS,CAACqe,aAAa,KAAK,IAAI,IAAIre,SAAS,CAACqe,aAAa,KAAK/e,SAAS,CAAC,EAC7E;QACEY,cAAM,CAACE,KAAK,CAAE,QAAO,IAAI,CAACC,MAAO,mCAAkC,CAAC;MACxE,CAAC,MAAM;QACHH,cAAM,CAACE,KAAK,CACP,QAAO,IAAI,CAACC,MAAO,mBAAkBL,SAAS,CAACM,MAAO,eAAcN,SAAS,CAACA,SAAU,EAAC,CAC7F;MACL;MAEA,IAAI;QACA,MAAM,IAAI,CAACS,QAAQ,CAAE6d,eAAe,CAACte,SAAS,CAAC;MACnD,CAAC,CAAC,OAAOvB,GAAG,EAAE;QACV,IAAI,CAAC,IAAI,CAAC6Y,WAAW,EAAE;UACnBpX,cAAM,CAAC8B,IAAI,CAAE,QAAO,IAAI,CAAC3B,MAAO,qCAAoC,EAAE5B,GAAG,CAAC;QAC9E;MACJ;IACJ;EACJ;EAEA,IAAW8f,iBAAiB,GAAY;IACpC,OAAOjY,OAAO,CAAC,IAAI,CAAC7F,QAAQ,CAAC;EACjC;AACJ;AAAC;AAEM,SAASoK,gBAAgB,CAAC2T,MAA+B,EAAExT,OAAgB,EAAQ;EACtF,KAAK,MAAMpI,KAAK,IAAI4b,MAAM,EAAE;IACxB5b,KAAK,CAACoI,OAAO,GAAGA,OAAO;EAC3B;AACJ;AAEO,SAASyT,kBAAkB,GAAY;EAC1C;EACA,IAAI,OAAOrB,MAAM,KAAK,WAAW,IAAI,OAAOsB,QAAQ,KAAK,WAAW,EAAE;IAClE;IACA;IACA,OAAO,KAAK;EAChB;;EAEA;EACA;EACA;EACA,IAAI;IACA,MAAMC,SAAS,GAAGrY,OAAO,CACrB8W,MAAM,CAACC,iBAAiB,IACpBD,MAAM,CAACwB,qBAAqB,IAC5BxB,MAAM,CAACyB,eAAe,IACtBC,SAAS,CAACC,YAAY,CAC7B;IACD,IAAI,CAACJ,SAAS,EAAE;MACZ,yBAAyB;MACzB,IAAIK,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,MAAM,EAAE;QACjChf,cAAM,CAACS,KAAK,CAAC,uDAAuD,CAAC;MACzE;MACA,OAAO,KAAK;IAChB;EACJ,CAAC,CAAC,OAAOmN,CAAC,EAAE;IACR5N,cAAM,CAACS,KAAK,CAAC,+CAA+C,EAAEmN,CAAC,CAAC;IAChE,OAAO,KAAK;EAChB;EAEA,OAAO,IAAI;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASqR,mBAAmB,CAC/Bva,MAAoB,EACpBF,MAAc,EACdqB,OAA4G,EAC3F;EACjB,IAAI,CAAC0Y,kBAAkB,EAAE,EAAE,OAAO,IAAI;EAEtC,MAAMW,gBAAgB,GAAGrZ,OAAO,GAAGA,OAAO,CAACjB,SAAS,GAAG,KAAK;EAE5D,MAAMlF,IAAc,GAAG;IACnBgF,MAAM,EAAEA,MAAM;IACdF,MAAM,EAAEA,MAAM;IACdC,OAAO,EAAEoB,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEpB,OAAO;IACzBQ,WAAW,EAAEP,MAAM,CAACya,cAAc,EAAE;IACpC;IACAva,SAAS,EAAEF,MAAM,CAACE,SAAS,IAAIsa,gBAAgB;IAC/Cpa,gBAAgB,EAAEe,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEf,gBAAgB;IAC3CC,iBAAiB,EAAEc,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEd,iBAAiB;IAC7CC,WAAW,EAAEa,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEb;EAC1B,CAAC;EACD,MAAMoF,IAAI,GAAG,IAAI5K,UAAU,CAACE,IAAI,CAAC;EAEjCgF,MAAM,CAAC0a,SAAS,CAACC,MAAM,CAACjV,IAAI,EAAEkP,MAAM,CAACgG,MAAM,CAAC3hB,SAAS,CAAC,CAAC;EAEvD,OAAOyM,IAAI;AACf"}