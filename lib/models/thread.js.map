{"version":3,"file":"thread.js","names":["ThreadEvent","FeatureSupport","determineFeatureSupport","stable","unstable","Stable","Experimental","None","Thread","ReadReceipt","constructor","id","rootEvent","opts","hasServerSideSupport","event","redaction","isRelation","THREAD_RELATION_TYPE","name","room","eventShouldLiveIn","threadId","getId","status","replyCount","updatePendingReplyCount","emit","Update","threadRootId","threadEvent","timeline","clearEventMetadata","lastEvent","_currentUserParticipated","Delete","updateThreadMetadata","toStartOfTimeline","addLocalEchoReceipt","getSender","ReceiptType","Read","onEcho","NewReply","Error","client","pendingEventOrdering","PendingEventOrdering","Chronological","timelineSet","EventTimelineSet","timelineSupport","pendingEvents","reEmitter","TypedReEmitter","reEmit","RoomEvent","Timeline","TimelineReset","on","MatrixEventEvent","BeforeRedaction","onBeforeRedaction","Redaction","onRedaction","LocalEchoUpdated","onLocalEcho","onTimelineEvent","processReceipts","receipts","setEventMetadata","fetchRootEvent","findEventById","eventData","fetchRoomEvent","roomId","mapper","getEventMapper","e","logger","error","processEvent","setServerSideSupport","FILTER_RELATED_BY_SENDERS","setPreferUnstable","FILTER_RELATED_BY_REL_TYPES","setServerSideListSupport","hasServerSideListSupport","setServerSideFwdPaginationSupport","hasServerSideFwdPaginationSupport","roomState","getLiveTimeline","getState","EventTimeline","FORWARDS","addEventToTimeline","liveTimeline","fromCache","events","addEvents","forEach","ev","addEvent","lastReply","isNewestReply","localTimestamp","decryptEventIfNeeded","initialEventsFetched","fetchEditsWhereNeeded","RelationType","Annotation","Replace","replayEvents","push","relations","aggregateParentEvent","aggregateChildEvent","synthetic","content","getContent","Object","keys","eventId","receiptType","userId","receipt","addReceiptToStructure","getRootEventBundledRelationship","getServerAggregatedRelation","processRootEvent","bundledRelationship","count","current_user_participated","latest_event","room_id","unfilteredPendingEvents","Detached","getPendingEvents","filter","lastPendingEvent","length","undefined","pendingReplyCount","addEventsToTimeline","setPaginationToken","Direction","Backward","paginateEventTimeline","backwards","limit","Math","max","Promise","all","isEncrypted","map","getType","then","makeReplaced","catch","setThread","unsigned","matches","i","replyToEvent","getEvents","has","MatrixEvent","hasCurrentUserParticipated","getUnfilteredTimelineSet","addReceipt","hasUserReadEvent","getUserId","publicReadReceipt","getReadReceiptForUserId","privateReadReceipt","ReadPrivate","hasUnreads","getThreadUnreadNotificationCount","NotificationCountType","Total","ServerControlledNamespacedValue","ThreadFilterType","threadFilterTypeToFilter","type","My"],"sources":["../../src/models/thread.ts"],"sourcesContent":["/*\nCopyright 2021-2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { Optional } from \"matrix-events-sdk\";\n\nimport { MatrixClient, PendingEventOrdering } from \"../client\";\nimport { TypedReEmitter } from \"../ReEmitter\";\nimport { RelationType } from \"../@types/event\";\nimport { IThreadBundledRelationship, MatrixEvent, MatrixEventEvent } from \"./event\";\nimport { Direction, EventTimeline } from \"./event-timeline\";\nimport { EventTimelineSet, EventTimelineSetHandlerMap } from \"./event-timeline-set\";\nimport { NotificationCountType, Room, RoomEvent } from \"./room\";\nimport { RoomState } from \"./room-state\";\nimport { ServerControlledNamespacedValue } from \"../NamespacedValue\";\nimport { logger } from \"../logger\";\nimport { ReadReceipt } from \"./read-receipt\";\nimport { Receipt, ReceiptContent, ReceiptType } from \"../@types/read_receipts\";\n\nexport enum ThreadEvent {\n    New = \"Thread.new\",\n    Update = \"Thread.update\",\n    NewReply = \"Thread.newReply\",\n    ViewThread = \"Thread.viewThread\",\n    Delete = \"Thread.delete\",\n}\n\ntype EmittedEvents = Exclude<ThreadEvent, ThreadEvent.New> | RoomEvent.Timeline | RoomEvent.TimelineReset;\n\nexport type EventHandlerMap = {\n    [ThreadEvent.Update]: (thread: Thread) => void;\n    [ThreadEvent.NewReply]: (thread: Thread, event: MatrixEvent) => void;\n    [ThreadEvent.ViewThread]: () => void;\n    [ThreadEvent.Delete]: (thread: Thread) => void;\n} & EventTimelineSetHandlerMap;\n\ninterface IThreadOpts {\n    room: Room;\n    client: MatrixClient;\n    pendingEventOrdering?: PendingEventOrdering;\n    receipts?: { event: MatrixEvent; synthetic: boolean }[];\n}\n\nexport enum FeatureSupport {\n    None = 0,\n    Experimental = 1,\n    Stable = 2,\n}\n\nexport function determineFeatureSupport(stable: boolean, unstable: boolean): FeatureSupport {\n    if (stable) {\n        return FeatureSupport.Stable;\n    } else if (unstable) {\n        return FeatureSupport.Experimental;\n    } else {\n        return FeatureSupport.None;\n    }\n}\n\n/**\n * @experimental\n */\nexport class Thread extends ReadReceipt<EmittedEvents, EventHandlerMap> {\n    public static hasServerSideSupport = FeatureSupport.None;\n    public static hasServerSideListSupport = FeatureSupport.None;\n    public static hasServerSideFwdPaginationSupport = FeatureSupport.None;\n\n    /**\n     * A reference to all the events ID at the bottom of the threads\n     */\n    public readonly timelineSet: EventTimelineSet;\n    public timeline: MatrixEvent[] = [];\n\n    private _currentUserParticipated = false;\n\n    private reEmitter: TypedReEmitter<EmittedEvents, EventHandlerMap>;\n\n    private lastEvent: MatrixEvent | undefined;\n    private replyCount = 0;\n    private lastPendingEvent: MatrixEvent | undefined;\n    private pendingReplyCount = 0;\n\n    public readonly room: Room;\n    public readonly client: MatrixClient;\n    private readonly pendingEventOrdering: PendingEventOrdering;\n\n    public initialEventsFetched = !Thread.hasServerSideSupport;\n    /**\n     * An array of events to add to the timeline once the thread has been initialised\n     * with server suppport.\n     */\n    public replayEvents: MatrixEvent[] | null = [];\n\n    public constructor(public readonly id: string, public rootEvent: MatrixEvent | undefined, opts: IThreadOpts) {\n        super();\n\n        if (!opts?.room) {\n            // Logging/debugging for https://github.com/vector-im/element-web/issues/22141\n            // Hope is that we end up with a more obvious stack trace.\n            throw new Error(\"element-web#22141: A thread requires a room in order to function\");\n        }\n\n        this.room = opts.room;\n        this.client = opts.client;\n        this.pendingEventOrdering = opts.pendingEventOrdering ?? PendingEventOrdering.Chronological;\n        this.timelineSet = new EventTimelineSet(\n            this.room,\n            {\n                timelineSupport: true,\n                pendingEvents: true,\n            },\n            this.client,\n            this,\n        );\n        this.reEmitter = new TypedReEmitter(this);\n\n        this.reEmitter.reEmit(this.timelineSet, [RoomEvent.Timeline, RoomEvent.TimelineReset]);\n\n        this.room.on(MatrixEventEvent.BeforeRedaction, this.onBeforeRedaction);\n        this.room.on(RoomEvent.Redaction, this.onRedaction);\n        this.room.on(RoomEvent.LocalEchoUpdated, this.onLocalEcho);\n        this.timelineSet.on(RoomEvent.Timeline, this.onTimelineEvent);\n\n        this.processReceipts(opts.receipts);\n\n        // even if this thread is thought to be originating from this client, we initialise it as we may be in a\n        // gappy sync and a thread around this event may already exist.\n        this.updateThreadMetadata();\n        this.setEventMetadata(this.rootEvent);\n    }\n\n    private async fetchRootEvent(): Promise<void> {\n        this.rootEvent = this.room.findEventById(this.id);\n        // If the rootEvent does not exist in the local stores, then fetch it from the server.\n        try {\n            const eventData = await this.client.fetchRoomEvent(this.roomId, this.id);\n            const mapper = this.client.getEventMapper();\n            this.rootEvent = mapper(eventData); // will merge with existing event object if such is known\n        } catch (e) {\n            logger.error(\"Failed to fetch thread root to construct thread with\", e);\n        }\n        await this.processEvent(this.rootEvent);\n    }\n\n    public static setServerSideSupport(status: FeatureSupport): void {\n        Thread.hasServerSideSupport = status;\n        if (status !== FeatureSupport.Stable) {\n            FILTER_RELATED_BY_SENDERS.setPreferUnstable(true);\n            FILTER_RELATED_BY_REL_TYPES.setPreferUnstable(true);\n            THREAD_RELATION_TYPE.setPreferUnstable(true);\n        }\n    }\n\n    public static setServerSideListSupport(status: FeatureSupport): void {\n        Thread.hasServerSideListSupport = status;\n    }\n\n    public static setServerSideFwdPaginationSupport(status: FeatureSupport): void {\n        Thread.hasServerSideFwdPaginationSupport = status;\n    }\n\n    private onBeforeRedaction = (event: MatrixEvent, redaction: MatrixEvent): void => {\n        if (\n            event?.isRelation(THREAD_RELATION_TYPE.name) &&\n            this.room.eventShouldLiveIn(event).threadId === this.id &&\n            event.getId() !== this.id && // the root event isn't counted in the length so ignore this redaction\n            !redaction.status // only respect it when it succeeds\n        ) {\n            this.replyCount--;\n            this.updatePendingReplyCount();\n            this.emit(ThreadEvent.Update, this);\n        }\n    };\n\n    private onRedaction = async (event: MatrixEvent): Promise<void> => {\n        if (event.threadRootId !== this.id) return; // ignore redactions for other timelines\n        if (this.replyCount <= 0) {\n            for (const threadEvent of this.timeline) {\n                this.clearEventMetadata(threadEvent);\n            }\n            this.lastEvent = this.rootEvent;\n            this._currentUserParticipated = false;\n            this.emit(ThreadEvent.Delete, this);\n        } else {\n            await this.updateThreadMetadata();\n        }\n    };\n\n    private onTimelineEvent = (\n        event: MatrixEvent,\n        room: Room | undefined,\n        toStartOfTimeline: boolean | undefined,\n    ): void => {\n        // Add a synthesized receipt when paginating forward in the timeline\n        if (!toStartOfTimeline) {\n            room!.addLocalEchoReceipt(event.getSender()!, event, ReceiptType.Read);\n        }\n        this.onEcho(event, toStartOfTimeline ?? false);\n    };\n\n    private onLocalEcho = (event: MatrixEvent): void => {\n        this.onEcho(event, false);\n    };\n\n    private onEcho = async (event: MatrixEvent, toStartOfTimeline: boolean): Promise<void> => {\n        if (event.threadRootId !== this.id) return; // ignore echoes for other timelines\n        if (this.lastEvent === event) return; // ignore duplicate events\n        await this.updateThreadMetadata();\n        if (!event.isRelation(THREAD_RELATION_TYPE.name)) return; // don't send a new reply event for reactions or edits\n        if (toStartOfTimeline) return; // ignore messages added to the start of the timeline\n        this.emit(ThreadEvent.NewReply, this, event);\n    };\n\n    public get roomState(): RoomState {\n        return this.room.getLiveTimeline().getState(EventTimeline.FORWARDS)!;\n    }\n\n    private addEventToTimeline(event: MatrixEvent, toStartOfTimeline: boolean): void {\n        if (!this.findEventById(event.getId()!)) {\n            this.timelineSet.addEventToTimeline(event, this.liveTimeline, {\n                toStartOfTimeline,\n                fromCache: false,\n                roomState: this.roomState,\n            });\n            this.timeline = this.events;\n        }\n    }\n\n    public addEvents(events: MatrixEvent[], toStartOfTimeline: boolean): void {\n        events.forEach((ev) => this.addEvent(ev, toStartOfTimeline, false));\n        this.updateThreadMetadata();\n    }\n\n    /**\n     * Add an event to the thread and updates\n     * the tail/root references if needed\n     * Will fire \"Thread.update\"\n     * @param event - The event to add\n     * @param toStartOfTimeline - whether the event is being added\n     * to the start (and not the end) of the timeline.\n     * @param emit - whether to emit the Update event if the thread was updated or not.\n     */\n    public async addEvent(event: MatrixEvent, toStartOfTimeline: boolean, emit = true): Promise<void> {\n        this.setEventMetadata(event);\n\n        const lastReply = this.lastReply();\n        const isNewestReply = !lastReply || event.localTimestamp > lastReply!.localTimestamp;\n\n        // Add all incoming events to the thread's timeline set when there's  no server support\n        if (!Thread.hasServerSideSupport) {\n            // all the relevant membership info to hydrate events with a sender\n            // is held in the main room timeline\n            // We want to fetch the room state from there and pass it down to this thread\n            // timeline set to let it reconcile an event with its relevant RoomMember\n            this.addEventToTimeline(event, toStartOfTimeline);\n\n            this.client.decryptEventIfNeeded(event, {});\n        } else if (!toStartOfTimeline && this.initialEventsFetched && isNewestReply) {\n            this.addEventToTimeline(event, false);\n            this.fetchEditsWhereNeeded(event);\n        } else if (event.isRelation(RelationType.Annotation) || event.isRelation(RelationType.Replace)) {\n            if (!this.initialEventsFetched) {\n                /**\n                 * A thread can be fully discovered via a single sync response\n                 * And when that's the case we still ask the server to do an initialisation\n                 * as it's the safest to ensure we have everything.\n                 * However when we are in that scenario we might loose annotation or edits\n                 *\n                 * This fix keeps a reference to those events and replay them once the thread\n                 * has been initialised properly.\n                 */\n                this.replayEvents?.push(event);\n            } else {\n                this.addEventToTimeline(event, toStartOfTimeline);\n            }\n            // Apply annotations and replace relations to the relations of the timeline only\n            this.timelineSet.relations?.aggregateParentEvent(event);\n            this.timelineSet.relations?.aggregateChildEvent(event, this.timelineSet);\n            return;\n        }\n\n        // If no thread support exists we want to count all thread relation\n        // added as a reply. We can't rely on the bundled relationships count\n        if ((!Thread.hasServerSideSupport || !this.rootEvent) && event.isRelation(THREAD_RELATION_TYPE.name)) {\n            this.replyCount++;\n        }\n\n        if (emit) {\n            this.emit(ThreadEvent.NewReply, this, event);\n            this.updateThreadMetadata();\n        }\n    }\n\n    public async processEvent(event: Optional<MatrixEvent>): Promise<void> {\n        if (event) {\n            this.setEventMetadata(event);\n            await this.fetchEditsWhereNeeded(event);\n        }\n        this.timeline = this.events;\n    }\n\n    /**\n     * Processes the receipts that were caught during initial sync\n     * When clients become aware of a thread, they try to retrieve those read receipts\n     * and apply them to the current thread\n     * @param receipts - A collection of the receipts cached from initial sync\n     */\n    private processReceipts(receipts: { event: MatrixEvent; synthetic: boolean }[] = []): void {\n        for (const { event, synthetic } of receipts) {\n            const content = event.getContent<ReceiptContent>();\n            Object.keys(content).forEach((eventId: string) => {\n                Object.keys(content[eventId]).forEach((receiptType: ReceiptType | string) => {\n                    Object.keys(content[eventId][receiptType]).forEach((userId: string) => {\n                        const receipt = content[eventId][receiptType][userId] as Receipt;\n                        this.addReceiptToStructure(eventId, receiptType as ReceiptType, userId, receipt, synthetic);\n                    });\n                });\n            });\n        }\n    }\n\n    private getRootEventBundledRelationship(rootEvent = this.rootEvent): IThreadBundledRelationship | undefined {\n        return rootEvent?.getServerAggregatedRelation<IThreadBundledRelationship>(THREAD_RELATION_TYPE.name);\n    }\n\n    private async processRootEvent(): Promise<void> {\n        const bundledRelationship = this.getRootEventBundledRelationship();\n        if (Thread.hasServerSideSupport && bundledRelationship) {\n            this.replyCount = bundledRelationship.count;\n            this._currentUserParticipated = !!bundledRelationship.current_user_participated;\n\n            const mapper = this.client.getEventMapper();\n            // re-insert roomId\n            this.lastEvent = mapper({\n                ...bundledRelationship.latest_event,\n                room_id: this.roomId,\n            });\n            this.updatePendingReplyCount();\n            await this.processEvent(this.lastEvent);\n        }\n    }\n\n    private updatePendingReplyCount(): void {\n        const unfilteredPendingEvents =\n            this.pendingEventOrdering === PendingEventOrdering.Detached ? this.room.getPendingEvents() : this.events;\n        const pendingEvents = unfilteredPendingEvents.filter(\n            (ev) =>\n                ev.threadRootId === this.id &&\n                ev.isRelation(THREAD_RELATION_TYPE.name) &&\n                ev.status !== null &&\n                ev.getId() !== this.lastEvent?.getId(),\n        );\n        this.lastPendingEvent = pendingEvents.length ? pendingEvents[pendingEvents.length - 1] : undefined;\n        this.pendingReplyCount = pendingEvents.length;\n    }\n\n    private async updateThreadMetadata(): Promise<void> {\n        this.updatePendingReplyCount();\n\n        if (Thread.hasServerSideSupport) {\n            // Ensure we show *something* as soon as possible, we'll update it as soon as we get better data, but we\n            // don't want the thread preview to be empty if we can avoid it\n            if (!this.initialEventsFetched) {\n                await this.processRootEvent();\n            }\n            await this.fetchRootEvent();\n        }\n        await this.processRootEvent();\n\n        if (!this.initialEventsFetched) {\n            this.initialEventsFetched = true;\n            // fetch initial event to allow proper pagination\n            try {\n                // if the thread has regular events, this will just load the last reply.\n                // if the thread is newly created, this will load the root event.\n                if (this.replyCount === 0 && this.rootEvent) {\n                    this.timelineSet.addEventsToTimeline([this.rootEvent], true, this.liveTimeline, null);\n                    this.liveTimeline.setPaginationToken(null, Direction.Backward);\n                } else {\n                    await this.client.paginateEventTimeline(this.liveTimeline, {\n                        backwards: true,\n                        limit: Math.max(1, this.length),\n                    });\n                }\n                for (const event of this.replayEvents!) {\n                    this.addEvent(event, false);\n                }\n                this.replayEvents = null;\n                // just to make sure that, if we've created a timeline window for this thread before the thread itself\n                // existed (e.g. when creating a new thread), we'll make sure the panel is force refreshed correctly.\n                this.emit(RoomEvent.TimelineReset, this.room, this.timelineSet, true);\n            } catch (e) {\n                logger.error(\"Failed to load start of newly created thread: \", e);\n                this.initialEventsFetched = false;\n            }\n        }\n\n        this.emit(ThreadEvent.Update, this);\n    }\n\n    // XXX: Workaround for https://github.com/matrix-org/matrix-spec-proposals/pull/2676/files#r827240084\n    private async fetchEditsWhereNeeded(...events: MatrixEvent[]): Promise<unknown> {\n        return Promise.all(\n            events\n                .filter((e) => e.isEncrypted())\n                .map((event: MatrixEvent) => {\n                    if (event.isRelation()) return; // skip - relations don't get edits\n                    return this.client\n                        .relations(this.roomId, event.getId()!, RelationType.Replace, event.getType(), {\n                            limit: 1,\n                        })\n                        .then((relations) => {\n                            if (relations.events.length) {\n                                event.makeReplaced(relations.events[0]);\n                            }\n                        })\n                        .catch((e) => {\n                            logger.error(\"Failed to load edits for encrypted thread event\", e);\n                        });\n                }),\n        );\n    }\n\n    public setEventMetadata(event: Optional<MatrixEvent>): void {\n        if (event) {\n            EventTimeline.setEventMetadata(event, this.roomState, false);\n            event.setThread(this);\n        }\n    }\n\n    public clearEventMetadata(event: Optional<MatrixEvent>): void {\n        if (event) {\n            event.setThread(undefined);\n            delete event.event?.unsigned?.[\"m.relations\"]?.[THREAD_RELATION_TYPE.name];\n        }\n    }\n\n    /**\n     * Finds an event by ID in the current thread\n     */\n    public findEventById(eventId: string): MatrixEvent | undefined {\n        return this.timelineSet.findEventById(eventId);\n    }\n\n    /**\n     * Return last reply to the thread, if known.\n     */\n    public lastReply(matches: (ev: MatrixEvent) => boolean = (): boolean => true): MatrixEvent | null {\n        for (let i = this.timeline.length - 1; i >= 0; i--) {\n            const event = this.timeline[i];\n            if (matches(event)) {\n                return event;\n            }\n        }\n        return null;\n    }\n\n    public get roomId(): string {\n        return this.room.roomId;\n    }\n\n    /**\n     * The number of messages in the thread\n     * Only count rel_type=m.thread as we want to\n     * exclude annotations from that number\n     */\n    public get length(): number {\n        return this.replyCount + this.pendingReplyCount;\n    }\n\n    /**\n     * A getter for the last event of the thread.\n     * This might be a synthesized event, if so, it will not emit any events to listeners.\n     */\n    public get replyToEvent(): Optional<MatrixEvent> {\n        return this.lastPendingEvent ?? this.lastEvent ?? this.lastReply();\n    }\n\n    public get events(): MatrixEvent[] {\n        return this.liveTimeline.getEvents();\n    }\n\n    public has(eventId: string): boolean {\n        return this.timelineSet.findEventById(eventId) instanceof MatrixEvent;\n    }\n\n    public get hasCurrentUserParticipated(): boolean {\n        return this._currentUserParticipated;\n    }\n\n    public get liveTimeline(): EventTimeline {\n        return this.timelineSet.getLiveTimeline();\n    }\n\n    public getUnfilteredTimelineSet(): EventTimelineSet {\n        return this.timelineSet;\n    }\n\n    public addReceipt(event: MatrixEvent, synthetic: boolean): void {\n        throw new Error(\"Unsupported function on the thread model\");\n    }\n\n    public hasUserReadEvent(userId: string, eventId: string): boolean {\n        if (userId === this.client.getUserId()) {\n            const publicReadReceipt = this.getReadReceiptForUserId(userId, false, ReceiptType.Read);\n            const privateReadReceipt = this.getReadReceiptForUserId(userId, false, ReceiptType.ReadPrivate);\n            const hasUnreads = this.room.getThreadUnreadNotificationCount(this.id, NotificationCountType.Total) > 0;\n\n            if (!publicReadReceipt && !privateReadReceipt && !hasUnreads) {\n                // Consider an event read if it's part of a thread that has no\n                // read receipts and has no notifications. It is likely that it is\n                // part of a thread that was created before read receipts for threads\n                // were supported (via MSC3771)\n                return true;\n            }\n        }\n\n        return super.hasUserReadEvent(userId, eventId);\n    }\n}\n\nexport const FILTER_RELATED_BY_SENDERS = new ServerControlledNamespacedValue(\n    \"related_by_senders\",\n    \"io.element.relation_senders\",\n);\nexport const FILTER_RELATED_BY_REL_TYPES = new ServerControlledNamespacedValue(\n    \"related_by_rel_types\",\n    \"io.element.relation_types\",\n);\nexport const THREAD_RELATION_TYPE = new ServerControlledNamespacedValue(\"m.thread\", \"io.element.thread\");\n\nexport enum ThreadFilterType {\n    \"My\",\n    \"All\",\n}\n\nexport function threadFilterTypeToFilter(type: ThreadFilterType | null): \"all\" | \"participated\" {\n    switch (type) {\n        case ThreadFilterType.My:\n            return \"participated\";\n        default:\n            return \"all\";\n    }\n}\n"],"mappings":"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"}