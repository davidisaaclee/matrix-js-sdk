{"version":3,"file":"autodiscovery.js","names":["AutoDiscoveryAction","AutoDiscoveryError","AutoDiscovery","fromDiscoveryConfig","wellknown","clientConfig","state","FAIL_ERROR","error","ERROR_INVALID","base_url","PROMPT","logger","FAIL_PROMPT","Promise","resolve","ERROR_INVALID_HS_BASE_URL","hsUrl","sanitizeWellKnownUrl","hsVersions","fetchWellKnownObject","raw","ERROR_INVALID_HOMESERVER","SUCCESS","isUrl","failingClientConfig","ERROR_INVALID_IS","ERROR_INVALID_IS_BASE_URL","isResponse","action","ERROR_INVALID_IDENTITY_SERVER","toString","length","Object","keys","forEach","k","notProps","prop","includes","findClientConfig","domain","Error","reason","IGNORE","getRawClientConfig","response","url","parsed","URL","e","hostname","protocol","port","path","pathname","saferUrl","endsWith","substring","fetch","resource","options","fetchFn","global","setFetchFn","method","Method","Get","signal","timeoutSignal","status","ERROR_MISSING_WELLKNOWN","ok","err","message","json","name","ERROR_INVALID_JSON","Invalid","GenericFailure","InvalidHsBaseUrl","InvalidHomeserver","InvalidIsBaseUrl","InvalidIdentityServer","InvalidIs","MissingWellknown","InvalidJson"],"sources":["../src/autodiscovery.ts"],"sourcesContent":["/*\nCopyright 2018 New Vector Ltd\nCopyright 2019 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { IClientWellKnown, IWellKnownConfig } from \"./client\";\nimport { logger } from \"./logger\";\nimport { MatrixError, Method, timeoutSignal } from \"./http-api\";\n\n// Dev note: Auto discovery is part of the spec.\n// See: https://matrix.org/docs/spec/client_server/r0.4.0.html#server-discovery\n\nexport enum AutoDiscoveryAction {\n    SUCCESS = \"SUCCESS\",\n    IGNORE = \"IGNORE\",\n    PROMPT = \"PROMPT\",\n    FAIL_PROMPT = \"FAIL_PROMPT\",\n    FAIL_ERROR = \"FAIL_ERROR\",\n}\n\nenum AutoDiscoveryError {\n    Invalid = \"Invalid homeserver discovery response\",\n    GenericFailure = \"Failed to get autodiscovery configuration from server\",\n    InvalidHsBaseUrl = \"Invalid base_url for m.homeserver\",\n    InvalidHomeserver = \"Homeserver URL does not appear to be a valid Matrix homeserver\",\n    InvalidIsBaseUrl = \"Invalid base_url for m.identity_server\",\n    InvalidIdentityServer = \"Identity server URL does not appear to be a valid identity server\",\n    InvalidIs = \"Invalid identity server discovery response\",\n    MissingWellknown = \"No .well-known JSON file found\",\n    InvalidJson = \"Invalid JSON\",\n}\n\ninterface WellKnownConfig extends Omit<IWellKnownConfig, \"error\"> {\n    state: AutoDiscoveryAction;\n    error?: IWellKnownConfig[\"error\"] | null;\n}\n\ninterface ClientConfig extends Omit<IClientWellKnown, \"m.homeserver\" | \"m.identity_server\"> {\n    \"m.homeserver\": WellKnownConfig;\n    \"m.identity_server\": WellKnownConfig;\n}\n\n/**\n * Utilities for automatically discovery resources, such as homeservers\n * for users to log in to.\n */\nexport class AutoDiscovery {\n    // Dev note: the constants defined here are related to but not\n    // exactly the same as those in the spec. This is to hopefully\n    // translate the meaning of the states in the spec, but also\n    // support our own if needed.\n\n    public static readonly ERROR_INVALID = AutoDiscoveryError.Invalid;\n\n    public static readonly ERROR_GENERIC_FAILURE = AutoDiscoveryError.GenericFailure;\n\n    public static readonly ERROR_INVALID_HS_BASE_URL = AutoDiscoveryError.InvalidHsBaseUrl;\n\n    public static readonly ERROR_INVALID_HOMESERVER = AutoDiscoveryError.InvalidHomeserver;\n\n    public static readonly ERROR_INVALID_IS_BASE_URL = AutoDiscoveryError.InvalidIsBaseUrl;\n\n    public static readonly ERROR_INVALID_IDENTITY_SERVER = AutoDiscoveryError.InvalidIdentityServer;\n\n    public static readonly ERROR_INVALID_IS = AutoDiscoveryError.InvalidIs;\n\n    public static readonly ERROR_MISSING_WELLKNOWN = AutoDiscoveryError.MissingWellknown;\n\n    public static readonly ERROR_INVALID_JSON = AutoDiscoveryError.InvalidJson;\n\n    public static readonly ALL_ERRORS = Object.keys(AutoDiscoveryError);\n\n    /**\n     * The auto discovery failed. The client is expected to communicate\n     * the error to the user and refuse logging in.\n     */\n    public static readonly FAIL_ERROR = AutoDiscoveryAction.FAIL_ERROR;\n\n    /**\n     * The auto discovery failed, however the client may still recover\n     * from the problem. The client is recommended to that the same\n     * action it would for PROMPT while also warning the user about\n     * what went wrong. The client may also treat this the same as\n     * a FAIL_ERROR state.\n     */\n    public static readonly FAIL_PROMPT = AutoDiscoveryAction.FAIL_PROMPT;\n\n    /**\n     * The auto discovery didn't fail but did not find anything of\n     * interest. The client is expected to prompt the user for more\n     * information, or fail if it prefers.\n     */\n    public static readonly PROMPT = AutoDiscoveryAction.PROMPT;\n\n    /**\n     * The auto discovery was successful.\n     */\n    public static readonly SUCCESS = AutoDiscoveryAction.SUCCESS;\n\n    /**\n     * Validates and verifies client configuration information for purposes\n     * of logging in. Such information includes the homeserver URL\n     * and identity server URL the client would want. Additional details\n     * may also be included, and will be transparently brought into the\n     * response object unaltered.\n     * @param wellknown - The configuration object itself, as returned\n     * by the .well-known auto-discovery endpoint.\n     * @returns Promise which resolves to the verified\n     * configuration, which may include error states. Rejects on unexpected\n     * failure, not when verification fails.\n     */\n    public static async fromDiscoveryConfig(wellknown: IClientWellKnown): Promise<ClientConfig> {\n        // Step 1 is to get the config, which is provided to us here.\n\n        // We default to an error state to make the first few checks easier to\n        // write. We'll update the properties of this object over the duration\n        // of this function.\n        const clientConfig: ClientConfig = {\n            \"m.homeserver\": {\n                state: AutoDiscovery.FAIL_ERROR,\n                error: AutoDiscovery.ERROR_INVALID,\n                base_url: null,\n            },\n            \"m.identity_server\": {\n                // Technically, we don't have a problem with the identity server\n                // config at this point.\n                state: AutoDiscovery.PROMPT,\n                error: null,\n                base_url: null,\n            },\n        };\n\n        if (!wellknown || !wellknown[\"m.homeserver\"]) {\n            logger.error(\"No m.homeserver key in config\");\n\n            clientConfig[\"m.homeserver\"].state = AutoDiscovery.FAIL_PROMPT;\n            clientConfig[\"m.homeserver\"].error = AutoDiscovery.ERROR_INVALID;\n\n            return Promise.resolve(clientConfig);\n        }\n\n        if (!wellknown[\"m.homeserver\"][\"base_url\"]) {\n            logger.error(\"No m.homeserver base_url in config\");\n\n            clientConfig[\"m.homeserver\"].state = AutoDiscovery.FAIL_PROMPT;\n            clientConfig[\"m.homeserver\"].error = AutoDiscovery.ERROR_INVALID_HS_BASE_URL;\n\n            return Promise.resolve(clientConfig);\n        }\n\n        // Step 2: Make sure the homeserver URL is valid *looking*. We'll make\n        // sure it points to a homeserver in Step 3.\n        const hsUrl = this.sanitizeWellKnownUrl(wellknown[\"m.homeserver\"][\"base_url\"]);\n        if (!hsUrl) {\n            logger.error(\"Invalid base_url for m.homeserver\");\n            clientConfig[\"m.homeserver\"].error = AutoDiscovery.ERROR_INVALID_HS_BASE_URL;\n            return Promise.resolve(clientConfig);\n        }\n\n        // Step 3: Make sure the homeserver URL points to a homeserver.\n        const hsVersions = await this.fetchWellKnownObject(`${hsUrl}/_matrix/client/versions`);\n        if (!hsVersions || !hsVersions.raw?.[\"versions\"]) {\n            logger.error(\"Invalid /versions response\");\n            clientConfig[\"m.homeserver\"].error = AutoDiscovery.ERROR_INVALID_HOMESERVER;\n\n            // Supply the base_url to the caller because they may be ignoring liveliness\n            // errors, like this one.\n            clientConfig[\"m.homeserver\"].base_url = hsUrl;\n\n            return Promise.resolve(clientConfig);\n        }\n\n        // Step 4: Now that the homeserver looks valid, update our client config.\n        clientConfig[\"m.homeserver\"] = {\n            state: AutoDiscovery.SUCCESS,\n            error: null,\n            base_url: hsUrl,\n        };\n\n        // Step 5: Try to pull out the identity server configuration\n        let isUrl: string | boolean = \"\";\n        if (wellknown[\"m.identity_server\"]) {\n            // We prepare a failing identity server response to save lines later\n            // in this branch.\n            const failingClientConfig: ClientConfig = {\n                \"m.homeserver\": clientConfig[\"m.homeserver\"],\n                \"m.identity_server\": {\n                    state: AutoDiscovery.FAIL_PROMPT,\n                    error: AutoDiscovery.ERROR_INVALID_IS,\n                    base_url: null,\n                },\n            };\n\n            // Step 5a: Make sure the URL is valid *looking*. We'll make sure it\n            // points to an identity server in Step 5b.\n            isUrl = this.sanitizeWellKnownUrl(wellknown[\"m.identity_server\"][\"base_url\"]);\n            if (!isUrl) {\n                logger.error(\"Invalid base_url for m.identity_server\");\n                failingClientConfig[\"m.identity_server\"].error = AutoDiscovery.ERROR_INVALID_IS_BASE_URL;\n                return Promise.resolve(failingClientConfig);\n            }\n\n            // Step 5b: Verify there is an identity server listening on the provided\n            // URL.\n            const isResponse = await this.fetchWellKnownObject(`${isUrl}/_matrix/identity/api/v1`);\n            if (!isResponse?.raw || isResponse.action !== AutoDiscoveryAction.SUCCESS) {\n                logger.error(\"Invalid /api/v1 response\");\n                failingClientConfig[\"m.identity_server\"].error = AutoDiscovery.ERROR_INVALID_IDENTITY_SERVER;\n\n                // Supply the base_url to the caller because they may be ignoring\n                // liveliness errors, like this one.\n                failingClientConfig[\"m.identity_server\"].base_url = isUrl;\n\n                return Promise.resolve(failingClientConfig);\n            }\n        }\n\n        // Step 6: Now that the identity server is valid, or never existed,\n        // populate the IS section.\n        if (isUrl && isUrl.toString().length > 0) {\n            clientConfig[\"m.identity_server\"] = {\n                state: AutoDiscovery.SUCCESS,\n                error: null,\n                base_url: isUrl,\n            };\n        }\n\n        // Step 7: Copy any other keys directly into the clientConfig. This is for\n        // things like custom configuration of services.\n        Object.keys(wellknown).forEach((k: keyof IClientWellKnown) => {\n            if (k === \"m.homeserver\" || k === \"m.identity_server\") {\n                // Only copy selected parts of the config to avoid overwriting\n                // properties computed by the validation logic above.\n                const notProps = [\"error\", \"state\", \"base_url\"];\n                for (const prop of Object.keys(wellknown[k]!)) {\n                    if (notProps.includes(prop)) continue;\n                    type Prop = Exclude<keyof IWellKnownConfig, \"error\" | \"state\" | \"base_url\">;\n                    // @ts-ignore - ts gets unhappy as we're mixing types here\n                    clientConfig[k][prop as Prop] = wellknown[k]![prop as Prop];\n                }\n            } else {\n                // Just copy the whole thing over otherwise\n                clientConfig[k] = wellknown[k];\n            }\n        });\n\n        // Step 8: Give the config to the caller (finally)\n        return Promise.resolve(clientConfig);\n    }\n\n    /**\n     * Attempts to automatically discover client configuration information\n     * prior to logging in. Such information includes the homeserver URL\n     * and identity server URL the client would want. Additional details\n     * may also be discovered, and will be transparently included in the\n     * response object unaltered.\n     * @param domain - The homeserver domain to perform discovery\n     * on. For example, \"matrix.org\".\n     * @returns Promise which resolves to the discovered\n     * configuration, which may include error states. Rejects on unexpected\n     * failure, not when discovery fails.\n     */\n    public static async findClientConfig(domain: string): Promise<ClientConfig> {\n        if (!domain || typeof domain !== \"string\" || domain.length === 0) {\n            throw new Error(\"'domain' must be a string of non-zero length\");\n        }\n\n        // We use a .well-known lookup for all cases. According to the spec, we\n        // can do other discovery mechanisms if we want such as custom lookups\n        // however we won't bother with that here (mostly because the spec only\n        // supports .well-known right now).\n        //\n        // By using .well-known, we need to ensure we at least pull out a URL\n        // for the homeserver. We don't really need an identity server configuration\n        // but will return one anyways (with state PROMPT) to make development\n        // easier for clients. If we can't get a homeserver URL, all bets are\n        // off on the rest of the config and we'll assume it is invalid too.\n\n        // We default to an error state to make the first few checks easier to\n        // write. We'll update the properties of this object over the duration\n        // of this function.\n        const clientConfig: ClientConfig = {\n            \"m.homeserver\": {\n                state: AutoDiscovery.FAIL_ERROR,\n                error: AutoDiscovery.ERROR_INVALID,\n                base_url: null,\n            },\n            \"m.identity_server\": {\n                // Technically, we don't have a problem with the identity server\n                // config at this point.\n                state: AutoDiscovery.PROMPT,\n                error: null,\n                base_url: null,\n            },\n        };\n\n        // Step 1: Actually request the .well-known JSON file and make sure it\n        // at least has a homeserver definition.\n        const wellknown = await this.fetchWellKnownObject(`https://${domain}/.well-known/matrix/client`);\n        if (!wellknown || wellknown.action !== AutoDiscoveryAction.SUCCESS) {\n            logger.error(\"No response or error when parsing .well-known\");\n            if (wellknown.reason) logger.error(wellknown.reason);\n            if (wellknown.action === AutoDiscoveryAction.IGNORE) {\n                clientConfig[\"m.homeserver\"] = {\n                    state: AutoDiscovery.PROMPT,\n                    error: null,\n                    base_url: null,\n                };\n            } else {\n                // this can only ever be FAIL_PROMPT at this point.\n                clientConfig[\"m.homeserver\"].state = AutoDiscovery.FAIL_PROMPT;\n                clientConfig[\"m.homeserver\"].error = AutoDiscovery.ERROR_INVALID;\n            }\n            return Promise.resolve(clientConfig);\n        }\n\n        // Step 2: Validate and parse the config\n        return AutoDiscovery.fromDiscoveryConfig(wellknown.raw!);\n    }\n\n    /**\n     * Gets the raw discovery client configuration for the given domain name.\n     * Should only be used if there's no validation to be done on the resulting\n     * object, otherwise use findClientConfig().\n     * @param domain - The domain to get the client config for.\n     * @returns Promise which resolves to the domain's client config. Can\n     * be an empty object.\n     */\n    public static async getRawClientConfig(domain?: string): Promise<IClientWellKnown> {\n        if (!domain || typeof domain !== \"string\" || domain.length === 0) {\n            throw new Error(\"'domain' must be a string of non-zero length\");\n        }\n\n        const response = await this.fetchWellKnownObject(`https://${domain}/.well-known/matrix/client`);\n        if (!response) return {};\n        return response.raw || {};\n    }\n\n    /**\n     * Sanitizes a given URL to ensure it is either an HTTP or HTTP URL and\n     * is suitable for the requirements laid out by .well-known auto discovery.\n     * If valid, the URL will also be stripped of any trailing slashes.\n     * @param url - The potentially invalid URL to sanitize.\n     * @returns The sanitized URL or a falsey value if the URL is invalid.\n     * @internal\n     */\n    private static sanitizeWellKnownUrl(url?: string | null): string | false {\n        if (!url) return false;\n\n        try {\n            let parsed: URL | undefined;\n            try {\n                parsed = new URL(url);\n            } catch (e) {\n                logger.error(\"Could not parse url\", e);\n            }\n\n            if (!parsed?.hostname) return false;\n            if (parsed.protocol !== \"http:\" && parsed.protocol !== \"https:\") return false;\n\n            const port = parsed.port ? `:${parsed.port}` : \"\";\n            const path = parsed.pathname ? parsed.pathname : \"\";\n            let saferUrl = `${parsed.protocol}//${parsed.hostname}${port}${path}`;\n            if (saferUrl.endsWith(\"/\")) {\n                saferUrl = saferUrl.substring(0, saferUrl.length - 1);\n            }\n            return saferUrl;\n        } catch (e) {\n            logger.error(e);\n            return false;\n        }\n    }\n\n    private static fetch(resource: URL | string, options?: RequestInit): ReturnType<typeof global.fetch> {\n        if (this.fetchFn) {\n            return this.fetchFn(resource, options);\n        }\n        return global.fetch(resource, options);\n    }\n\n    private static fetchFn?: typeof global.fetch;\n\n    public static setFetchFn(fetchFn: typeof global.fetch): void {\n        AutoDiscovery.fetchFn = fetchFn;\n    }\n\n    /**\n     * Fetches a JSON object from a given URL, as expected by all .well-known\n     * related lookups. If the server gives a 404 then the `action` will be\n     * IGNORE. If the server returns something that isn't JSON, the `action`\n     * will be FAIL_PROMPT. For any other failure the `action` will be FAIL_PROMPT.\n     *\n     * The returned object will be a result of the call in object form with\n     * the following properties:\n     *   raw: The JSON object returned by the server.\n     *   action: One of SUCCESS, IGNORE, or FAIL_PROMPT.\n     *   reason: Relatively human-readable description of what went wrong.\n     *   error: The actual Error, if one exists.\n     * @param url - The URL to fetch a JSON object from.\n     * @returns Promise which resolves to the returned state.\n     * @internal\n     */\n    private static async fetchWellKnownObject(url: string): Promise<IWellKnownConfig> {\n        let response: Response;\n\n        try {\n            response = await AutoDiscovery.fetch(url, {\n                method: Method.Get,\n                signal: timeoutSignal(5000),\n            });\n\n            if (response.status === 404) {\n                return {\n                    raw: {},\n                    action: AutoDiscoveryAction.IGNORE,\n                    reason: AutoDiscovery.ERROR_MISSING_WELLKNOWN,\n                };\n            }\n\n            if (!response.ok) {\n                return {\n                    raw: {},\n                    action: AutoDiscoveryAction.FAIL_PROMPT,\n                    reason: \"General failure\",\n                };\n            }\n        } catch (err) {\n            const error = err as AutoDiscoveryError | string | undefined;\n            let reason = \"\";\n            if (typeof error === \"object\") {\n                reason = (<Error>error)?.message;\n            }\n\n            return {\n                error,\n                raw: {},\n                action: AutoDiscoveryAction.FAIL_PROMPT,\n                reason: reason || \"General failure\",\n            };\n        }\n\n        try {\n            return {\n                raw: await response.json(),\n                action: AutoDiscoveryAction.SUCCESS,\n            };\n        } catch (err) {\n            const error = err as Error;\n            return {\n                error,\n                raw: {},\n                action: AutoDiscoveryAction.FAIL_PROMPT,\n                reason:\n                    (error as MatrixError)?.name === \"SyntaxError\"\n                        ? AutoDiscovery.ERROR_INVALID_JSON\n                        : AutoDiscovery.ERROR_INVALID,\n            };\n        }\n    }\n}\n"],"mappings":"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"}